<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Temp | Eysiking</title><meta name="author" content="Eysiking,eysikinge@gmail.com"><meta name="copyright" content="Eysiking"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="DP‍    简介SOS-DP，英文名 Sum over Subsets(SOS) dynamic programming，即子集和DP，用来求某一集合的所有子集对应状态之和。 给定一个含 $2^N$ 个元素的集合 $A$，下标用 $i$ 来表示，求一个 $F_{state}$，对应为：$$F_{state}&#x3D;\sum_{i\subseteq state &#x2F; i \tex">
<meta property="og:type" content="article">
<meta property="og:title" content="Temp">
<meta property="og:url" content="http://lineagestar.github.io/2025/08/19/Algorithm/x/index.html">
<meta property="og:site_name" content="Eysiking">
<meta property="og:description" content="DP‍    简介SOS-DP，英文名 Sum over Subsets(SOS) dynamic programming，即子集和DP，用来求某一集合的所有子集对应状态之和。 给定一个含 $2^N$ 个元素的集合 $A$，下标用 $i$ 来表示，求一个 $F_{state}$，对应为：$$F_{state}&#x3D;\sum_{i\subseteq state &#x2F; i \tex">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://eysiking-photo.oss-cn-hangzhou.aliyuncs.com/img/57.jpg">
<meta property="article:published_time" content="2025-08-19T05:59:43.000Z">
<meta property="article:modified_time" content="2025-11-03T07:29:17.654Z">
<meta property="article:author" content="Eysiking">
<meta property="article:tag" content="Note">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://eysiking-photo.oss-cn-hangzhou.aliyuncs.com/img/57.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Temp",
  "url": "http://lineagestar.github.io/2025/08/19/Algorithm/x/",
  "image": "https://eysiking-photo.oss-cn-hangzhou.aliyuncs.com/img/57.jpg",
  "datePublished": "2025-08-19T05:59:43.000Z",
  "dateModified": "2025-11-03T07:29:17.654Z",
  "author": [
    {
      "@type": "Person",
      "name": "Eysiking",
      "url": "http://lineagestar.github.io/eysikinge@gmail.com"
    }
  ]
}</script><link rel="shortcut icon" href="https://eysiking-photo.oss-cn-hangzhou.aliyuncs.com/img/aili.png"><link rel="canonical" href="http://lineagestar.github.io/2025/08/19/Algorithm/x/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="manifest" href="/null"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Temp',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background: linear-gradient(20deg, #fbc2eb 0%, #a6c1ee 100%);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://eysiking-photo.oss-cn-hangzhou.aliyuncs.com/img/aili.png" onerror="this.onerror=null;this.src='https://eysiking-photo.oss-cn-hangzhou.aliyuncs.com/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-tags"></i><span> Tags</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="https://lineagestar.github.io/tags/CPP-Thread/"><i class="fa-fw fas fa-solid fa-paperclip"></i><span> CPP-Thread</span></a></li><li><a class="site-page child" href="https://lineagestar.github.io/tags/CPP-Template/"><i class="fa-fw fas fa-solid fa-paperclip"></i><span> CPP-Template</span></a></li><li><a class="site-page child" href="https://lineagestar.github.io/tags/Assembly/"><i class="fa-fw fas fa-solid fa-paperclip"></i><span> Assembly</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="https://lineagestar.github.io/categories/CPP/"><i class="fa-fw fas fa-regular fa-file"></i><span> CPP</span></a></li><li><a class="site-page child" href="https://lineagestar.github.io/categories/Assembly/"><i class="fa-fw fas fa-regular fa-file"></i><span> Assembly</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-link"></i><span> Link</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://en.cppreference.com/w/Main_Page"><i class="fa-fw fa-solid fa-code"></i><span> cppreference</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.youtube.com/"><i class="fa-fw fa-brands fa-youtube"></i><span> Youtube</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/"><i class="fa-fw fa-brands fa-square-github"></i><span> GitHub</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://hoyue.fun/animes.html"><i class="fa-fw fa-brands fa-react"></i><span> Cartoon</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://eysiking-photo.oss-cn-hangzhou.aliyuncs.com/img/57.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://eysiking-photo.oss-cn-hangzhou.aliyuncs.com/img/aili.png" alt="Logo"><span class="site-name">Eysiking</span></a><a class="nav-page-title" href="/"><span class="site-name">Temp</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-tags"></i><span> Tags</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="https://lineagestar.github.io/tags/CPP-Thread/"><i class="fa-fw fas fa-solid fa-paperclip"></i><span> CPP-Thread</span></a></li><li><a class="site-page child" href="https://lineagestar.github.io/tags/CPP-Template/"><i class="fa-fw fas fa-solid fa-paperclip"></i><span> CPP-Template</span></a></li><li><a class="site-page child" href="https://lineagestar.github.io/tags/Assembly/"><i class="fa-fw fas fa-solid fa-paperclip"></i><span> Assembly</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="https://lineagestar.github.io/categories/CPP/"><i class="fa-fw fas fa-regular fa-file"></i><span> CPP</span></a></li><li><a class="site-page child" href="https://lineagestar.github.io/categories/Assembly/"><i class="fa-fw fas fa-regular fa-file"></i><span> Assembly</span></a></li></ul></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-link"></i><span> Link</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://en.cppreference.com/w/Main_Page"><i class="fa-fw fa-solid fa-code"></i><span> cppreference</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.youtube.com/"><i class="fa-fw fa-brands fa-youtube"></i><span> Youtube</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/"><i class="fa-fw fa-brands fa-square-github"></i><span> GitHub</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://hoyue.fun/animes.html"><i class="fa-fw fa-brands fa-react"></i><span> Cartoon</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Temp</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-08-19T05:59:43.000Z" title="Created 2025-08-19 13:59:43">2025-08-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-11-03T07:29:17.654Z" title="Updated 2025-11-03 15:29:17">2025-11-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Algorithm/">Algorithm</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">49.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>245mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><!-- From: DP\README.md -->


<h1 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h1><p>‍</p>
<!-- From: DP\SOSDP.md -->


<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>SOS-DP</strong>，英文名 <strong>Sum over Subsets(SOS)</strong> dynamic programming，即<strong>子集和</strong>DP，用来求某一集合的所有子集对应状态之和。</p>
<p>给定一个含 $2^N$ 个元素的集合 $A$，下标用 $i$ 来表示，求一个 $F_{state}$，对应为：<br>$$<br>F_{state}&#x3D;\sum_{i\subseteq state &#x2F; i \text{&amp;} state &#x3D; state}A[i]<br>$$</p>
<h1 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h1><ol>
<li><h4 id="Bruteforce"><a href="#Bruteforce" class="headerlink" title="Bruteforce"></a>Bruteforce</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; (<span class="number">1</span> &lt;&lt; N); mask++) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; N); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((mask &amp; i) == i) &#123;</span><br><span class="line">			F[mask] += A[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于每个 $mask$，暴力枚举哪些状态为它的子集，时间复杂度 $O(4^N)$</p>
</li>
<li><h4 id="Suboptimal-Solution"><a href="#Suboptimal-Solution" class="headerlink" title="Suboptimal Solution"></a>Suboptimal Solution</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iterate over all the masks</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; (<span class="number">1</span> &lt;&lt; N); mask++) &#123;</span><br><span class="line">	F[mask] = A[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// iterate over all the subsets of the mask</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = mask; i &gt; <span class="number">0</span>; i = (i - <span class="number">1</span>) &amp; mask) &#123;</span><br><span class="line">    	F[mask] += A[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于每个 $mask$，只会枚举它所包含的子集 $i$。</p>
<p>若该 $mask$ 含有 $k$ 个 $1$，则它所枚举的状态数量为 $2 ^ k$，时间复杂度为 $O(\sum_{k&#x3D;0}^N \binom{N}{k}2^k&#x3D;(1+2) ^ N &#x3D; 3^N)$</p>
</li>
<li><h4 id="SoS-Dynamic-Programming-solution"><a href="#SoS-Dynamic-Programming-solution" class="headerlink" title="SoS Dynamic Programming solution"></a>SoS Dynamic Programming solution</h4></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; N); i++) &#123;</span><br><span class="line">  F[i] = A[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; (<span class="number">1</span> &lt;&lt; N); mask++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mask &gt;&gt; i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">      F[mask] += F[mask ^ (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Suboptimal Solution 中，发现对于每个状态 $mask$，如果它包含有 $k$ 个 $0$，则会被枚举 $2^k$ 次（它对应 $2^k$ 个超集，每个超集都会枚举一次 $mask$ 状态）</p>
<p>考虑如何在不同的 $F_{state}$ 中建立联系：</p>
<p>设状态 $S_{state,i}&#x3D;{x|x\subseteq state \land state\oplus x &lt; 2^{i+1}}$，即 $S_{state,i}$ 中包含的状态为<strong>仅有 0~i 位可以与 $state$ 状态不同，而其余位均相同的子集 $x$ 的集合</strong></p>
<p>$F(S)$ 之间的状态转移为<br>$$<br>\begin{aligned}<br>&amp; F_{state,0}&#x3D;A[state]\<br>&amp; F_{state,i}&#x3D;<br>\begin{cases}<br>F_{state, i-1},&amp;\text{if } state &amp; (1 &lt;&lt; i)&#x3D;0\<br>F_{state,i-1}+F_{state\oplus (1&lt;&lt;i), i-1}, &amp;\text{if }state &amp; (1 &lt;&lt; i)\ne 0<br>\end{cases}<br>\end{aligned}<br>$$<br>如果 $state$ 的第 $i$ 位为 $0$，则它只会包括第 $i$ 位为 $0$ 的子集；反之会包括第 $i$ 位为 $0$ 和 $1$ 的子集。</p>
<p>发现每层状态只会与上一层相关，经过空间压缩后得到上述代码。</p>
<p>该算法又被称为<strong>高维前缀和</strong>，其逆过程，也就是将<code>F[mask] += F[mask ^ (1 &lt;&lt; i)];</code>改为<code>F[mask] -= F[mask ^ (1 &lt;&lt; i)];</code>可得高维差分，一般先用高位前缀和，变换后再用高维差分，得到所需的严格等的信息。</p>
<h1 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h1><p><a target="_blank" rel="noopener" href="https://vjudge.net/contest/444410#overview">SOS-DP 题单</a></p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/165/E">CF165E</a></p>
<p>在数组 $a$ 对于每一个元素 $a_i$，找出一个元素 $a_j$，满足 $a_i \text{&amp;} a_j&#x3D;0$，其中元素大小 $a_i\le 4\times 10^6$</p>
<p>将 $a_i$ 标记为状态，只需要看 $state&#x3D;((1&lt;&lt;N)-1)\oplus a_i$ 对应状态的子集有无数组 $a$ 中元素即可，再用一位表示这个状态含有哪些子集，只需要一个，用一个维度添加特定子集即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">22</span>, M = (<span class="number">1</span> &lt;&lt; <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;pii&gt; <span class="title">dp</span><span class="params">(M)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">    dp[i] = &#123;<span class="number">0</span>, i&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    dp[a[i]].fi = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; M; mask++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mask &gt;&gt; i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dp[mask].fi) &#123;</span><br><span class="line">          dp[mask].se = dp[mask ^ (<span class="number">1</span> &lt;&lt; i)].se;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[mask].fi += dp[mask ^ (<span class="number">1</span> &lt;&lt; i)].fi;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> mask = (M - <span class="number">1</span>) ^ a[i];</span><br><span class="line">    <span class="keyword">if</span> (!dp[mask].fi) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n - <span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cout &lt;&lt; dp[mask].se &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/arc100/tasks/arc100_c?lang=en">arc100_c</a></p>
<p>对于每个状态，维护一个最大值和一个次大值，再求一个前缀最大值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> N;</span><br><span class="line">  cin &gt;&gt; N;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(M)</span></span>;</span><br><span class="line">  std::vector&lt;std::array&lt;<span class="type">int</span>, 2&gt;&gt; <span class="built_in">dp</span>(M);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">    dp[i] = &#123;a[i], <span class="number">0</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; M; mask++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mask &gt;&gt; i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        std::array&lt;<span class="type">int</span>, 4&gt; b&#123;dp[mask][<span class="number">0</span>], dp[mask][<span class="number">1</span>], dp[mask ^ (<span class="number">1</span> &lt;&lt; i)][<span class="number">0</span>], dp[mask ^ (<span class="number">1</span> &lt;&lt; i)][<span class="number">1</span>]&#125;;</span><br><span class="line">        std::<span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), std::<span class="built_in">greater</span>());</span><br><span class="line">        dp[mask] = &#123;b[<span class="number">0</span>], b[<span class="number">1</span>]&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">F</span><span class="params">(M)</span></span>;</span><br><span class="line">  F[<span class="number">1</span>] = dp[<span class="number">1</span>][<span class="number">0</span>] + dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; M; i++) &#123;</span><br><span class="line">    F[i] = std::<span class="built_in">max</span>(dp[i][<span class="number">0</span>] + dp[i][<span class="number">1</span>], F[i - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; M; i++) &#123;</span><br><span class="line">    cout &lt;&lt; F[i] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1208/F">CF1208F</a></p>
<p>在数组中找 $a_i|(a_j\text{&amp;}a_k),(1\le i&lt;j&lt;k\le n)$ 的最大值</p>
<p>对式子变形，求 $(\overline {a_i}\text{&amp;} (a_j\text{&amp;} a_k))+a_i$ 的最大值，对 $state$ 做超集 SOS-DP，求 $state\subseteq a_j \text{&amp;} a_k$ 的最大下标和次大下标，对 $\overline{a_i}$ 做按位贪心</p>
<p>按位贪心步骤：从高到低枚举每一位 $add$，看 $add$ 当前位是否可以为 1，如果可以 $add\leftarrow add + (1&lt;&lt;j)$，否则跳过枚举下一位，检查即为看 $state&#x3D;add+(1&lt;&lt;j)$ 中对应的次大下标是否大于 $i$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> N = <span class="number">21</span>, M = (<span class="number">1</span> &lt;&lt; N);</span><br><span class="line">  std::vector&lt;std::array&lt;<span class="type">int</span>, 2&gt;&gt; <span class="built_in">dp</span>(M);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> update = [&amp;](<span class="type">int</span> state, <span class="type">int</span> pos) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &gt; dp[state][<span class="number">0</span>]) &#123;</span><br><span class="line">      dp[state][<span class="number">1</span>] = dp[state][<span class="number">0</span>];</span><br><span class="line">      dp[state][<span class="number">0</span>] = pos;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos &gt; dp[state][<span class="number">1</span>]) &#123;</span><br><span class="line">      dp[state][<span class="number">1</span>] = pos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">update</span>(a[i], i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; M; mask++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(mask &gt;&gt; i &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="built_in">update</span>(mask, dp[mask ^ (<span class="number">1</span> &lt;&lt; i)][<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">update</span>(mask, dp[mask ^ (<span class="number">1</span> &lt;&lt; i)][<span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> C = (M - <span class="number">1</span>) ^ a[i], add = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = N - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(C &gt;&gt; j &amp; <span class="number">1</span>) || dp[add ^ (<span class="number">1</span> &lt;&lt; j)][<span class="number">1</span>] &lt;= i) <span class="keyword">continue</span>;</span><br><span class="line">      add += (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans = std::<span class="built_in">max</span>(ans, a[i] + add);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/383/E">CF383E</a></p>
<p>给定  $n$ 个单词，这 $n$ 个单词均为 3 个由<code>a~x</code> 的小写字母组成，规定至少含有一个元音字母的单词是正确的，对于<code>a~x</code>中所有可能的元音字母组合（共有 $2^{24}$ 个），求 $n$ 个单词中正确单词数量的平方和。</p>
<p>本质是求 $n$ 个单词中与 $mask$ 字母集合有交集的单词个数，正难则反：把 $mask$ 当作辅音集合，其一定也是 <code>0~(1&lt;&lt;24)-1</code>，对 $dp[mask]$ 做子集和，即为 $n$ 个单词中均为辅音的单词数量  $n-dp[mask]$ 即为正确单词数量。异或和即为答案。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> N = <span class="number">24</span>, M = (<span class="number">1</span> &lt;&lt; N);</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(M)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> [x, y, z] = std::<span class="built_in">make_tuple</span>(s[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>, s[<span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>, s[<span class="number">2</span>] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    dp[(<span class="number">1</span> &lt;&lt; x) | (<span class="number">1</span> &lt;&lt; y) | (<span class="number">1</span> &lt;&lt; z)]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; M; mask++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mask &gt;&gt; i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        dp[mask] += dp[mask ^ (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">    ans ^= (n - dp[i]) * (n - dp[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.codechef.com/problems/COVERING">Convering Sets</a></p>
<p>有 $F,G,H$ 三个函数，定义在<code>0~(1 &lt;&lt; N) - 1</code>上，求 $\sum_{x&#x3D;0}^{2^N-1}R(x),R(x)&#x3D;\sum_{x\subseteq A\cup B \cup C}F(A)\cdot G(B)\cdot H(C)$</p>
<p>考虑求 $T(x)&#x3D;\sum_{x&#x3D;A\cup B \cup C}F(A)G(B)H(C)$ 对 $T$ 做子集和DP即可求得 $R$</p>
<p>先对 $F,G,H$ 做子集和DP得 $F’,G’,H’$,表示 $F_i\leftarrow\sum_{j\cup i &#x3D; i} F_j $ ，设 $a_i &#x3D; F_i \cdot G_i \cdot H_i$，对 $a$ 做高维前缀和得到 $a_i\leftarrow\sum_{A\cup B\cup C \subseteq i}F(A)G(B)H(C)$</p>
<p>对 $a$ 做高维差分得到 $T_i&#x3D;\sum_{A\cup B\cup C&#x3D;i}F(A)G(B)H(C)$，即求得 $T$，再做一遍子集和DP求各项和即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> N, M;</span><br><span class="line">  cin &gt;&gt; N;</span><br><span class="line"></span><br><span class="line">  M = (<span class="number">1</span> &lt;&lt; N);</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;mint&gt; <span class="title">F</span><span class="params">(M)</span>, <span class="title">G</span><span class="params">(M)</span>, <span class="title">H</span><span class="params">(M)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">    cin &gt;&gt; F[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">    cin &gt;&gt; G[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">    cin &gt;&gt; H[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; M; mask++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mask &gt;&gt; i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        F[mask] += F[mask ^ (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line">        G[mask] += G[mask ^ (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line">        H[mask] += H[mask ^ (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;mint&gt; <span class="title">a</span><span class="params">(M)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">    a[i] = F[i] * G[i] * H[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; M; mask++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mask &gt;&gt; i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        a[mask] -= a[mask ^ (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; M; mask++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(mask &gt;&gt; i &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">        a[mask] += a[mask ^ (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mint ans = std::<span class="built_in">accumulate</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">mint</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/449/D">CF449D</a></p>
<p>求数组 $a$ 中按位或为 0 的子序列个数</p>
<p>正难则反，考虑有多少子序列按位或为  $mask$</p>
<p>设 $f_i$ 为 $f_i&#x3D;\sum_{j&#x3D;1}^n [a_j \text{&amp;} i &#x3D; i]$</p>
<p>只需要将 $f_i$ 看作桶，记录每个元素出现次数，再做超集和DP即可</p>
<p>设 $g_i&#x3D;2^{f_i}-1$，即子序列按位或为 $j\land i\subseteq j$ 的个数</p>
<p>考虑将高维前缀和反过来，变成高维差分，对$g$ 即可求得 $g_i$ 为按位或和为 $i$ 的子序列个数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> N = <span class="number">20</span>, M = (<span class="number">1</span> &lt;&lt; N);</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(M)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    f[x]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; M; mask++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(mask &gt;&gt; i &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">        f[mask] += f[mask ^ (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;mint&gt; <span class="title">g</span><span class="params">(M)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; M; mask++) &#123;</span><br><span class="line">    g[mask] = <span class="built_in">power</span>(<span class="built_in">mint</span>(<span class="number">2</span>), f[mask]) - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; M; mask++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(mask &gt;&gt; i &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">        g[mask] -= g[mask ^ (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mint ans = <span class="built_in">power</span>(<span class="built_in">mint</span>(<span class="number">2</span>), n) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">1</span>; mask &lt; M; mask++) &#123;</span><br><span class="line">    ans -= g[mask];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<!-- From: DP\优化尝试和状态设计.md -->


<h1 id="优化尝试和状态设计"><a href="#优化尝试和状态设计" class="headerlink" title="优化尝试和状态设计"></a>优化尝试和状态设计</h1><ol>
<li><p>双倍起点问题：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cherry-pickup/description/">741. 摘樱桃 - 力扣（LeetCode）</a></p>
<p> [P1004 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1004">NOIP 2000 提高组] 方格取数 - 洛谷</a></p>
</li>
<li><p>矩阵优化dp</p>
<p> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/starroadxyz/p/17578200.html">矩阵快速幂优化dp - star_road_xyz - 博客园</a></p>
</li>
</ol>
<p>‍</p>
<!-- From: DP\可持久化并查集和可撤销并查集.md -->


<h1 id="可持久化并查集"><a href="#可持久化并查集" class="headerlink" title="可持久化并查集"></a>可持久化并查集</h1><p>可以查询任意版本的并查集，本质就是可持久化数组，将 $f$ 数组与 $siz$ 可持久化</p>
<p>为了减少每次合并操作的修改元素数量，只做按秩合并，不做路径压缩。假设要合并 $a$ 所在元素集合和 $b$ 所在元素集合，集合代表节点和集合大小分别为 $f_a,siz_a,f_b,siz_b(siz_a&gt;siz_b)$，这样每次合并的操作就只有</p>
<ol>
<li>$f[f_b]&#x3D;f_a  $</li>
<li>$siz[f_a]&#x3D;siz_a+siz_b$</li>
</ol>
<p>只需进行两次操作，大大减小了操作量，并且由于启发式合并，每次查询操作也只会跳转 $O(\log n)$ 次。</p>
<h1 id="可撤销并查集"><a href="#可撤销并查集" class="headerlink" title="可撤销并查集"></a>可撤销并查集</h1><p>可以按照<code>FIFO</code>回滚所做操作，用一个栈来存储当前版本修改了哪些信息，以便回退到它上一个版本。</p>
<p>由于只维护了两个集合代表节点在合并时的相关信息，同样不能做路径压缩</p>
<p>模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span> &#123;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; f, siz;</span><br><span class="line">  std::stack&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; his;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DSU</span>() &#123;&#125;</span><br><span class="line">  <span class="built_in">DSU</span>(<span class="type">int</span> n) &#123; <span class="built_in">init</span>(n); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    f.<span class="built_in">resize</span>(n);</span><br><span class="line">    std::<span class="built_in">iota</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    siz.<span class="built_in">assign</span>(n, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != f[x]) &#123;</span><br><span class="line">      x = f[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = <span class="built_in">find</span>(x);</span><br><span class="line">    y = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (siz[x] &lt; siz[y]) &#123;</span><br><span class="line">      std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    his.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    siz[x] += siz[y];</span><br><span class="line">    f[y] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">time</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> his.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">revert</span><span class="params">(<span class="type">int</span> tm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (his.<span class="built_in">size</span>() &gt; tm) &#123;</span><br><span class="line">      <span class="keyword">auto</span> [x, y] = his.<span class="built_in">top</span>();</span><br><span class="line">      his.<span class="built_in">pop</span>();</span><br><span class="line">      f[y] = y;</span><br><span class="line">      siz[x] -= siz[y];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">revert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [x, y] = his.<span class="built_in">top</span>();</span><br><span class="line">    his.<span class="built_in">pop</span>();</span><br><span class="line">    f[y] = y;</span><br><span class="line">    siz[x] -= siz[y];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> siz[<span class="built_in">find</span>(x)]; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><ol>
<li><p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc302/tasks/abc302_h">AT_abc302_h</a></p>
<p> 每个点有两个权值 $A,B$，经过一个点只能选择其中一个，问根节点 0 到其他节点，走最短路径所能取的权值最大种类数量是多少</p>
<p> 对于同一个点上的权值 $A_i,B_i$，用一条边连接，表示可以取这条边两个端点之一</p>
<p> 考虑一张连通图 $G(n,m) $：</p>
<ol>
<li>若 $m&#x3D; n-1$：则 $G$ 为一棵树，按照上述规则可以取到 $n-1$ 个不同权值</li>
<li>若 $m&#x3D;n$：可以发现经过调整，可以取到 $n$ 个不同权值</li>
<li>若 $m&gt;n$：能取到的权值种类数量已到达上限，仍为 $n$ 个</li>
</ol>
<p> 所以总结规律：假如当前路径加入点 $u$，其两个权值为 $A_u,B_u$，向 $A_u,B_u$ 之间连接一条边，并查集记录连通分量，存储每个连通分量中边的数量：</p>
<ol>
<li><p>如果 $A_u,B_u$ 不在同一连通分量：</p>
<ul>
<li>若 $A_u,B_u$ 所在连通分量中，存在边数 &lt; 点数的情况，则计数 +1</li>
<li>若 $A_u,B_u$ 所在连通分量中，不存在边数 &lt; 点数的情况，不会产生贡献</li>
</ul>
</li>
<li><p>如果 $A_u,B_u$ 在同一连通分量：</p>
<ul>
<li>若该连通分量，边数 &lt; 点数，则计数+1</li>
<li>否则，不会产生贡献</li>
</ul>
</li>
</ol>
<p> 利用 dfs 的递归特性，在计算完一个点后删除其影响（可撤销并查集），这样一次 dfs 就可以得到所有点的答案</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="function">std::vector&lt;pii&gt; <span class="title">ball</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> A, B;</span><br><span class="line">    cin &gt;&gt; A &gt;&gt; B;</span><br><span class="line">    A--;</span><br><span class="line">    B--;</span><br><span class="line">    ball[i] = &#123;A, B&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    u--;</span><br><span class="line">    v--;</span><br><span class="line">    g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="function">DSU <span class="title">dsu</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp;&amp; self, <span class="type">int</span> u, <span class="type">int</span> f) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> [A, B] = ball[u];</span><br><span class="line">    <span class="type">int</span> fA = dsu.<span class="built_in">find</span>(A), fB = dsu.<span class="built_in">find</span>(B);</span><br><span class="line">    <span class="type">bool</span> add = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (fA == fB) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dsu.siz[fA] &gt; dsu.ecnt[fA]) &#123;</span><br><span class="line">        add = <span class="literal">true</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">      &#125;</span><br><span class="line">      dsu.ecnt[fA]++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (dsu.siz[fA] &lt; dsu.siz[fB]) &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(fA, fB);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (dsu.siz[fA] &gt; dsu.ecnt[fA] || dsu.siz[fB] &gt; dsu.ecnt[fB]) &#123;</span><br><span class="line">        add = <span class="literal">true</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">      &#125;</span><br><span class="line">      dsu.ecnt[fA] += dsu.ecnt[fB] + <span class="number">1</span>;</span><br><span class="line">      dsu.siz[fA] += dsu.siz[fB];</span><br><span class="line">      dsu.f[fB] = fA;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[u] = cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : g[u]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (v == f) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="built_in">self</span>(self, v, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (add) &#123;</span><br><span class="line">      cnt--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fA != fB) &#123;</span><br><span class="line">      dsu.f[fB] = fB;</span><br><span class="line">      dsu.siz[fA] -= dsu.siz[fB];</span><br><span class="line">      dsu.ecnt[fA] -= dsu.ecnt[fB];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dsu.ecnt[fA]--;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">dfs</span>(dfs, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/891/C">CF891C</a></p>
<p> 给定 $G(n,m)$，每组询问给出若干条边，判断这若干条边是否都能够存在于 $G$ 的一个最小生成树中。</p>
<p> 考虑离线做法，将所有询问存储起来，用 $[u,v,w,id]$ 表示，以 $w$ 为第一关键字，$id$ 为第二关键字排序，这样就能按照 $w$ 和 $id$ 进行分组。</p>
<p> 考虑一个性质：对于一组权值相同的所有边，按照 $kruscal$ 算法流程，无论选择哪些边加入当前最小生成树中，都不会改变其最后生成的图的连通性（考虑反证）。这样在考虑一到 $[u,v,w,id]$ 时，$kruscal$ 算法考虑所有权值小于 $w$ 的边，再看这条边能否加入到最小生成树当中。由于上述性质存在，不必考虑权值比它小的边加入最小生成树时，不同的选择会导致不同的连通性，从而不会对当前选择产生影响。在权值相同，但不同组的 $[u,v,w,id]$ 中，用可撤销并查集去除上一组的影响。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;Edge&gt; e;</span><br><span class="line">  e.<span class="built_in">reserve</span>(m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">    e.<span class="built_in">emplace_back</span>(u - <span class="number">1</span>, v - <span class="number">1</span>, w);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> q;</span><br><span class="line">  cin &gt;&gt; q;</span><br><span class="line">  std::vector&lt;Q&gt; que;</span><br><span class="line">  que.<span class="built_in">reserve</span>(q);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; t; j++) &#123;</span><br><span class="line">      <span class="type">int</span> x;</span><br><span class="line">      cin &gt;&gt; x;</span><br><span class="line">      x--;</span><br><span class="line">      que.<span class="built_in">emplace_back</span>(e[x].u, e[x].v, e[x].w, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">sort</span>(que.<span class="built_in">begin</span>(), que.<span class="built_in">end</span>());</span><br><span class="line">  std::<span class="built_in">sort</span>(e.<span class="built_in">begin</span>(), e.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">ans</span><span class="params">(q, <span class="literal">true</span>)</span></span>;</span><br><span class="line">  <span class="function">DSU <span class="title">dsu</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, p = <span class="number">0</span>; l &lt; que.<span class="built_in">size</span>(); l = r + <span class="number">1</span>, r = l) &#123;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; m &amp;&amp; e[p].w &lt; que[l].w) &#123;</span><br><span class="line">      dsu.<span class="built_in">merge</span>(e[p].u, e[p].v);</span><br><span class="line">      p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (r &lt; que.<span class="built_in">size</span>() &amp;&amp; que[r].w == que[l].w &amp;&amp; que[r].id == que[l].id) &#123;</span><br><span class="line">      r++;</span><br><span class="line">    &#125;</span><br><span class="line">    r--;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = l; j &lt;= r; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!dsu.<span class="built_in">same</span>(que[j].u, que[j].v)) &#123;</span><br><span class="line">        dsu.<span class="built_in">merge</span>(que[j].u, que[j].v);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ans[que[j].id] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len = j - l;</span><br><span class="line">    <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">      dsu.<span class="built_in">revert</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">    cout &lt;&lt; (ans[i] ? <span class="string">&quot;YES\n&quot;</span> : <span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1444/C">CF1444C</a></p>
<p> $n$ 个点有 $m$ 个不相容关系，另外有若干组，将任意两组配对，问有多少种配对，可以将两个组中的所有点导出一个二分图（分成两部分，每部分里的所有点之间无不相容关系）。</p>
<p> 使用<strong>扩展域并查集</strong>来判断相容关系，如果同一组中点无法导出二分图，则事先排除这个组，反之需要加入配对。</p>
<p> 先用 $\binom{k}{2}$ 计算总的配对数量，再从不在同一组的不相容关系中排除不合法的配对数量，使用可撤销并查集撤销上一次不相容关系的影响。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> n, m, k;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">check</span><span class="params">(k, <span class="literal">true</span>)</span></span>;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">belong</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    cin &gt;&gt; id;</span><br><span class="line">    id--;</span><br><span class="line">    belong[i] = id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::array&lt;<span class="type">int</span>, 4&gt;&gt; e;</span><br><span class="line">  e.<span class="built_in">reserve</span>(m);</span><br><span class="line">  <span class="type">int</span> cnt = k;</span><br><span class="line"></span><br><span class="line">  <span class="function">DSU <span class="title">dsu</span><span class="params">(n * <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    u--;</span><br><span class="line">    v--;</span><br><span class="line">    <span class="keyword">if</span> (belong[u] == belong[v]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!check[belong[u]]) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (dsu.<span class="built_in">same</span>(u, v)) &#123;</span><br><span class="line">        check[belong[u]] = <span class="literal">false</span>;</span><br><span class="line">        cnt--;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dsu.<span class="built_in">merge</span>(u, v + n);</span><br><span class="line">        dsu.<span class="built_in">merge</span>(v, u + n);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (belong[u] &gt; belong[v]) &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">      &#125;</span><br><span class="line">      e.<span class="built_in">push_back</span>(&#123;belong[u], belong[v], u, v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  i64 ans = <span class="number">1LL</span> * (cnt - <span class="number">1</span>) * cnt / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (e.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">sort</span>(e.<span class="built_in">begin</span>(), e.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; l &lt; e.<span class="built_in">size</span>(); l = r + <span class="number">1</span>, r++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; e.<span class="built_in">size</span>() &amp;&amp; e[l][<span class="number">0</span>] == e[r][<span class="number">0</span>] &amp;&amp; e[l][<span class="number">1</span>] == e[r][<span class="number">1</span>]) &#123;</span><br><span class="line">      r++;</span><br><span class="line">    &#125;</span><br><span class="line">    r--;</span><br><span class="line">    <span class="keyword">if</span> (!check[e[l][<span class="number">0</span>]] || !check[e[l][<span class="number">1</span>]]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dsu.<span class="built_in">same</span>(e[i][<span class="number">2</span>], e[i][<span class="number">3</span>])) &#123;</span><br><span class="line">        ans--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t += dsu.<span class="built_in">merge</span>(e[i][<span class="number">2</span>], e[i][<span class="number">3</span>] + n);</span><br><span class="line">        t += dsu.<span class="built_in">merge</span>(e[i][<span class="number">2</span>] + n, e[i][<span class="number">3</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">      dsu.<span class="built_in">revert</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<!-- From: DP\数位DP\README.md -->


<h1 id="数位DP"><a href="#数位DP" class="headerlink" title="数位DP"></a>数位DP</h1><p>‍</p>
<!-- From: DP\数位DP\例题.md -->


<h1 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h1><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/2081/A">数位dp+期望dp Math Division</a></p>
<!-- From: DP\线性DP\README.md -->


<h1 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h1><p>‍</p>
<!-- From: DP\线性DP\例题.md -->


<h1 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h1><ol>
<li><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P10954">LCIS问题</a>：线性dp的针对特定题目的优化问题。</p>
<p> 如何将 $O(n^3)$ 复杂度的 dp 问题通过循环中的固定量转变为 $O(n^2)$。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"> cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"> <span class="type">int</span> n;</span><br><span class="line"> cin &gt;&gt; n;</span><br><span class="line"> <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span>, <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> &amp;x : a) &#123;</span><br><span class="line">     cin &gt;&gt; x;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> &amp;x : b) &#123;</span><br><span class="line">     cin &gt;&gt; x;</span><br><span class="line"> &#125;</span><br><span class="line"> std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line"> <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">     <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">         dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">         <span class="keyword">if</span> (a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>]) &#123;</span><br><span class="line">             dp[i][j] = std::<span class="built_in">max</span>(dp[i][j], max + <span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (b[j - <span class="number">1</span>] &lt; a[i - <span class="number">1</span>]) &#123; <span class="comment">// a[i - 1] == b[j / k - 1]</span></span><br><span class="line">             max = std::<span class="built_in">max</span>(max, dp[i - <span class="number">1</span>][j]);</span><br><span class="line">         &#125;</span><br><span class="line">         ans = std::<span class="built_in">max</span>(ans, dp[i][j]);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/SP15637">SP15637 GNYR04H - Mr Youngs Picture Permutations</a>：奇怪的dp问题求解</p>
<p> 依次选择 $1,2,3,…,n$ 加入，加入时要保证：</p>
<ul>
<li>加入的该行一定是添加到该行的最后位置，否则有更大的数添加到该行的中间位置，导致行不满足条件。</li>
<li>加入某一行时，一定要保证它之前的行的长度大于它，否则有更大的数添加到之前行导致列不满足条件。</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; k &amp;&amp; k) &#123;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">row</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            cin &gt;&gt; row[i];</span><br><span class="line">        &#125;</span><br><span class="line">        std::vector&lt;std::vector&lt;std::vector&lt;std::vector&lt;std::vector&lt;i64&gt;&gt;&gt;&gt;&gt; <span class="built_in">dp</span>(row[<span class="number">0</span>] + <span class="number">1</span>, std::vector&lt;std::vector&lt;std::vector&lt;std::vector&lt;i64&gt;&gt;&gt;&gt;(row[<span class="number">1</span>] + <span class="number">1</span>, std::vector&lt;std::vector&lt;std::vector&lt;i64&gt;&gt;&gt;(row[<span class="number">2</span>] + <span class="number">1</span>, std::vector&lt;std::vector&lt;i64&gt;&gt;(row[<span class="number">3</span>] + <span class="number">1</span>, std::<span class="built_in">vector</span>&lt;i64&gt;(row[<span class="number">4</span>] + <span class="number">1</span>)))));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a1 = <span class="number">0</span>; a1 &lt;= row[<span class="number">0</span>]; a1++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> a2 = <span class="number">0</span>; a2 &lt;= row[<span class="number">1</span>]; a2++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> a3 = <span class="number">0</span>; a3 &lt;= row[<span class="number">2</span>]; a3++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> a4 = <span class="number">0</span>; a4 &lt;= row[<span class="number">3</span>]; a4++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> a5 = <span class="number">0</span>; a5 &lt;= row[<span class="number">4</span>]; a5++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (a1 &lt; row[<span class="number">0</span>]) &#123;</span><br><span class="line">                                dp[a1 + <span class="number">1</span>][a2][a3][a4][a5] += dp[a1][a2][a3][a4][a5];</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (a2 &lt; row[<span class="number">1</span>] &amp;&amp; a2 &lt; a1) &#123;</span><br><span class="line">                                dp[a1][a2 + <span class="number">1</span>][a3][a4][a5] += dp[a1][a2][a3][a4][a5];</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (a3 &lt; row[<span class="number">2</span>] &amp;&amp; a3 &lt; a2) &#123;</span><br><span class="line">                                dp[a1][a2][a3 + <span class="number">1</span>][a4][a5] += dp[a1][a2][a3][a4][a5];</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (a4 &lt; row[<span class="number">3</span>] &amp;&amp; a4 &lt; a3) &#123;</span><br><span class="line">                                dp[a1][a2][a3][a4 + <span class="number">1</span>][a5] += dp[a1][a2][a3][a4][a5];</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (a5 &lt; row[<span class="number">4</span>] &amp;&amp; a5 &lt; a4) &#123;</span><br><span class="line">                                dp[a1][a2][a3][a4][a5 + <span class="number">1</span>] += dp[a1][a2][a3][a4][a5];</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; dp[row[<span class="number">0</span>]][row[<span class="number">1</span>]][row[<span class="number">2</span>]][row[<span class="number">3</span>]][row[<span class="number">4</span>]] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<!-- From: DP\线段树分治(2).md -->


<p>上一章中介绍到使用可撤销并查集结合线段树分治可以维护图的连通性信息。由于在同一时间线段树的深度为 $O(\log q)$ ，因此可以利用直接复制的操作，如果数据结构大小为 $n$，则总的时间复杂度为 $O(nq\log q)$</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/601/E">CF601E</a></p>
<p>维护背包问题的 dp 数组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> n, k;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  <span class="function">std::vector&lt;Z&gt; <span class="title">fac</span><span class="params">(k)</span></span>;</span><br><span class="line">  fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> P = <span class="number">10000019</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">    fac[i] = fac[i - <span class="number">1</span>] * P;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;pii&gt; <span class="title">items</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> v, w;</span><br><span class="line">    cin &gt;&gt; v &gt;&gt; w;</span><br><span class="line">    items[i] = &#123;v, w&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> q, cnt = n;</span><br><span class="line">  cin &gt;&gt; q;</span><br><span class="line">  items.<span class="built_in">resize</span>(n + q);</span><br><span class="line">  std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">event</span>(n + q);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    event[i].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">haveq</span><span class="params">(q + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">    <span class="type">int</span> op;</span><br><span class="line">    cin &gt;&gt; op;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="type">int</span> v, w;</span><br><span class="line">      cin &gt;&gt; v &gt;&gt; w;</span><br><span class="line">      items[cnt] = &#123;v, w&#125;;</span><br><span class="line">      event[cnt].<span class="built_in">push_back</span>(i);</span><br><span class="line">      cnt++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="type">int</span> x;</span><br><span class="line">      cin &gt;&gt; x;</span><br><span class="line">      x--;</span><br><span class="line">      event[x].<span class="built_in">push_back</span>(i - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      haveq[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">seg</span>((q + <span class="number">1</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">auto</span> add = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span> &amp;&amp; add, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> v) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">      seg[p].<span class="built_in">push_back</span>(v);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= m) &#123;</span><br><span class="line">      <span class="built_in">add</span>(p &lt;&lt; <span class="number">1</span>, l, m, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= m + <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">add</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n + q; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event[i].<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event[i].<span class="built_in">size</span>() &amp; <span class="number">1</span>) &#123;</span><br><span class="line">      event[i].<span class="built_in">push_back</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j + <span class="number">1</span> &lt; event[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">      <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">0</span>, q, event[i][j], event[i][j + <span class="number">1</span>], i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(k + <span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span> &amp;&amp; dfs, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> ndp = dp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : seg[p]) &#123;</span><br><span class="line">      <span class="keyword">auto</span> [v, w] = items[x];</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = k; i &gt;= w; i--) &#123;</span><br><span class="line">        dp[i] = std::<span class="built_in">max</span>(dp[i], dp[i - w] + v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">      <span class="keyword">if</span> (haveq[l]) &#123;</span><br><span class="line">        Z ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">          ans += fac[i - <span class="number">1</span>] * dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      dp = ndp;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(p &lt;&lt; <span class="number">1</span>, l, m);</span><br><span class="line">    <span class="built_in">dfs</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    dp = ndp;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, q);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a target="_blank" rel="noopener" href="https://loj.ac/p/6515">loj 6515</a></p>
</li>
</ol>
<!-- From: DP\线段树分治.md -->


<p>线段树和离线算法的结合。假如你需要维护一些信息，这些信息会在某一个时间段内出现，要求在离线的前提下回答某一个时刻的信息并，则可以考虑使用线段树分治的技巧。</p>
<p>回顾线段树内容，假如需要维护一个时间轴上的操作，对这个时间轴建立线段树，把在某一时间段生效的操作挂在线段树节点上，在到达当前节点时，添加该节点上保存的操作；在离开该节点时，对于图的连通性问题通常使用<strong>可撤销并查集</strong>，对于其他特殊问题，如果需要维护的数据结构空间复杂度很小，也可以直接保存操作前的状态，离开该节点时再复制回原来的状态。询问操作一般存储在线段树叶节点上。</p>
<h1 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h1><ol>
<li><p><a target="_blank" rel="noopener" href="https://loj.ac/p/121">loj121 模板题</a></p>
<p>维护一张图，动态添加一些边，删除一些已经存在的边，查询两个点是否连通</p>
<p>将操作标记上生效时间，用线段树维护时间轴</p>
<p>维护一个可撤销并查集</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">  std::map&lt;pii, std::vector&lt;<span class="type">int</span>&gt;&gt; mm;</span><br><span class="line">  std::vector&lt;std::tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> op, x, y;</span><br><span class="line">    cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">if</span> (y &lt; x) &#123;</span><br><span class="line">      std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">0</span> || op == <span class="number">1</span>) &#123;</span><br><span class="line">      mm[&#123;x, y&#125;].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      q.<span class="built_in">emplace_back</span>(x, y, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  std::vector&lt;std::vector&lt;std::tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>&gt;&gt;&gt; <span class="built_in">seg</span>(m &lt;&lt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> modify = [&amp;](<span class="keyword">auto</span> &amp;&amp;self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y,</span><br><span class="line">                    std::tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>&gt; v) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">      seg[p].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= m) &#123;</span><br><span class="line">      <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span>, l, m, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= m + <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function">DSU <span class="title">dsu</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> &amp;&amp;self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y, isq] : seg[p]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isq) <span class="keyword">continue</span>;</span><br><span class="line">      cnt += dsu.<span class="built_in">merge</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y, isq] : seg[p]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isq) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (dsu.<span class="built_in">same</span>(x, y)) &#123;</span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;Y\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;N\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (cnt--) &#123;</span><br><span class="line">        dsu.<span class="built_in">revert</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span>, l, m);</span><br><span class="line">    <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cnt--) &#123;</span><br><span class="line">      dsu.<span class="built_in">revert</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[xy, vec] : mm) &#123;</span><br><span class="line">    <span class="keyword">auto</span> [x, y] = xy;</span><br><span class="line">    <span class="keyword">if</span> (vec.<span class="built_in">size</span>() &amp; <span class="number">1</span>) &#123;</span><br><span class="line">      vec.<span class="built_in">push_back</span>(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i += <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">0</span>, m - <span class="number">1</span>, vec[i], vec[i + <span class="number">1</span>], &#123;x, y, <span class="literal">false</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y, t] : q) &#123;</span><br><span class="line">    <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">0</span>, m - <span class="number">1</span>, t, t, &#123;x, y, <span class="literal">true</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(dfs, <span class="number">1</span>, <span class="number">0</span>, m - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5787">P5787</a></p>
<p>维护一张图是否是二分图</p>
<p>维护一个可撤销并查集，用扩展域并查集来判断是否是二分图</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n, m, k;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::vector&lt;pii&gt;&gt; <span class="built_in">seg</span>((k + <span class="number">1</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> modify = [&amp;](<span class="keyword">auto</span> &amp;&amp; self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, pii v) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">      seg[p].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= m) &#123;</span><br><span class="line">      <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span>, l, m, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= m + <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> x, y, l, r;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    l++;</span><br><span class="line">    x--;</span><br><span class="line">    y--;</span><br><span class="line">    <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">0</span>, k, l, r, &#123;x, y&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">DSU <span class="title">dsu</span><span class="params">(n * <span class="number">2</span>)</span></span>;</span><br><span class="line">  <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> &amp;&amp; self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> check = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y] : seg[p]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dsu.<span class="built_in">same</span>(x, y)) &#123;</span><br><span class="line">        check = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cnt += dsu.<span class="built_in">merge</span>(x, y + n);</span><br><span class="line">        cnt += dsu.<span class="built_in">merge</span>(x + n, y);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">      <span class="keyword">if</span> (l &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (check) &#123;</span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (cnt--) &#123;</span><br><span class="line">        dsu.<span class="built_in">revert</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!check) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (cnt--) &#123;</span><br><span class="line">        dsu.<span class="built_in">revert</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span>, l, m);</span><br><span class="line">    <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cnt--) &#123;</span><br><span class="line">      dsu.<span class="built_in">revert</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dfs</span>(dfs, <span class="number">1</span>, <span class="number">0</span>, k);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5631">P5631</a></p>
<p>找出一张图的最小 mex 树</p>
<p>按照边权值轴建立线段树，如果一条边的权值为 w，那么就设置它的生效时间为 $[0,w-1],[w+1,w_{max}]$，依次检查每个 $w$ 时刻能否让图连通</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// std::ios::sync_with_stdio(false);</span></span><br><span class="line">  <span class="comment">// std::cin.tie(nullptr);</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  <span class="comment">// cin &gt;&gt; n &gt;&gt; m;</span></span><br><span class="line">  <span class="built_in">read</span>(n);</span><br><span class="line">  <span class="built_in">read</span>(m);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> W = <span class="number">100&#x27;000</span> + <span class="number">1</span>;</span><br><span class="line">  std::vector&lt;std::vector&lt;pii&gt;&gt; <span class="built_in">seg</span>((W + <span class="number">1</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> modify = [&amp;](<span class="keyword">auto</span> &amp;&amp;self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y,</span><br><span class="line">                    pii v) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">      seg[p].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= m) &#123;</span><br><span class="line">      <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span>, l, m, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= m + <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">read</span>(u);</span><br><span class="line">    <span class="built_in">read</span>(v);</span><br><span class="line">    <span class="built_in">read</span>(w);</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">continue</span>;</span><br><span class="line">    u--;</span><br><span class="line">    v--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (w - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">0</span>, W, <span class="number">0</span>, w - <span class="number">1</span>, &#123;u, v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">0</span>, W, w + <span class="number">1</span>, W, &#123;u, v&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">DSU <span class="title">dsu</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="type">int</span> cnt = n;</span><br><span class="line">  <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y] : seg[p]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dsu.<span class="built_in">same</span>(x, y)) <span class="keyword">continue</span>;</span><br><span class="line">      dsu.<span class="built_in">merge</span>(x, y);</span><br><span class="line">      t++;</span><br><span class="line">      cnt--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cnt == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(l, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      cnt += t;</span><br><span class="line">      <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        dsu.<span class="built_in">revert</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span>, l, m);</span><br><span class="line">    <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    cnt += t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">      dsu.<span class="built_in">revert</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dfs</span>(dfs, <span class="number">1</span>, <span class="number">0</span>, W);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1681/F">CF1681F</a></p>
<p>给定一棵树，树边设置权值，$f(u,v)$ 为 $u,v$ 两点间简单路径上边权只出现一次的边权个数，同样按照边权值建立线段树，统计每条边的贡献。如果当前来到线段树叶节点 $w$，检查 $w$ 权值的所有边，由于原图是一棵树，能保证枚举当前边时，边左右两个端点的连通块一定不同，且只有当前边能让它们连通，$siz[u]\times siz[v]$ 即为当前边的贡献。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::vector&lt;pii&gt;&gt; <span class="built_in">seg</span>((n + <span class="number">1</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> modify = [&amp;](<span class="keyword">auto</span> &amp;&amp; self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, pii v) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">      seg[p].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= m) &#123;</span><br><span class="line">      <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span>, l, m, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= m + <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::vector&lt;pii&gt;&gt; <span class="built_in">e</span>(n + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> u, v, x;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v &gt;&gt; x;</span><br><span class="line">    u--;</span><br><span class="line">    v--;</span><br><span class="line">    e[x].<span class="built_in">emplace_back</span>(u, v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, x - <span class="number">1</span>, &#123;u, v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; n) &#123;</span><br><span class="line">      <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">1</span>, n, x + <span class="number">1</span>, n, &#123;u, v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">DSU <span class="title">dsu</span><span class="params">(n)</span></span>;</span><br><span class="line">  i64 ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> &amp;&amp; self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y] : seg[p]) &#123;</span><br><span class="line">      t += dsu.<span class="built_in">merge</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y] : e[l]) &#123;</span><br><span class="line">        ans += <span class="number">1LL</span> * dsu.<span class="built_in">size</span>(x) * dsu.<span class="built_in">size</span>(y);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        dsu.<span class="built_in">revert</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span>, l, m);</span><br><span class="line">    <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">      dsu.<span class="built_in">revert</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dfs</span>(dfs, <span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4219">P4219</a></p>
<p>思路同上一题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">  std::map&lt;pii, std::vector&lt;<span class="type">int</span>&gt;&gt; mm;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">haveq</span><span class="params">(m)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    cin &gt;&gt; op &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    u--;</span><br><span class="line">    v--;</span><br><span class="line">    <span class="keyword">if</span> (u &gt; v) &#123;</span><br><span class="line">      std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mm[&#123;u, v&#125;].<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">      haveq[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  std::vector&lt;std::vector&lt;std::tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>&gt;&gt;&gt; <span class="built_in">seg</span>(m &lt;&lt; <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">auto</span> modify = [&amp;](<span class="keyword">auto</span> &amp;&amp; self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> std::tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>&gt; &amp;v) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">      seg[p].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= m) &#123;</span><br><span class="line">      <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span>, l, m, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= m + <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[edge, vec] : mm) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vec.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">1</span>, m, vec.<span class="built_in">front</span>(), m, &#123;edge.fi, edge.se, <span class="literal">false</span>&#125;);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">1</span>, m, vec[<span class="number">0</span>], vec[<span class="number">1</span>] - <span class="number">1</span>, &#123;edge.fi, edge.se, <span class="literal">false</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (vec[i] + <span class="number">1</span> &lt;= vec[i + <span class="number">1</span>] - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">1</span>, m, vec[i] + <span class="number">1</span>, vec[i + <span class="number">1</span>] - <span class="number">1</span>, &#123;edge.fi, edge.se, <span class="literal">false</span>&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vec.<span class="built_in">back</span>() &lt; m) &#123;</span><br><span class="line">      <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">1</span>, m, vec.<span class="built_in">back</span>() + <span class="number">1</span>, m, &#123;edge.fi, edge.se, <span class="literal">false</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">1</span>, m, vec[i], vec[i], &#123;edge.fi, edge.se, <span class="literal">true</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">DSU <span class="title">dsu</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> &amp;&amp; self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[x, y, isq] : seg[p]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isq) <span class="keyword">continue</span>;</span><br><span class="line">      t += dsu.<span class="built_in">merge</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[x, y, isq] : seg[p]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isq) <span class="keyword">continue</span>;</span><br><span class="line">        cout &lt;&lt; <span class="number">1LL</span> * dsu.<span class="built_in">size</span>(x) * dsu.<span class="built_in">size</span>(y) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        dsu.<span class="built_in">revert</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span>, l, m);</span><br><span class="line">    <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">      dsu.<span class="built_in">revert</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dfs</span>(dfs, <span class="number">1</span>, <span class="number">1</span>, m);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5227">P5227</a></p>
<p>模板题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;pii&gt; e;</span><br><span class="line">  e.<span class="built_in">reserve</span>(m);</span><br><span class="line">  std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">opt</span>(m);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    u--;</span><br><span class="line">    v--;</span><br><span class="line">    e.<span class="built_in">emplace_back</span>(u, v);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> k;</span><br><span class="line">  cin &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">      <span class="type">int</span> x;</span><br><span class="line">      cin &gt;&gt; x;</span><br><span class="line">      x--;</span><br><span class="line">      opt[x].<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">seg</span>((k + <span class="number">1</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> modify = [&amp;](<span class="keyword">auto</span> &amp;&amp; self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> v) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">      seg[p].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= m) &#123;</span><br><span class="line">      <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span>, l, m, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= m + <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> siz = opt[i].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (siz == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">0</span>, k, <span class="number">0</span>, k, i);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">0</span>, k, <span class="number">0</span>, opt[i][<span class="number">0</span>] - <span class="number">1</span>, i);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; siz - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (opt[i][j] + <span class="number">1</span> &lt;= opt[i][j + <span class="number">1</span>] - <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">0</span>, k, opt[i][j] + <span class="number">1</span>, opt[i][j + <span class="number">1</span>] - <span class="number">1</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (opt[i][siz - <span class="number">1</span>] + <span class="number">1</span> &lt;= k) &#123;</span><br><span class="line">          <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">0</span>, k, opt[i][siz - <span class="number">1</span>] + <span class="number">1</span>, k, i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">DSU <span class="title">dsu</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> &amp;&amp; self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : seg[p]) &#123;</span><br><span class="line">      <span class="keyword">auto</span> [x, y] = e[i];</span><br><span class="line">      t += dsu.<span class="built_in">merge</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">      <span class="keyword">if</span> (l &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dsu.<span class="built_in">size</span>(<span class="number">0</span>) == n) &#123;</span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;Connected\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;Disconnected\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        dsu.<span class="built_in">revert</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span>, l, m);</span><br><span class="line">    <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">      dsu.<span class="built_in">revert</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dfs</span>(dfs, <span class="number">1</span>, <span class="number">0</span>, k);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/576/E">CF576E</a></p>
<p>初始给定一张图，边没有颜色，每次操作将边染上一种指定颜色，操作后，判断所有颜色中仅由该种颜色形成的图是否是二分图，如果是，保留操作，否则撤销这次操作。</p>
<p>由于不合法则撤销，所以能保证每种颜色的边组成的图始终是二分图。如果将一条边由原来的 $old$ 色变为 $new$ 色，可以确保如果操作成功后，$old$ 色减少一条边，仍是二分图，所以我们只需要判断 $new$ 色的边加入当前一条新边后是否是二分图即可。</p>
<p>该题目难点在于当前操作有可能被撤销，从而维持当前边之前的颜色。我们先按照经典的方式将所有操作加入时间轴线段树中，同时维护一个 $last$ 数组，表示 $last_i$ 为第 $i$ 条边上次的颜色，每次对边的染色操作从 $last_i$ 取出颜色，如果发现当前操作染色成功，则 $last_i&#x3D;new$，否则不变。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n, m, k, q;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;pii&gt; e;</span><br><span class="line">  e.<span class="built_in">reserve</span>(m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    u--;</span><br><span class="line">    v--;</span><br><span class="line">    <span class="keyword">if</span> (u &gt; v) &#123;</span><br><span class="line">      std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    e.<span class="built_in">emplace_back</span>(u, v);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">last</span><span class="params">(m, <span class="number">-1</span>)</span></span>;</span><br><span class="line">  std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">seg</span>(q &lt;&lt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;pii&gt; <span class="title">query</span><span class="params">(q)</span></span>;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">opt</span><span class="params">(m, <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> modify = [&amp;](<span class="keyword">auto</span> &amp;&amp; self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> v) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">      seg[p].<span class="built_in">push_back</span>(v);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= m) &#123;</span><br><span class="line">      <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span>, l, m, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= m + <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">    <span class="type">int</span> x, color;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; color;</span><br><span class="line">    x--;</span><br><span class="line">    color--;</span><br><span class="line">    query[i] = &#123;x, color&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (~opt[x]) &#123;</span><br><span class="line">      <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">0</span>, q - <span class="number">1</span>, opt[x] + <span class="number">1</span>, i, x);</span><br><span class="line">    &#125;</span><br><span class="line">    opt[x] = i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (opt[i] &lt; q - <span class="number">1</span> &amp;&amp; opt[i] != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">0</span>, q - <span class="number">1</span>, opt[i] + <span class="number">1</span>, q - <span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;DSU&gt; <span class="title">dsu</span><span class="params">(k, DSU(n * <span class="number">2</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> &amp;&amp; self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; change;</span><br><span class="line">    change.<span class="built_in">reserve</span>(<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> edge : seg[p]) &#123;</span><br><span class="line">      <span class="keyword">auto</span> [x, y] = e[edge];</span><br><span class="line">      <span class="type">int</span> color = last[edge];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (color == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">      t += dsu[color].<span class="built_in">merge</span>(x, y + n);</span><br><span class="line">      t += dsu[color].<span class="built_in">merge</span>(x + n, y);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        change.<span class="built_in">push_back</span>(color);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">      <span class="keyword">auto</span> [x, color] = query[l];</span><br><span class="line">      <span class="keyword">auto</span> [u, v] = e[x];</span><br><span class="line">      <span class="type">int</span> nw = color;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">auto</span> &amp;d = dsu[nw];</span><br><span class="line">      <span class="keyword">if</span> (d.<span class="built_in">same</span>(u, v)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">        last[x] = nw;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> c : change) &#123;</span><br><span class="line">        dsu[c].<span class="built_in">revert</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span>, l, m);</span><br><span class="line">    <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> c : change) &#123;</span><br><span class="line">      dsu[c].<span class="built_in">revert</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dfs</span>(dfs, <span class="number">1</span>, <span class="number">0</span>, q - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2104/problem/G">CF2104G</a></p>
<p>给定一个内向基环森林，每次询问指定 k 种颜色，可以选择将每个点及其能到达的所有点染色，同时会修改一个点的出边，问对于每次询问，这个图最终会有多少种颜色不同的情况，答案对 3 取模。</p>
<p>由于每次修改一条出边，形成的图仍旧是内向基环森林，分析不难得到假如整个图的 SCC 数量为 $c$，则对应答案为 $k^c \mod 3$，下面分析一下这个答案：</p>
<ul>
<li>$k \equiv 0(\mod 3)\rightarrow k^c \equiv 0(\mod 3)$</li>
<li>$k\equiv 1 (\mod 3)\rightarrow k^c (\mod 3)$</li>
<li>$k\equiv 2(\mod 3)\rightarrow k^c\equiv 1(\mod 3)\text{ if k is even} , k^c\equiv 2(\mod 3)\text{ if k is odd}$</li>
</ul>
<p>统计强连通分量的数量很困难，因为通过并查集很难得出环的大小，但是可以很容易地得到环大小的奇偶性，因此只需要维护一个 $dis$ 带权并查集，就可以在合并时得到环的奇偶性</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n, q;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::vector&lt;pii&gt;&gt; <span class="built_in">opt</span>(n);</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">query</span><span class="params">(q + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> g;</span><br><span class="line">    cin &gt;&gt; g;</span><br><span class="line">    g--;</span><br><span class="line">    opt[i].<span class="built_in">push_back</span>(&#123;g, <span class="number">0</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">    <span class="type">int</span> x, y, k;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">    query[i] = k;</span><br><span class="line">    x--;</span><br><span class="line">    y--;</span><br><span class="line"></span><br><span class="line">    opt[x].<span class="built_in">push_back</span>(&#123;y, i&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::vector&lt;pii&gt;&gt; <span class="built_in">seg</span>((q + <span class="number">1</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> modify = [&amp;](<span class="keyword">auto</span> &amp;&amp;self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y,</span><br><span class="line">                    <span class="type">const</span> pii &amp;v) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">      seg[p].<span class="built_in">push_back</span>(v);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= m) &#123;</span><br><span class="line">      <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span>, l, m, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= m + <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; opt[i].<span class="built_in">size</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">0</span>, q, opt[i][j].se, opt[i][j + <span class="number">1</span>].se - <span class="number">1</span>,</span><br><span class="line">             &#123;i, opt[i][j].fi&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (opt[i].<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">0</span>, q, opt[i].<span class="built_in">back</span>().se, q, &#123;i, opt[i].<span class="built_in">back</span>().fi&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> odd = n &amp; <span class="number">1</span>;</span><br><span class="line">  <span class="function">DSU <span class="title">dsu</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> &amp;&amp;self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">void</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> todd = odd;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y] : seg[p]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dsu.<span class="built_in">same</span>(x, y)) &#123;</span><br><span class="line">        <span class="type">int</span> dx = dsu.<span class="built_in">getd</span>(x);</span><br><span class="line">        <span class="type">int</span> dy = dsu.<span class="built_in">getd</span>(y);</span><br><span class="line">        <span class="keyword">if</span> ((dx + dy) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">          odd ^= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dsu.<span class="built_in">merge</span>(x, y);</span><br><span class="line">        t++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">      <span class="keyword">if</span> (l &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> k = query[l] % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || k == <span class="number">1</span>) &#123;</span><br><span class="line">          cout &lt;&lt; k &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          cout &lt;&lt; (odd ? <span class="number">2</span> : <span class="number">1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        dsu.<span class="built_in">revert</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      odd = todd;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span>, l, m);</span><br><span class="line">    <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">      dsu.<span class="built_in">revert</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    odd = todd;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dfs</span>(dfs, <span class="number">1</span>, <span class="number">0</span>, q);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ol>
<!-- From: Math\README.md -->


<h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><p>‍</p>
<!-- From: Math\多项式与生成函数\README.md -->


<h1 id="多项式与生成函数"><a href="#多项式与生成函数" class="headerlink" title="多项式与生成函数"></a>多项式与生成函数</h1><h1 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h1><h2 id="形式："><a href="#形式：" class="headerlink" title="形式："></a>形式：</h2><p>求和式 $\sum a_nx^n$ 有限项相加，记作 $f(x)&#x3D;\sum_{n&#x3D;0}^ma_nx^n$</p>
<h1 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h1><p>某个序列 ${a}$ 的生成函数是一种形式幂级数，其每一项的系数可以提供关于这个序列的信息。</p>
<p>根据问题的不同，可以构造不同形式的生成函数</p>
<p>包括<strong>普通生成函数</strong>，<strong>指数生成函数</strong>，<strong>狄利克雷生成函数</strong>等。</p>
<h2 id="一般形式：-F-x-sum-n-a-nk-n-x"><a href="#一般形式：-F-x-sum-n-a-nk-n-x" class="headerlink" title="一般形式：$F(x)&#x3D;\sum_n  a_nk_n(x) $"></a>一般形式：$F(x)&#x3D;\sum_n  a_nk_n(x) $</h2><ol>
<li>普通生成函数：$k_n(x)&#x3D;x^n$</li>
<li>指数生成函数：$k_n(x)&#x3D;\frac{x^n}{n!}$</li>
<li>狄利克雷生成函数：$k_n(x)&#x3D;\frac{1}{n^x}$</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> G = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">addmod</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; a += b; <span class="keyword">if</span> (a &gt;= MOD) a -= MOD; <span class="keyword">return</span> a; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">submod</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; a -= b; <span class="keyword">if</span> (a &lt; <span class="number">0</span>) a += MOD; <span class="keyword">return</span> a; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">mulmod</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">int</span>((a * b) % MOD); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mod_pow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> e = MOD - <span class="number">2</span>)</span> </span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> r = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e &amp; <span class="number">1</span>) r = (r * a) % MOD;</span><br><span class="line">    a = (a * a) % MOD;</span><br><span class="line">    e &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">int</span>(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp; a, <span class="type">bool</span> invert)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = (<span class="type">int</span>)a.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> bit = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; j &amp; bit; bit &gt;&gt;= <span class="number">1</span>) j ^= bit;</span><br><span class="line">    j ^= bit;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; j) std::<span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> wlen = <span class="built_in">mod_pow</span>(G, (MOD - <span class="number">1</span>) / len);</span><br><span class="line">    <span class="keyword">if</span> (invert) wlen = <span class="built_in">mod_pow</span>(wlen, MOD - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += len) &#123;</span><br><span class="line">      <span class="type">long</span> <span class="type">long</span> w = <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> half = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; half; ++j) &#123;</span><br><span class="line">        <span class="type">int</span> u = a[i + j];</span><br><span class="line">        <span class="type">int</span> v = <span class="built_in">int</span>((a[i + j + half] * w) % MOD);</span><br><span class="line">        a[i + j] = u + v &lt; MOD ? u + v : u + v - MOD;</span><br><span class="line">        a[i + j + half] = u - v &gt;= <span class="number">0</span> ? u - v : u - v + MOD;</span><br><span class="line">        w = (w * wlen) % MOD;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (invert) &#123;</span><br><span class="line">    <span class="type">int</span> inv_n = <span class="built_in">mod_pow</span>(n, MOD - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp; x : a) x = <span class="built_in">int</span>((<span class="type">long</span> <span class="type">long</span>)x * inv_n % MOD);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> std::vector&lt;<span class="type">int</span>&gt; <span class="title">convolution</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;a, <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a.<span class="built_in">empty</span>() || b.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  <span class="type">int</span> n = (<span class="type">int</span>)a.<span class="built_in">size</span>();</span><br><span class="line">  <span class="type">int</span> m = (<span class="type">int</span>)b.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (std::<span class="built_in">min</span>(n, m) &lt; <span class="number">60</span>) &#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n + m - <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (a[i]) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) <span class="keyword">if</span> (b[j]) &#123;</span><br><span class="line">        res[i + j] = (res[i + j] + (<span class="type">long</span> <span class="type">long</span>)a[i] * b[j]) % MOD;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> sz = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (sz &lt; n + m - <span class="number">1</span>) sz &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">fa</span><span class="params">(a.begin(), a.end())</span>, <span class="title">fb</span><span class="params">(b.begin(), b.end())</span></span>;</span><br><span class="line">  fa.<span class="built_in">resize</span>(sz);</span><br><span class="line">  fb.<span class="built_in">resize</span>(sz);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ntt</span>(fa, <span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">ntt</span>(fb, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; ++i) fa[i] = <span class="built_in">int</span>((<span class="type">long</span> <span class="type">long</span>)fa[i] * fb[i] % MOD);</span><br><span class="line">  <span class="built_in">ntt</span>(fa, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  fa.<span class="built_in">resize</span>(n + m - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> fa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">OGF_mul</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;a, <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">convolution</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">EGF_mul</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;a, <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = (<span class="type">int</span>)a.<span class="built_in">size</span>();</span><br><span class="line">  <span class="type">int</span> m = (<span class="type">int</span>)b.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span> || m == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  <span class="type">int</span> res_len = n + m - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">fact</span><span class="params">(res_len)</span>, <span class="title">invfact</span><span class="params">(res_len)</span></span>;</span><br><span class="line">  fact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; res_len; ++i) fact[i] = <span class="built_in">mulmod</span>(fact[i<span class="number">-1</span>], i);</span><br><span class="line">  invfact[res_len - <span class="number">1</span>] = <span class="built_in">mod_pow</span>(fact[res_len - <span class="number">1</span>], MOD - <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = res_len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) invfact[i] = <span class="built_in">mulmod</span>(invfact[i<span class="number">+1</span>], i<span class="number">+1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">ta</span><span class="params">(n)</span>, <span class="title">tb</span><span class="params">(m)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) ta[i] = <span class="built_in">mulmod</span>(a[i], invfact[i]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) tb[i] = <span class="built_in">mulmod</span>(b[i], invfact[i]);</span><br><span class="line"></span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; conv = <span class="built_in">convolution</span>(ta, tb);</span><br><span class="line">  conv.<span class="built_in">resize</span>(res_len);</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(res_len)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; res_len; ++i) c[i] = <span class="built_in">mulmod</span>(conv[i], fact[i]);</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">Dirichlet_mul</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;f, <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;g)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (f.<span class="built_in">empty</span>() || g.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  <span class="type">int</span> N = std::<span class="built_in">min</span>((<span class="type">int</span>)f.<span class="built_in">size</span>(), (<span class="type">int</span>)g.<span class="built_in">size</span>()) - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (N &lt; <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">h</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line">  h[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">1</span>; d &lt;= N; ++d) &#123;</span><br><span class="line">    <span class="keyword">if</span> (f[d] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">int</span> limit = N / d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">1</span>; m &lt;= limit; ++m) &#123;</span><br><span class="line">      h[d * m] = (h[d * m] + (<span class="type">long</span> <span class="type">long</span>)f[d] * g[m]) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>‍</p>
<!-- From: Math\多项式与生成函数\指数生成函数.md -->


<h1 id="指数生成函数"><a href="#指数生成函数" class="headerlink" title="指数生成函数"></a>指数生成函数</h1><p>适用于<strong>多重集排列数</strong>问题</p>
<h1 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h1><p>$F(x)&#x3D;\sum_{n\ge 0}a_n\frac{x^n}{n!}$</p>
<p>序列 ${1,1,1,\dots}$ 的生成函数是 $1+x+\frac{x^2}{2!}+\frac{x^3}{3!}+\dots&#x3D;\sum_{n\ge 0}\frac{x^n}{n!}&#x3D;e^x$</p>
<p>序列 ${1,p,p^2,p^3,\dots}$ 的生成函数是 $1+px+p^2\frac{x^n}{2!}+p^3\frac{x^3}{3!}+\dots&#x3D;\sum_{n\ge 0}p^n\frac{x^n}{n!}&#x3D;e^{px}$</p>
<h1 id="加减运算"><a href="#加减运算" class="headerlink" title="加减运算"></a>加减运算</h1><p>$$<br>\begin{aligned}<br>F(x)\pm G(x)&amp;&#x3D;\sum_{i\ge 0}a_i\frac{x^i}{i!}\pm \sum_{j\ge 0}b_j\frac{x^j}{j!}\<br>&amp;&#x3D;\sum_{n\ge 0} (a_n\pm b_n)\frac{x^n}{n!}<br>\end{aligned}<br>$$</p>
<p>$F(x)\pm G(x)$ 是序列 ${a_n\pm b_n}$ 的指数生成函数</p>
<h1 id="乘法运算（卷积）"><a href="#乘法运算（卷积）" class="headerlink" title="乘法运算（卷积）"></a>乘法运算（卷积）</h1><p>$$<br>\begin{aligned}<br>F(x)G(x)&amp;&#x3D;\sum_{i\ge 0}a_i\frac{x^i}{i!}\sum_{j\ge 0}b_j\frac{x^j}{j!}\<br>&amp;&#x3D;\sum_{n\ge 0}x^n\sum_{i&#x3D;0}^na_ib_{n-i}\frac{1}{i!(n-i)!}\<br>&amp;&#x3D;\sum_{n\ge 0}\frac{x^n}{n!}\sum_{i&#x3D;0}^{n}\frac{n!}{i!(n-i)!}a_ib_{n-i}\<br>&amp;&#x3D;\sum_{n\ge 0} \frac{x^n}{n!}\sum_{i&#x3D;0}^n\binom{n}{i}a_ib_{n-i}<br>\end{aligned}<br>$$</p>
<p>因此 $F(x)G(x)$ 是序列 ${\sum_{i&#x3D;0}^{n}\binom{n}{i}a_ib_{n-i}}$ 的指数生成函数</p>
<h1 id="例题形式"><a href="#例题形式" class="headerlink" title="例题形式"></a>例题形式</h1><p>$n$ 个物品，各有 ${a_1,a_2,\dots,a_n}$ 数量，问组成总个数为 $m$ 的物品集合，共有多少种排列方式</p>
<p>设分别选择了 ${c_1,c_2,\dots,c_n}$ 个物品，组成总个数为 $m$，则总方法数为 $\frac{m!}{c_1!c_2!\dots c_n!}$</p>
<p>即求指数生成函数  $\frac{x^m}{m!}$ 项的系数</p>
<p>‍</p>
<!-- From: Math\多项式与生成函数\普通生成函数.md -->


<h1 id="普通生成函数"><a href="#普通生成函数" class="headerlink" title="普通生成函数"></a>普通生成函数</h1><p>适用于<strong>多重集组合数</strong>的问题</p>
<p>形式 $F(x)&#x3D;\sum_{n\ge 0} a_n x^n$</p>
<p>$a_n$ 可以是有穷序列，也可以是无穷序列。如：</p>
<p>序列 ${1,2,3}$ 的普通生成函数是 $1 + 2x + 3x^2$</p>
<p>序列 ${1,2,3,\dots}$ 的普通生成函数是 $1+x+x^2+\dots&#x3D;\sum_{n\ge 0}x^n$</p>
<p>序列 ${1,2,4,8,\dots}$ 的普通生成函数是 $\sum_{n \ge 0} 2^nx^n$</p>
<h1 id="加法运算"><a href="#加法运算" class="headerlink" title="加法运算"></a>加法运算</h1><p>$$<br>\begin{aligned}<br>F(x)\pm G(x)&amp;&#x3D;\sum_{i\ge 0}a_i x^i \pm\sum_{j\ge 0}b^j x^j\<br>&amp;&#x3D;\sum_{n\ge 0} (a_n\pm b_n)x^n<br>\end{aligned}<br>$$</p>
<p>是序列 ​${a_n\pm b_n}$ 的生成函数</p>
<h1 id="乘法运算（卷积）-1"><a href="#乘法运算（卷积）-1" class="headerlink" title="乘法运算（卷积）"></a>乘法运算（卷积）</h1><p>$$<br>\begin{aligned}<br>F(x)G(x)&amp;&#x3D;\sum_{i\ge 0} a_i x^i \sum_{j\ge 0}b_jx^j\<br>&amp;&#x3D; \sum_{n\ge 0}\sum_{i&#x3D;0}^n a_i b_{n-i}  x^n<br>\end{aligned}<br>$$</p>
<p>是序列 ${\sum_{i&#x3D;0}^n a_i b_{n-i}}$ 的生成函数</p>
<h1 id="例题形式-1"><a href="#例题形式-1" class="headerlink" title="例题形式"></a>例题形式</h1><p>$n$ 个物品，各有 ${a_1,a_2,\dots,a_n}$ 数量，价值分别为 ${b_1,b_2\dots,b_n}$，问组成总价值为 $m$，共有多少种方法</p>
<p>‍</p>
<!-- From: Math\多项式与生成函数\狄利克雷生成函数.md -->


<h1 id="狄利克雷生成函数"><a href="#狄利克雷生成函数" class="headerlink" title="狄利克雷生成函数"></a>狄利克雷生成函数</h1><h1 id="形式-1"><a href="#形式-1" class="headerlink" title="形式"></a>形式</h1><p>$F(x)&#x3D;\frac{a_1}{1^x}+\frac{a_2}{2^x}+\dots&#x3D;\sum_{n&#x3D;1}^{\infty}\frac{a_n}{n^x}$</p>
<h1 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h1><p>$$<br>\begin{aligned}<br>F(x)G(x)&amp;&#x3D;\sum_{i&#x3D;1}^{\infty}\frac{a_i}{i^x}\sum_{j&#x3D;1}^{\infty}\frac{b_j}{j^x}\<br>&amp;&#x3D;(\frac{a_1}{1^x}+\frac{a_2}{2^x}+\frac{a^3}{3^x}+\dots)(\frac{b_1}{1^x}+\frac{b_2}{2^x}+\frac{b^3}{3^x}+\dots)\<br>&amp;&#x3D;\frac{a_1b_1}{1^x}+\frac{a_1b_2+a_2b_1}{2^x}+\frac{a_1b_3+a_3b_1}{3^x}+\frac{a_1b_4+a_2b_2+a_4b_1}{4^x}+\dots\<br>&amp;&#x3D;\sum_{n&#x3D;1}^{\infty}\frac{1}{n^x}\sum_{d|n}a_db_{\frac{n}{d}}<br>\end{aligned}<br>$$</p>
<h1 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h1><p>$f(1)&#x3D;1$，当 $\gcd(a,b)&#x3D;1$ 时，有 $f(ab) &#x3D; f(a)f(b)$，则称 $f(n)$ 为积性函数</p>
<p>欧拉函数，莫比乌斯函数都是积性函数</p>
<h1 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h1><ol>
<li>定义：$\phi(x)&#x3D;\sum_{i&#x3D;1}^n[\gcd(i,n)&#x3D;1]$</li>
<li>性质：${\color{Red}\sum_{d|n}\phi(d)&#x3D;n}$</li>
</ol>
<h1 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h1><ol>
<li><p>定义：略</p>
</li>
<li><p>性质：${\color{Red}\sum_{d|n}\mu(d)&#x3D;[n&#x3D;1]}$</p>
<p> 证明：</p>
<p> $$<br> \begin{aligned}<br> &amp;\text{if }n&#x3D;1,\mu(n)&#x3D;1\<br> &amp;\text{if }n&gt;1,n&#x3D;p_1^{\alpha_1}p_2^{\alpha_2}\dots p_s^{\alpha_s}\<br> &amp;\text{let }n’&#x3D;p_1p_2\dots p_s\<br> &amp;\sum_{d|n}\mu(d)&#x3D;\sum_{d|n’}\mu(d)\<br> &amp;&#x3D;(-1)^0\binom{s}{0}+(-1)^1\binom{s}{1}+\dots(-1)^s\binom{s}{s}\<br> &amp;&#x3D;(1+(-1))^s\<br> &amp;&#x3D;0<br> \end{aligned}<br> $$</p>
</li>
<li><p>联系：${\color{Red}\sum_{d|n}\mu(d)\frac{n}{d}&#x3D;\phi(n)}$</p>
<p> 证明：</p>
<p> $$<br> \begin{aligned}<br> &amp;\text{if }n&#x3D;1,d&#x3D;1,\phi(n)&#x3D;\mu(n)&#x3D;1\<br> &amp;\text{if }n&gt;1,n&#x3D;p_1^{\alpha_1}p_2^{\alpha_2}\dots p_s^{\alpha_s}\<br> &amp;\text{let }n’&#x3D;p_1p_2\dots p_s\<br> &amp;\sum_{d|n}\mu(d)\frac{n}{d}\&amp;&#x3D;n\sum_{d|n’}\frac{\mu(d)}{d}\<br> &amp;&#x3D;n(1-(\frac{1}{p_1}+\frac{1}{p_2}+\dots+\frac{1}{p_s})+(\frac{1}{p_1p_2}+\dots+\frac{1}{p_{s-1}p_s})-\dots+\dots)\<br> &amp;&#x3D;n(1-\frac{1}{p_1})(1-\frac{1}{p_2})\dots(1-\frac{1}{p_s})\<br> &amp;&#x3D;\phi(n)</p>
<p> \end{aligned}<br> $$</p>
</li>
</ol>
<h1 id="狄利克雷卷积"><a href="#狄利克雷卷积" class="headerlink" title="狄利克雷卷积"></a>狄利克雷卷积</h1><ol>
<li><p>定义：</p>
<p> $$<br> (f*g)(n)&#x3D;\sum_{d|n}f(d)g(\frac{n}{d})&#x3D;\sum_{d|n}f(\frac{n}{d})g(n)<br> $$</p>
</li>
<li><p>性质：</p>
<ul>
<li>交换律：$f<em>g&#x3D;g</em>f$</li>
<li>结合律：$(f<em>g)<em>h&#x3D;f</em>(g</em>h)$</li>
<li>分配律：$(f+g)<em>h&#x3D;f</em>h+g*h$</li>
</ul>
</li>
<li><p>常用函数：</p>
<ul>
<li>元函数：$\epsilon(n)&#x3D;[n&#x3D;1]$</li>
<li>常数函数：$1(n)&#x3D;1$</li>
<li>恒等函数：$id(n)&#x3D;n$</li>
</ul>
</li>
<li><p>常用狄利克雷卷积关系：</p>
<ul>
<li>$\sum_{d|n}\mu(d)&#x3D;[n&#x3D;1]\iff \mu * 1 &#x3D; \epsilon$</li>
<li>$\sum_{d|n}\phi(d)&#x3D;n\iff \phi * 1 &#x3D; id$</li>
<li>$\sum_{d|n}\mu(d)\frac{n}{d}&#x3D;\phi(n)\iff \mu * id &#x3D; \phi$</li>
<li>$f*\epsilon &#x3D; f $</li>
<li>$f*1\ne f$</li>
</ul>
</li>
</ol>
<p>‍</p>
<!-- From: Math\多项式与生成函数\生成函数的应用.md -->


<h1 id="生成函数的应用"><a href="#生成函数的应用" class="headerlink" title="生成函数的应用"></a>生成函数的应用</h1><h1 id="泰勒展开式"><a href="#泰勒展开式" class="headerlink" title="泰勒展开式"></a>泰勒展开式</h1><ul>
<li><p>普通生成函数</p>
<ol>
<li>$\frac{1}{1-x}&#x3D;1+x+x^2+x^3+\dots&#x3D;\sum_{n&#x3D;0}^{\infty}x^n$</li>
<li>$\frac{1}{1-x^2}&#x3D;1+x^2+x^4+\dots $</li>
<li>$\frac{1}{1-x^k}&#x3D;1+x^k+x^{2k}+\dots $</li>
<li>$\frac{1}{(1-x)^2}&#x3D;1+2x+3x^2+\dots $</li>
</ol>
</li>
<li><p>指数生成函数</p>
<ol>
<li>$e^x&#x3D;1+x+\frac{x^2}{2!}+\frac{x^3}{3!}+\dots$</li>
<li>$\frac{e^x+e^{-x}}{2}&#x3D;1+\frac{x^2}{2!}+\frac{x^4}{4!}+\dots$</li>
<li>$\frac{e^x-e^{-x}}{2}&#x3D;x+\frac{x^3}{3!}+\frac{x^5}{5!}+\dots$</li>
</ol>
</li>
</ul>
<h1 id="有穷序列的生成函数"><a href="#有穷序列的生成函数" class="headerlink" title="有穷序列的生成函数"></a>有穷序列的生成函数</h1><ol>
<li>$1+x+x^2&#x3D;\frac{1-x^3}{1-x}$</li>
<li>$1+x+x^2+x^3&#x3D;\frac{1-x^4}{1-x}$（等比数列形式）</li>
</ol>
<h1 id="广义二项式定理"><a href="#广义二项式定理" class="headerlink" title="广义二项式定理"></a>广义二项式定理</h1><p>$$<br>\frac{1}{(1-x)^n}&#x3D;\sum_{i&#x3D;0}^{\infty}\binom{n+i-1}{i}x^i<br>$$</p>
<p>证明：<br>二项式定理：$(1+x)^n&#x3D;\sum_{i&#x3D;0}^{n}\binom{n}{i}x^i$</p>
<ol>
<li><p>扩展域：规定 $\binom{n}{i}&#x3D;0(\text{ if }i&gt;n)$，则有 $(1+x)^n&#x3D;\sum_{i&#x3D;0}^{\infty}\binom{n}{i}x^i$</p>
</li>
<li><p>$n$ 为负数时：$\binom{-n}{i}&#x3D;\frac{(-n)(-n-1){-n-2}\dots(-n-i+1)}{i!}&#x3D;(-1)^i\binom{n+i-1}{i}$</p>
<p> ‍</p>
<p> $(1+x)^{-n}&#x3D;\sum_{i&#x3D;0}^{\infty}(-1)^i\binom{n+i-1}{i}x^i$</p>
</li>
<li><p>$x$ 变为 $-x$：$(1-x)^{-n}&#x3D;\sum_{i&#x3D;0}^{\infty}(-1)^i\binom{n+i-1}{i}(-x)^i&#x3D;\sum_{i&#x3D;0}^{\infty}\binom{n+i-1}{i}x^i$</p>
</li>
</ol>
<p>‍</p>
<!-- From: Math\数论\Catalan数.md -->


<h1 id="Catalan数"><a href="#Catalan数" class="headerlink" title="Catalan数"></a>Catalan数</h1><h1 id="Catalan数基础"><a href="#Catalan数基础" class="headerlink" title="Catalan数基础"></a>Catalan数基础</h1><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><table>
<thead>
<tr>
<th>index</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>5</td>
<td>14</td>
<td>42</td>
<td>132</td>
<td>429</td>
<td>1430</td>
</tr>
</tbody></table>
<ol>
<li><ul>
<li><input checked="" disabled="" type="checkbox"> $f(n)&#x3D;\binom{2n}{n}-\binom{2n}{n-1}$</li>
</ul>
</li>
<li><ul>
<li><input checked="" disabled="" type="checkbox"> $f(n)&#x3D;\binom{2n}{n}&#x2F;(n+1)$</li>
</ul>
</li>
<li><ul>
<li><input disabled="" type="checkbox"> $f(n)&#x3D;f(n-1)\cdot(4n-2)&#x2F;(n+1)$</li>
</ul>
</li>
<li><ul>
<li><input checked="" disabled="" type="checkbox"> $f(n)&#x3D;\sum_{i&#x3D;0}^{n-1}f(i)\cdot f(n-1-i)$</li>
</ul>
</li>
</ol>
<p>最常用1，2，4，使用时需要考虑取模问题。</p>
<h2 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h2><ol>
<li><p>进出栈序列：</p>
<p> 序列 ${1,2,3,4,5,…,n}$ 依次入栈，每个数字可以自由选择出栈时间，不同出栈序列的个数是 Catalan数。</p>
<p> 转化为公式1：</p>
<p> $n$ 个左括号<code>(</code>和 $n$ 个右括号<code>)</code>，在任意前缀上<code>(</code>的数量大于<code>)</code>的数量，用<code>(</code>表示进栈，<code>)</code>表示出栈，那么括号序列的个数可以和进出栈序列形成<strong>双射</strong>。</p>
<ul>
<li><p>括号序列总个数 $\binom{2n}{n}$。</p>
</li>
<li><p>不符合条件的个数 $\iff$ 任意一个前缀上<code>)</code>数量大于<code>(</code>的序列个数 $\iff$ $n-1$ 个<code>(</code>和 $n+1$ 个<code>)</code>形成的序列个数 $\iff$ $\binom{2n}{n-1}$。</p>
<p>证明：对任意一个不符合条件的括号序列，找出第一个不满足条件的前缀位置，其右侧的<code>(</code>变为<code>)</code>，<code>)</code>变为<code>(</code>，总共 $n-1$ 个<code>(</code>和 $n+1$ 个<code>)</code>，且后者必定存在不满足条件的前缀。</p>
</li>
</ul>
<p> 同类模型：</p>
<ul>
<li><p>门票5元，$n$ 个人有5元，$n$ 个人有10元，初始没有钱，能确保找零的队伍序列数量</p>
</li>
<li><p>$n$ 个1和 $n$ 个-1，保证任意前缀和 $\geq0$。</p>
</li>
<li><p>$2n$ 个多边形，将所有点组成 $n$ 个点对，所有点对之间的连线均不相交的方法数。（一定保证奇数点与奇数点连接，偶数点与偶数点连接，因为要保证一段连线一侧剩余偶数个点）</p>
<p>${1,3,5,…}$ 依次进栈，每个出栈数字依次选择 ${2,4,6,…}$ 组成点对。</p>
</li>
</ul>
</li>
<li><p>路径计数模型：</p>
<p> 正方形网格中，从 $(0,0)$ 点开始，$(n,n)$ 点结束，路径保持在对角线一侧的方案数量（可以触碰到对角线）。</p>
<p> 如图，每个不合法路径均可以转化为从 $(-1,1)$ 到 $(n,n)$ 的一条路径。</p>
<p> <img src="/../../../_resources/Freehand%20Drawing.svg" alt="Freehand Drawing.svg"></p>
<p> 拓展：不触碰对角线的方案数：$2\binom{2n-2}{n-1}-2\binom{2n-2}{n}$。转化为从 $(1,0)$ 到 $(6,5)$ 和从 $(0,1)$ 到 $(5,6)$ 方案数量之和。</p>
</li>
<li><p>划分左右相乘模型：从 dp 递推式中得到 Catalan 数的模型。</p>
<ul>
<li>有 $n+2$ 条边的凸多边形，通过顶点连线的方式，全部划分为三角形，连线不能相交的方法数。</li>
<li>有 $n$ 个节点，所有节点都相同，能形成多少种不同结构的<strong>二叉树</strong>。</li>
</ul>
</li>
</ol>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><ol>
<li><p>组合数计算，需要预处理阶乘及其关于 $mod$ 的乘法逆元。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">fac</span><span class="params">(n * <span class="number">2</span> + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">invfac</span><span class="params">(n * <span class="number">2</span> + <span class="number">1</span>)</span></span>;</span><br><span class="line">fac[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">    fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % Mod;</span><br><span class="line">&#125;</span><br><span class="line">invfac[<span class="number">2</span> * n] = <span class="built_in">qmi</span>(fac[<span class="number">2</span> * n], Mod - <span class="number">2</span>, Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span> * n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    invfac[i - <span class="number">1</span>] = <span class="number">1ll</span> * invfac[i] * i % Mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Comb</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;mint&gt; _fac;</span><br><span class="line">    std::vector&lt;mint&gt; _invfac;</span><br><span class="line">    std::vector&lt;mint&gt; _inv;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Comb</span>() : n&#123;<span class="number">0</span>&#125;, _fac&#123;<span class="number">1</span>&#125;, _invfac&#123;<span class="number">1</span>&#125;, _inv&#123;<span class="number">0</span>&#125; &#123;&#125;</span><br><span class="line">    <span class="built_in">Comb</span>(<span class="type">int</span> n) : <span class="built_in">Comb</span>() &#123;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m &lt;= n) <span class="keyword">return</span>;</span><br><span class="line">        _fac.<span class="built_in">resize</span>(m + <span class="number">1</span>);</span><br><span class="line">        _invfac.<span class="built_in">resize</span>(m + <span class="number">1</span>);</span><br><span class="line">        _inv.<span class="built_in">resize</span>(m + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            _fac[i] = _fac[i - <span class="number">1</span>] * i;</span><br><span class="line">        &#125;</span><br><span class="line">        _invfac[m] = _fac[m].<span class="built_in">inv</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt; n; i--) &#123;</span><br><span class="line">            _invfac[i - <span class="number">1</span>] = _invfac[i] * i;</span><br><span class="line">            _inv[i] = _invfac[i] * _fac[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        n = m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">mint <span class="title">fac</span><span class="params">(<span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) <span class="built_in">init</span>(<span class="number">2</span> * m);</span><br><span class="line">        <span class="keyword">return</span> _fac[m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">mint <span class="title">invfac</span><span class="params">(<span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) <span class="built_in">init</span>(<span class="number">2</span> * m);</span><br><span class="line">        <span class="keyword">return</span> _invfac[m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">mint <span class="title">inv</span><span class="params">(<span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) <span class="built_in">init</span>(<span class="number">2</span> * m);</span><br><span class="line">        <span class="keyword">return</span> _inv[m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">mint <span class="title">binom</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; m || m &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fac</span>(n) * <span class="built_in">invfac</span>(m) * <span class="built_in">invfac</span>(n - m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; comb;</span><br></pre></td></tr></table></figure></li>
<li><p>直接使用递推公式计算（$mod$ 不是质数）：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>, r = i - <span class="number">1</span>; l &lt; n; l++, r--) &#123;</span><br><span class="line">        f[i] = (f[i] + <span class="number">1ll</span> * f[l] * f[r]) % Mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>公式2+因子计数法（质因子分解计数）：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3200">Luogu P3200</a></p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(pcnt)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pcnt &amp;&amp; prime[i] &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">    i64 p = prime[i];</span><br><span class="line">    <span class="keyword">while</span> (p &lt;= n * <span class="number">2</span>) &#123;</span><br><span class="line">        cnt[i] += n * <span class="number">2</span> / p;</span><br><span class="line">        p *= prime[i];</span><br><span class="line">    &#125;</span><br><span class="line">    p = prime[i];</span><br><span class="line">    <span class="keyword">while</span> (p &lt;= n) &#123;</span><br><span class="line">        cnt[i] -= <span class="number">2</span> * (n / p);</span><br><span class="line">        p *= prime[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tmp = n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pcnt &amp;&amp; prime[i] &lt;= tmp; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tmp % prime[i] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (tmp % prime[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            tmp /= prime[i];</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[i] -= t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pcnt; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    ans = <span class="number">1ll</span> * ans * <span class="built_in">qmi</span>(prime[i], cnt[i], Mod) % Mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="使用情况分析"><a href="#使用情况分析" class="headerlink" title="使用情况分析"></a>使用情况分析</h1><ol>
<li>$n\leq 35$，数据范围不超过 <code>long long</code>。</li>
<li>$n\leq 10^3 \land p\in prime$，四个公式均可。</li>
<li>$n\leq 10^3 \land p\notin prime$，公式4。</li>
<li>$n\leq 10^6 \land p\in prime$，公式1，2，3。</li>
<li>$n\leq 10^6 \land p \notin prime$，公式2 + 因子计数法。</li>
<li>$n\leq 10^3$，输出真实值，使用高精度。</li>
</ol>
<p>‍</p>
<!-- From: Math\数论\Euler函数.md -->


<h1 id="Euler函数"><a href="#Euler函数" class="headerlink" title="Euler函数"></a>Euler函数</h1><p>‍</p>
<!-- From: Math\数论\README.md -->


<h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><p>‍</p>
<!-- From: Math\数论\中国剩余定理CRT.md -->


<h1 id="中国剩余定理CRT"><a href="#中国剩余定理CRT" class="headerlink" title="中国剩余定理CRT"></a>中国剩余定理CRT</h1><h1 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h1><p>$$<br>\begin{cases}<br>x &amp;\equiv r_1 \pmod {m_1} \<br>x &amp;\equiv r_2 \pmod {m_2} \<br>  &amp;\vdots \<br>x &amp;\equiv r_k \pmod {m_k} \<br>\end{cases}<br>$$</p>
<p>其中 ${r}$ 互质，满足该同余方程组的 $x$ 的值</p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol>
<li><p>计算 $M&#x3D;\prod_{i&#x3D;1}^k m_i$</p>
</li>
<li><p>对于第 $i$ 个方程</p>
<ol>
<li>计算 $c_i&#x3D;\frac{M}{m_i}$</li>
<li>计算 $c_i$ 在 $\mod M$ 意义下的乘法逆元 $c_{i}^{-1}$，用 exgcd 进行计算</li>
</ol>
</li>
<li><p>解得 $x&#x3D;\sum_{i&#x3D;1}^k r_i c_i c_i^{-1}$</p>
</li>
</ol>
<h1 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h1><p>$$<br>\begin{cases}<br>c_j \mod m_i\equiv 0\Rightarrow r_jc_j c_j^{-1}\mod m_i \equiv 0, &amp;i\ne j\<br>c_j \mod m_i \equiv c_j \Rightarrow r_jc_jc_j^{-1} \mod m_i \equiv r_j,&amp;i&#x3D;j<br>\end{cases}<br>$$</p>
<h1 id="扩展中国剩余定理EXCRT"><a href="#扩展中国剩余定理EXCRT" class="headerlink" title="扩展中国剩余定理EXCRT"></a>扩展中国剩余定理EXCRT</h1><p>当 ${m }$ 之间不互质时，CRT 失效</p>
<p>‍</p>
<!-- From: Math\数论\乘法逆元Inv.md -->


<h1 id="乘法逆元Inv"><a href="#乘法逆元Inv" class="headerlink" title="乘法逆元Inv"></a>乘法逆元Inv</h1><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>如果线性同余方程 $ax\equiv 1\left( \mod b\right)$ ，则将 $x$ 称为 $a\mod b$ 意义下的乘法逆元，记作 $a^{-1}$。</p>
<h1 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h1><ol>
<li><p>扩展欧几里得算法（exgcd）：</p>
<p> 求得 $ax+by&#x3D;1$ 方程的解，则</p>
<p> $$<br> ax+by&#x3D;1<br> \Rightarrow ax&#x3D;1-by \Rightarrow ax\equiv 1(\mod b)<br> $$</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">    x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">  y -= a / b * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>费马小定理+快速幂：</p>
<p> $a^{p-1}\equiv 1(\mod p)\land ax\equiv 1(\mod p)\Rightarrow x\equiv a^{p-2}(\mod p)$，前提：$p$ 为质数。</p>
</li>
<li><p>线性求逆元：</p>
<p> 初始有 $inv[1] &#x3D;1$，有 $inv[i]&#x3D;(p-\lfloor \frac{p}{i}\rfloor)\cdot inv[p\mod i]\mod p,(i&gt;1)$。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">  inv[i] = (<span class="type">long</span> <span class="type">long</span>)(p - p / i) * inv[p % i] % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>线性求阶乘逆元：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">fac</span><span class="params">(n * <span class="number">2</span> + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">invfac</span><span class="params">(n * <span class="number">2</span> + <span class="number">1</span>)</span></span>;</span><br><span class="line">fac[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">    fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % Mod;</span><br><span class="line">&#125;</span><br><span class="line">invfac[<span class="number">2</span> * n] = <span class="built_in">qmi</span>(fac[<span class="number">2</span> * n], Mod - <span class="number">2</span>, Mod);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span> * n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    invfac[i - <span class="number">1</span>] = <span class="number">1ll</span> * invfac[i] * i % Mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<!-- From: Math\数论\数论分块.md -->


<h1 id="数论分块"><a href="#数论分块" class="headerlink" title="数论分块"></a>数论分块</h1><pre><code>数论分块可以快速计算含有除法向下取整的和式（形如 $\sum_&#123;i=1&#125;^&#123;n&#125;f(i)g(\lfloor \frac&#123;n&#125;&#123;i&#125; \rfloor)$。当可以在 $O(1)$ 内计算 $f(r)-f(l)$ 或已经预处理出 $f$ 的前缀和时，数论分块就可以在 $O(\sqrt&#123;n&#125;)$ 的时间内计算上述和式的值。

它主要利用了富比尼定理（Fubini&#39;s theorem），将 $\lfloor \frac&#123;n&#125;&#123;i&#125;\rfloor$  相同的数打包同时计算。
</code></pre>
<!-- From: Math\数论\类欧几里得算法.md -->


<h1 id="类欧几里得算法"><a href="#类欧几里得算法" class="headerlink" title="类欧几里得算法"></a>类欧几里得算法</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>类欧几里德算法是洪华敦在 2016 年冬令营营员交流中提出的内容。</p>
<p>其本质可以理解为，使用一个类似辗转相除法的方法来进行函数求和。</p>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>设</p>
<p>$$<br>f(a,b,c,n)&#x3D;\sum_{i&#x3D;0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor<br>$$</p>
<p>其中 $a,b,c,n$ 是常数。需要一个 $O(\log n)$ 的算法。</p>
<p>这个式子和我们以前见过的式子都长得不太一样。带向下取整的式子容易让人想到数论分块，然而数论分块似乎不适用于这个求和。但是我们是可以做一些预处理的。</p>
<p>如果说 $a\ge c$ 或者 $b\ge c$，意味着可以将 $a,b$ 对 $c$ 取模以简化问题：</p>
<p>$$<br>\begin{aligned}<br>f(a,b,c,n)&amp;&#x3D;\sum_{i&#x3D;0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor\<br>&amp;&#x3D;\sum_{i&#x3D;0}^n\left\lfloor<br>\frac{\left(\left\lfloor\frac{a}{c}\right\rfloor c+a\bmod c\right)i+\left(\left\lfloor\frac{b}{c}\right\rfloor c+b\bmod c\right)}{c}\right\rfloor\<br>&amp;&#x3D;\frac{n(n+1)}{2}\left\lfloor\frac{a}{c}\right\rfloor+(n+1)\left\lfloor\frac{b}{c}\right\rfloor+<br>\sum_{i&#x3D;0}^n\left\lfloor\frac{\left(a\bmod c\right)i+\left(b\bmod c\right)}{c}<br>\right\rfloor\<br>&amp;&#x3D;\frac{n(n+1)}{2}\left\lfloor\frac{a}{c}\right\rfloor<br>+(n+1)\left\lfloor\frac{b}{c}\right\rfloor+f(a\bmod c,b\bmod c,c,n)<br>\end{aligned}<br>$$</p>
<p>那么问题转化为了 $a&lt;c,b&lt;c$ 的情况。观察式子，你发现只有 $i$ 这一个变量。因此要推就只能从 $i$ 下手。在推求和式子中有一个常见的技巧，就是条件与贡献的放缩与转化。具体地说，在原式 $\displaystyle f(a,b,c,n)&#x3D;\sum_{i&#x3D;0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor$ 中，$0\le i\le n$ 是条件，而 $\left\lfloor \dfrac{ai+b}{c} \right\rfloor$ 是对总和的贡献。</p>
<p>要加快一个和式的计算过程，所有的方法都可以归约为 <strong>贡献合并计算</strong>。但你发现这个式子的贡献难以合并，怎么办？<strong>将贡献与条件做转化</strong> 得到另一个形式的和式。具体地，我们直接把原式的贡献变成条件：</p>
<p>$$<br>\sum_{i&#x3D;0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor<br>&#x3D;\sum_{i&#x3D;0}^n\sum_{j&#x3D;0}^{\left\lfloor \frac{ai+b}{c} \right\rfloor-1}1<br>$$</p>
<p>现在多了一个变量 $j$，既然算 $i$ 的贡献不方便，我们就想办法算 $j$ 的贡献。因此想办法搞一个和 $j$ 有关的贡献式。这里有另一个家喻户晓的变换方法，笔者概括为限制转移。具体来说，在上面的和式中 $n$ 限制 $i$ 的上界，而 $i$ 限制 $j$ 的上界。为了搞 $j$，就先把 j 放到贡献的式子里，于是我们交换一下 $i,j$ 的求和算子，强制用 $n$ 限制 $j$ 的上界。</p>
<p>$$<br>&#x3D;\sum_{j&#x3D;0}^{\left\lfloor \frac{an+b}{c} \right\rfloor-1}\sum_{i&#x3D;0}^n\left[j&lt;\left\lfloor \frac{ai+b}{c} \right\rfloor\right]<br>$$</p>
<p>这样做的目的是让 $j$ 摆脱 $i$ 的限制，现在 $i,j$ 都被 $n$ 限制，而贡献式看上去是一个条件，但是我们仍把它叫作贡献式，再对贡献式做变换后就可以改变 $i,j$ 的限制关系。于是我们做一些放缩的处理。首先把向下取整的符号拿掉</p>
<p>$$<br>j&lt;\left\lfloor \frac{ai+b}{c} \right\rfloor<br>\iff j+1\leq \left\lfloor \frac{ai+b}{c} \right\rfloor<br>\iff j+1\leq \frac{ai+b}{c}<br>$$</p>
<p>然后可以做一些变换</p>
<p>$$<br>j+1\leq \frac{ai+b}{c} \iff jc+c\le ai+b \iff jc+c-b-1&lt; ai<br>$$</p>
<p>最后一步，向下取整得到：</p>
<p>$$<br>jc+c-b-1&lt; ai\iff \left\lfloor\frac{jc+c-b-1}{a}\right\rfloor&lt; i<br>$$</p>
<p>这一步的重要意义在于，我们可以把变量 $i$ 消掉了！具体地，令 $m&#x3D;\left\lfloor \frac{an+b}{c} \right\rfloor$，那么原式化为</p>
<p>$$<br>\begin{aligned}<br>f(a,b,c,n)&amp;&#x3D;\sum_{j&#x3D;0}^{m-1}<br>\sum_{i&#x3D;0}^n\left[i&gt;\left\lfloor\frac{jc+c-b-1}{a}\right\rfloor \right]\<br>&amp;&#x3D;\sum_{j&#x3D;0}^{m-1}<br>(n-\left\lfloor\frac{jc+c-b-1}{a}\right\rfloor)\<br>&amp;&#x3D;nm-f\left(c,c-b-1,a,m-1\right)<br>\end{aligned}<br>$$</p>
<p>这是一个递归的式子。并且你发现 $a,c$ 分子分母换了位置，又可以重复上述过程。先取模，再递归。这就是一个辗转相除的过程，这也是类欧几里德算法的得名。</p>
<p>容易发现时间复杂度为 $O(\log n)$。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>理解了最基础的类欧几里德算法，我们再来思考以下两个变种求和式：</p>
<p>$$<br>g(a,b,c,n)&#x3D;\sum_{i&#x3D;0}^ni\left\lfloor \frac{ai+b}{c} \right\rfloor<br>$$</p>
<p>$$<br>h(a,b,c,n)&#x3D;\sum_{i&#x3D;0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor^2<br>$$</p>
<h3 id="推导-g"><a href="#推导-g" class="headerlink" title="推导 g"></a>推导 g</h3><p>我们先考虑 $g$，类似地，首先取模：</p>
<p>$$<br>g(a,b,c,n)<br>&#x3D;g(a\bmod c,b\bmod c,c,n)+\left\lfloor\frac{a}{c}\right\rfloor\frac{n(n+1)(2n+1)}{6}+\left\lfloor\frac{b}{c}\right\rfloor\frac{n(n+1)}{2}<br>$$</p>
<p>接下来考虑 $a&lt;c,b&lt;c$ 的情况，令 $m&#x3D;\left\lfloor\frac{an+b}{c}\right\rfloor$。之后的过程比较简略，因为方法和上文略同：</p>
<p>$$<br>\begin{aligned}<br>g(a,b,c,n)&amp;&#x3D;\sum_{i&#x3D;0}^ni\left\lfloor \frac{ai+b}{c} \right\rfloor\<br>&amp;&#x3D;\sum_{j&#x3D;0}^{m-1}<br>\sum_{i&#x3D;0}^n\left[j&lt;\left\lfloor\frac{ai+b}{c}\right\rfloor\right]\cdot i<br>\end{aligned}<br>$$</p>
<p>这时我们设 $t&#x3D;\left\lfloor\frac{jc+c-b-1}{a}\right\rfloor$，可以得到</p>
<p>$$<br>\begin{aligned}<br>g(a,b,c,n)&amp;&#x3D;\sum_{j&#x3D;0}^{m-1}\sum_{i&#x3D;0}^n[i&gt;t]\cdot i\<br>&amp;&#x3D;\sum_{j&#x3D;0}^{m-1}\frac{1}{2}(t+n+1)(n-t)\<br>&amp;&#x3D;\frac{1}{2}\left[mn(n+1)-\sum_{j&#x3D;0}^{m-1}t^2-\sum_{j&#x3D;0}^{m-1}t\right]\<br>&amp;&#x3D;\frac{1}{2}[mn(n+1)-h(c,c-b-1,a,m-1)-f(c,c-b-1,a,m-1)]<br>\end{aligned}<br>$$</p>
<h3 id="推导-h"><a href="#推导-h" class="headerlink" title="推导 h"></a>推导 h</h3><p>同样的，首先取模：</p>
<p>$$<br>\begin{aligned}<br>h(a,b,c,n)&amp;&#x3D;h(a\bmod c,b\bmod c,c,n)\<br>&amp;+2\left\lfloor\frac{b}{c}\right\rfloor f(a\bmod c,b\bmod c,c,n)<br>+2\left\lfloor\frac{a}{c}\right\rfloor g(a\bmod c,b\bmod c,c,n)\<br>&amp;+\left\lfloor\frac{a}{c}\right\rfloor^2\frac{n(n+1)(2n+1)}{6}+\left\lfloor\frac{b}{c}\right\rfloor^2(n+1)<br>+\left\lfloor\frac{a}{c}\right\rfloor\left\lfloor\frac{b}{c}\right\rfloor n(n+1)<br>\end{aligned}<br>$$</p>
<p>考虑 $a&lt;c,b&lt;c$ 的情况，$m&#x3D;\left\lfloor\dfrac{an+b}{c}\right\rfloor, t&#x3D;\left\lfloor\dfrac{jc+c-b-1}{a}\right\rfloor$.</p>
<p>我们发现这个平方不太好处理，于是可以这样把它拆成两部分：</p>
<p>$$<br>n^2&#x3D;2\dfrac{n(n+1)}{2}-n&#x3D;\left(2\sum_{i&#x3D;0}^ni\right)-n<br>$$</p>
<p>这样做的意义在于，添加变量 $j$ 的时侯就只会变成一个求和算子，不会出现 $\sum\times \sum$ 的形式：</p>
<p>$$<br>\begin{aligned}<br>h(a,b,c,n)&amp;&#x3D;\sum_{i&#x3D;0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor^2\<br>&amp;&#x3D;\sum_{i&#x3D;0}^n\left[\left(2\sum_{j&#x3D;1}^{\left\lfloor \frac{ai+b}{c} \right\rfloor}j \right)-\left\lfloor\frac{ai+b}{c}\right\rfloor\right]\<br>&amp;&#x3D;\left(2\sum_{i&#x3D;0}^n\sum_{j&#x3D;1}^{\left\lfloor \frac{ai+b}{c} \right\rfloor}j\right) -f(a,b,c,n)\<br>\end{aligned}<br>$$</p>
<p>接下来考虑化简前一部分：</p>
<p>$$<br>\begin{aligned}<br>\sum_{i&#x3D;0}^n\sum_{j&#x3D;1}^{\left\lfloor \frac{ai+b}{c} \right\rfloor}j&amp;&#x3D;\sum_{i&#x3D;0}^n\sum_{j&#x3D;0}^{\left\lfloor \frac{ai+b}{c} \right\rfloor-1}(j+1)\<br>&amp;&#x3D;\sum_{j&#x3D;0}^{m-1}(j+1)<br>\sum_{i&#x3D;0}^n\left[j&lt;\left\lfloor \frac{ai+b}{c} \right\rfloor\right]\<br>&amp;&#x3D;\sum_{j&#x3D;0}^{m-1}(j+1)\sum_{i&#x3D;0}^n[i&gt;t]\<br>&amp;&#x3D;\sum_{j&#x3D;0}^{m-1}(j+1)(n-t)\<br>&amp;&#x3D;\frac{1}{2}nm(m+1)-\sum_{j&#x3D;0}^{m-1}(j+1)\left\lfloor \frac{jc+c-b-1}{a} \right\rfloor\<br>&amp;&#x3D;\frac{1}{2}nm(m+1)-g(c,c-b-1,a,m-1)-f(c,c-b-1,a,m-1)<br>\end{aligned}<br>$$</p>
<p>因此</p>
<p>$$<br>h(a,b,c,n)&#x3D;nm(m+1)-2g(c,c-b-1,a,m-1)-2f(c,c-b-1,a,m-1)-f(a,b,c,n)<br>$$</p>
<p>在代码实现的时侯，因为 $3$ 个函数各有交错递归，因此可以考虑三个一起整体递归，同步计算，否则有很多项会被多次计算。这样实现的复杂度是 $O(\log n)$ 的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="type">int</span> f, g, h;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Data <span class="title">solve</span><span class="params">(i64 a, i64 b, i64 c, i64 n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> i64 M = <span class="number">998244353</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> i64 i2 = (M + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> i64 i6 = (M + <span class="number">1</span>) / <span class="number">6</span>;</span><br><span class="line">    i64 n2 = (n + <span class="number">1</span>) * n % M * i2 % M;</span><br><span class="line">    i64 n3 = (<span class="number">2</span> * n + <span class="number">1</span>) * (n + <span class="number">1</span>) % M * n % M * i6 % M;</span><br><span class="line">    Data res = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (a &gt;= c || b &gt;= c) &#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = <span class="built_in">solve</span>(a % c, b % c, c, n);</span><br><span class="line">        i64 aa = a / c, bb = b / c;</span><br><span class="line">        res.f = (tmp.f + aa * n2 + bb * (n + <span class="number">1</span>)) % M;</span><br><span class="line">        res.g = (tmp.g + aa * n3 + bb * n2) % M;</span><br><span class="line">        res.h = (tmp.h + <span class="number">2</span> * bb * tmp.f % M +</span><br><span class="line">                <span class="number">2</span> * aa * tmp.g % M +</span><br><span class="line">                aa * aa % M * n3 % M +</span><br><span class="line">                bb * bb % M * (n + <span class="number">1</span>) % M +</span><br><span class="line">                <span class="number">2</span> * aa * bb % M * n2 % M) % M;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    i64 m = (a * n + b) / c;</span><br><span class="line">    <span class="keyword">if</span> (!m) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">auto</span> tmp = <span class="built_in">solve</span>(c, c - b - <span class="number">1</span>, a, m - <span class="number">1</span>);</span><br><span class="line">    res.f = (m * n - tmp.f + M) % M;</span><br><span class="line">    res.g = (m * n2 + (M - tmp.f) * i2 + (M - tmp.h) * i2) % M;</span><br><span class="line">    res.h = (n * m % M * m - tmp.f - tmp.g * <span class="number">2</span> + <span class="number">3</span> * M) % M;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>‍</p>
<!-- From: Math\数论\莫比乌斯函数与莫比乌斯反演.md -->


<h1 id="莫比乌斯函数与莫比乌斯反演"><a href="#莫比乌斯函数与莫比乌斯反演" class="headerlink" title="莫比乌斯函数与莫比乌斯反演"></a>莫比乌斯函数与莫比乌斯反演</h1><p>‍</p>
<!-- From: Math\线性代数\README.md -->


<h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><p>‍</p>
<!-- From: Math\线性代数\线性基.md -->


<h1 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h1><h1 id="异或空间线性基"><a href="#异或空间线性基" class="headerlink" title="异或空间线性基"></a>异或空间线性基</h1><ol>
<li>定义：一组数字能得到的所有<strong>非0异或和</strong>的结果，能够被<strong>元素个数尽量少</strong>的集合，不多不少地全部得到，那么就说这个元素个数尽量少的集合，是这组数字的<strong>异或空间线性基</strong></li>
<li>性质：<ul>
<li>一组数字中，任意的两个数字 $a$，$b$，用 $a \oplus b$ 的结果代替其中的一个数字，不会影响非0异或和的组成</li>
<li>一组数字中，如果有两个数字 $a\oplus b&#x3D;0$，那么舍弃掉 $a$，$b$ 之中的任何一个数字，不会影响非0异或和的组成</li>
<li>一组数字能得到的异或和如果可以得到0，但其异或空间线性基无法得到0，则需要特殊标记</li>
</ul>
</li>
<li>求法（普通消元）：<ol>
<li>依次取出原数组中的每一个数，观察当前数字的二进制最高有效位</li>
<li>如果最高有效位所对应的线性基不存在，将其填入线性基对应位置，否则将它与对应位置线性基异或，重复至填入线性基或者该数字等于0</li>
<li>如果得到0，则舍弃掉该数字，并且标记原数组异或和可以得到0</li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">XorHamel</span> &#123;</span><br><span class="line">    <span class="type">int</span> BIT;</span><br><span class="line">    <span class="type">bool</span> zero;</span><br><span class="line">    std::vector&lt;T&gt; hamel;</span><br><span class="line">    <span class="built_in">XorHamel</span>() : <span class="built_in">BIT</span>(<span class="built_in">sizeof</span>(T) * __CHAR_BIT__ - <span class="number">1</span>), <span class="built_in">zero</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="built_in">init</span>(std::<span class="built_in">vector</span>&lt;T&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">XorHamel</span>(std::vector&lt;T&gt; &amp;_init) : <span class="built_in">BIT</span>(<span class="built_in">sizeof</span>(T) * __CHAR_BIT__ - <span class="number">1</span>), <span class="built_in">zero</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="built_in">init</span>(_init);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(std::vector&lt;T&gt; &amp;&amp;_init)</span> </span>&#123;</span><br><span class="line">        hamel.<span class="built_in">resize</span>(BIT);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : _init) &#123;</span><br><span class="line">            <span class="keyword">while</span> (x) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hamel[std::__lg(x)] != <span class="number">0</span>) &#123;</span><br><span class="line">                    x ^= hamel[std::__lg(x)];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    hamel[std::__lg(x)] = x;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">                zero = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">MaxXor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = BIT - <span class="number">1</span>;</span><br><span class="line">        T ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (~p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(ans &gt;&gt; p &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">                ans ^= hamel[p];</span><br><span class="line">            &#125;</span><br><span class="line">            p--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hamel[std::__lg(x)] != <span class="number">0</span>) &#123;</span><br><span class="line">                x ^= hamel[std::__lg(x)];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hamel[std::__lg(x)] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    XorHamel <span class="keyword">operator</span>+(<span class="type">const</span> XorHamel &amp;oth) <span class="type">const</span> &#123;</span><br><span class="line">        XorHamel tmp = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;vec : oth.hamel) &#123;</span><br><span class="line">            tmp.<span class="built_in">insert</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="高斯消元求线性基"><a href="#高斯消元求线性基" class="headerlink" title="高斯消元求线性基"></a>高斯消元求线性基</h1><ol>
<li>普通消元可以得到信息：线性基大小，异或和个数，异或和是否含有0，最大异或和等</li>
<li>高斯消元可以<strong>额外</strong>得到的信息：标准线性基，第k小的异或和</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GaussXorHamel</span> &#123;</span><br><span class="line">    <span class="type">int</span> BIT, cnt, n;</span><br><span class="line">    <span class="type">bool</span> zero;</span><br><span class="line">    std::vector&lt;std::bitset&lt;<span class="keyword">sizeof</span>(T) * __CHAR_BIT__ - 1&gt;&gt; hamel;</span><br><span class="line">    <span class="built_in">GaussXorHamel</span>() : <span class="built_in">BIT</span>(<span class="built_in">sizeof</span>(T) * __CHAR_BIT__ - <span class="number">1</span>), <span class="built_in">zero</span>(<span class="literal">false</span>), <span class="built_in">cnt</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">init</span>(std::<span class="built_in">vector</span>&lt;T&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">GaussXorHamel</span>(std::vector&lt;T&gt; &amp;_init) : <span class="built_in">BIT</span>(<span class="built_in">sizeof</span>(T) * __CHAR_BIT__ - <span class="number">1</span>), <span class="built_in">zero</span>(<span class="literal">false</span>), <span class="built_in">cnt</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">init</span>(_init);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(std::vector&lt;T&gt; &amp;_init)</span> </span>&#123;</span><br><span class="line">        n = _init.<span class="built_in">size</span>();</span><br><span class="line">        hamel.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            hamel[i] = _init[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = BIT - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = cnt; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hamel[i].<span class="built_in">test</span>(j)) &#123;</span><br><span class="line">                    std::<span class="built_in">swap</span>(hamel[cnt], hamel[i]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!hamel[cnt].<span class="built_in">test</span>(j)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hamel[i].<span class="built_in">test</span>(j) &amp;&amp; i != cnt) &#123;</span><br><span class="line">                    hamel[i] ^= hamel[cnt];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span> (cnt == n) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; n) &#123;</span><br><span class="line">            zero = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">lowbit</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -x &amp; x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">nth_element</span><span class="params">(T k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (zero) &#123;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= (<span class="number">1ll</span> &lt;&lt; cnt)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        T ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k) &#123;</span><br><span class="line">            ans ^= hamel[cnt - std::__lg(<span class="built_in">lowbit</span>(k)) - <span class="number">1</span>].<span class="built_in">to_ullong</span>();</span><br><span class="line">            k -= <span class="built_in">lowbit</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="向量空间线性基"><a href="#向量空间线性基" class="headerlink" title="向量空间线性基"></a>向量空间线性基</h1><p>普通求法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">VecHamel</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt, _n, _m;</span><br><span class="line">    <span class="type">bool</span> zero;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> _esp;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">double</span>&gt;&gt; hamel;</span><br><span class="line">    std::vector&lt;<span class="type">bool</span>&gt; is_pivot;</span><br><span class="line">    <span class="built_in">VecHamel</span>() : _n(<span class="number">0</span>), _m(<span class="number">0</span>), <span class="built_in">zero</span>(<span class="literal">false</span>), _esp(<span class="number">1e-3</span>) &#123;</span><br><span class="line">        <span class="built_in">init</span>(std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">VecHamel</span>(<span class="type">int</span> n, <span class="type">int</span> m) : _n(n), _m(m), <span class="built_in">zero</span>(<span class="literal">false</span>), _esp(<span class="number">1e-3</span>) &#123;</span><br><span class="line">        hamel.<span class="built_in">resize</span>(_m);</span><br><span class="line">        is_pivot.<span class="built_in">resize</span>(_m, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="built_in">VecHamel</span>(std::vector&lt;std::vector&lt;T&gt;&gt; &amp;_init) : _n(_init.<span class="built_in">size</span>()), _m(_init.<span class="built_in">front</span>().<span class="built_in">size</span>()), <span class="built_in">zero</span>(<span class="literal">false</span>), _esp(<span class="number">1e-3</span>) &#123;</span><br><span class="line">        <span class="built_in">init</span>(_init);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">const</span> std::vector&lt;std::vector&lt;T&gt;&gt; &amp;&amp;_init)</span> </span>&#123;</span><br><span class="line">        hamel.<span class="built_in">resize</span>(_m);</span><br><span class="line">        is_pivot.<span class="built_in">resize</span>(_m, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;vec : _init) &#123;</span><br><span class="line">            <span class="function">std::vector&lt;<span class="type">double</span>&gt; <span class="title">tmp</span><span class="params">(_m)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; _m; j++) &#123;</span><br><span class="line">                tmp[j] = vec[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; _m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (std::<span class="built_in">abs</span>(tmp[j]) &gt; _esp) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!is_pivot[j]) &#123;</span><br><span class="line">                        hamel[j] = tmp;</span><br><span class="line">                        is_pivot[j] = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="type">double</span> times = tmp[j] / hamel[j][j];</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> i = j; i &lt; _m; i++) &#123;</span><br><span class="line">                            tmp[i] -= times * hamel[j][i];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(std::vector&lt;T&gt; &amp;ins)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">double</span>&gt; <span class="title">tmp</span><span class="params">(_m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; _m; j++) &#123;</span><br><span class="line">            tmp[j] = ins[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; _m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (std::<span class="built_in">abs</span>(tmp[j]) &gt; _esp) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!is_pivot[j]) &#123;</span><br><span class="line">                    hamel[j] = tmp;</span><br><span class="line">                    is_pivot[j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">double</span> times = tmp[j] / hamel[j][j];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = j; i &lt; _m; i++) &#123;</span><br><span class="line">                        tmp[i] -= times * hamel[j][i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[P4151 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4151">WC2011] 最大XOR和路径 - 洛谷</a></p>
<!-- From: Math\线性代数\高斯消元.md -->


<h1 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h1><h1 id="高斯消元解加法方程组"><a href="#高斯消元解加法方程组" class="headerlink" title="高斯消元解加法方程组"></a>高斯消元解加法方程组</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">GaussianElimination</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> _ESP;</span><br><span class="line">    <span class="type">int</span> _n, _m, state;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">double</span>&gt;&gt; _equations;</span><br><span class="line">    std::vector&lt;<span class="type">double</span>&gt; solution;</span><br><span class="line">    std::vector&lt;<span class="type">bool</span>&gt; is_pivot;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">init</span><span class="params">(std::vector&lt;std::vector&lt;T&gt;&gt; &amp;_init)</span> </span>&#123;</span><br><span class="line">        _equations.<span class="built_in">resize</span>(_n, std::<span class="built_in">vector</span>&lt;<span class="type">double</span>&gt;(_m + <span class="number">1</span>));</span><br><span class="line">        solution.<span class="built_in">resize</span>(_m);</span><br><span class="line">        is_pivot.<span class="built_in">resize</span>(_m, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= _m; j++) &#123;</span><br><span class="line">                _equations[i][j] = _init[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Work</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">GaussianElimination</span>() : _n(<span class="number">0</span>), _m(<span class="number">0</span>), <span class="built_in">state</span>(<span class="number">0</span>), _ESP(<span class="number">1e-8</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">GaussianElimination</span><span class="params">(std::vector&lt;std::vector&lt;T&gt;&gt; &amp;_init)</span> : _n(_init.size()), _m(_init.frotn().size()), _ESP(<span class="number">1e-8</span>) &#123;</span></span><br><span class="line">        <span class="built_in">init</span>(_init);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; _n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">int</span> row = i;</span><br><span class="line">            <span class="type">double</span> max = std::numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; _n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (std::<span class="built_in">abs</span>(_equations[j][i]) &gt; max) &#123;</span><br><span class="line">                    max = _equations[i][j];</span><br><span class="line">                    row = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (std::<span class="built_in">abs</span>(max) &lt; _ESP) &#123;</span><br><span class="line">                <span class="keyword">if</span> (std::<span class="built_in">abs</span>(_equations[row][_m]) &lt; _ESP) &#123;</span><br><span class="line">                    state = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    state = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                std::<span class="built_in">swap</span>(_equations[i], _equations[row]);</span><br><span class="line">                is_pivot[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = _m; k &gt;= i; k--) &#123;</span><br><span class="line">                    _equations[i][k] /= _equations[i][i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; _n; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i != j &amp;&amp; std::<span class="built_in">abs</span>(_equations[j][i]) &gt; _ESP) &#123;</span><br><span class="line">                        <span class="type">double</span> times = _equations[j][i];</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt;= _m; k++) &#123;</span><br><span class="line">                            _equations[j][k] -= times * _equations[i][k];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (~state) &#123;</span><br><span class="line">            <span class="keyword">if</span> (std::<span class="built_in">count</span>(is_pivot.<span class="built_in">begin</span>(), is_pivot.<span class="built_in">end</span>(), <span class="literal">false</span>)) &#123;</span><br><span class="line">                state = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _m; i++) &#123;</span><br><span class="line">                    solution[i] = _equations[i][_m];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="高斯消元法解异或方程组"><a href="#高斯消元法解异或方程组" class="headerlink" title="高斯消元法解异或方程组"></a>高斯消元法解异或方程组</h1><p><strong>只有0，1系数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// N equations, M variables</span></span><br><span class="line"><span class="comment">// Gaussian Elimination for XOR</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N, <span class="type">int</span> M&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GaussianEliminationXor</span> &#123;</span><br><span class="line">    <span class="type">int</span> _n, _m, state;</span><br><span class="line">    std::array&lt;std::bitset&lt;M + 1&gt;, N&gt; _equations;</span><br><span class="line">    std::vector&lt;<span class="type">bool</span>&gt; solution;</span><br><span class="line">    std::vector&lt;<span class="type">bool</span>&gt; is_pivot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">init</span><span class="params">(std::vector&lt;std::vector&lt;T&gt;&gt; &amp;_init)</span> </span>&#123;</span><br><span class="line">        solution.<span class="built_in">resize</span>(_m, <span class="number">0</span>);</span><br><span class="line">        is_pivot.<span class="built_in">resize</span>(_m, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= _m; j++) &#123;</span><br><span class="line">                _equations[i][j] = _init[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Work</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">GaussianEliminationXor</span><span class="params">(std::vector&lt;std::vector&lt;T&gt;&gt; &amp;_init)</span> : _n(_init.size()), _m(_init.front().size() - <span class="number">1</span>), state(<span class="number">1</span>) &#123;</span></span><br><span class="line">        <span class="built_in">init</span>(_init);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= _n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">int</span> row = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; _n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (_equations[j][i]) &#123;</span><br><span class="line">                    row = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!_equations[row][i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (_equations[row][_m]) &#123;</span><br><span class="line">                    state = <span class="number">-1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    state = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                is_pivot[i] = <span class="literal">true</span>;</span><br><span class="line">                std::<span class="built_in">swap</span>(_equations[i], _equations[row]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; _n; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j != i &amp;&amp; _equations[j][i]) &#123;</span><br><span class="line">                        _equations[j] ^= _equations[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (~state) &#123;</span><br><span class="line">            <span class="keyword">if</span> (std::<span class="built_in">count</span>(is_pivot.<span class="built_in">begin</span>(), is_pivot.<span class="built_in">end</span>(), <span class="literal">false</span>)) &#123;</span><br><span class="line">                state = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _m; i++) &#123;</span><br><span class="line">                    solution[i] = _equations[i][_m];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="高斯消元解同余方程组"><a href="#高斯消元解同余方程组" class="headerlink" title="高斯消元解同余方程组"></a>高斯消元解同余方程组</h1><!-- From: Math\组合\README.md -->


<h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><p>‍</p>
<!-- From: Math\组合\二项式定理和反演_.md -->


<h1 id="二项式定理和反演"><a href="#二项式定理和反演" class="headerlink" title="二项式定理和反演_"></a>二项式定理和反演_</h1><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><ol>
<li><p>组合（comb）：$C_n^k&#x3D;\binom{n}{k}&#x3D;\frac{n!}{k!(n-k)!}$</p>
</li>
<li><p>组合求法：</p>
<ul>
<li>阶乘与逆元预处理</li>
<li>$C[N][M]$ 预处理</li>
<li>因子计数法</li>
<li>$Lucas$ 定理：$\binom{n}{m}\equiv \binom{\lfloor n&#x2F;p\rfloor}{\lfloor m&#x2F;p\rfloor}\binom{n\mod p}{m \mod p}(\mod p),p \in prime$</li>
</ul>
</li>
<li><p><strong>二项式定理</strong>：$(a+b)^n&#x3D;\sum^{n}_{k&#x3D;0}\binom{n}{k}a^{n-k}b^k$</p>
</li>
<li><p>特例 $a&#x3D;b&#x3D;1$ 时，杨辉三角 $(1+1)^n&#x3D;\sum^{n}_{k&#x3D;0}\binom{n}{k}$</p>
<ol>
<li>​			<strong>组合恒等式</strong>：$\binom{n}{m}&#x3D;\binom{n-1}{m}+\binom{n-1}{m-1}$</li>
</ol>
</li>
<li><p>插板法：$\binom{n+k-1}{n}&#x3D;\binom{n+k-1}{k-1}$</p>
<p> $\sum_{i&#x3D;1}^{n}x_i&#x3D;n$：</p>
<ul>
<li>$x_i\ge 0$，$\binom{n+k-1}{k-1}$</li>
<li>$x_i&gt;0$，$\binom{n-1}{k-1}$</li>
<li>${ a },x_i\ge a_i$，$\binom{n+k-1-\sum a_i}{n-\sum a_i}$</li>
</ul>
</li>
</ol>
<h1 id="二项式反演"><a href="#二项式反演" class="headerlink" title="二项式反演"></a>二项式反演</h1><ol>
<li>$g(n)&#x3D;\sum_{i&#x3D;0}^{n}\binom{n}{i}f(i)\iff f(n)&#x3D;\sum_{i&#x3D;0}^{n}(-1)^{n-i} \binom{n}{i}g(i)$</li>
<li>$g(n)&#x3D;\sum_{i&#x3D;0}^{n}(-1)^i\binom{n}{i}f(i) \iff f(n)&#x3D;\sum_{i&#x3D;0}^{n}(-1)^i \binom{n}{i}g(i)$</li>
<li>$g(n)&#x3D;\sum_{i&#x3D;n}^N(-1)^i\binom{i}{n}f(i) \iff f(n)&#x3D;\sum_{i&#x3D;n}^N(-1)^i\binom{i}{n}g(i)$</li>
<li>$g(n)&#x3D;\sum_{i&#x3D;n}^N\binom{i}{n}f(i) \iff f(n)&#x3D;\sum_{i&#x3D;n}^N (-1)^{i-n}\binom{i}{n}g(i)$</li>
</ol>
<h1 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h1><p><strong>二项式系数的组合分解公式</strong>：$\binom{n}{i}\binom{i}{j}&#x3D;\binom{n}{j}\binom{n-j}{i-j}&#x3D;\binom{n}{i}\binom{n-j}{n-i}$，可以通过组合形式化证明。</p>
<p>$$<br>\begin{aligned}<br>f(n)&amp;&#x3D;\sum_{i&#x3D;0}^n(-1)^i\binom{n}{i}g(i) \<br>&amp;&#x3D;\sum_{i&#x3D;0}^n(-1)^i\binom{n}{i}\sum_{j&#x3D;0}^{i}(-1)^j\binom{i}{j}f(j)\<br>&amp;&#x3D;\sum_{j&#x3D;0}^nf(j)\sum_{i&#x3D;j}^n(-1)^{i+j}\binom{n}{i}\binom{i}{j}\<br>&amp;&#x3D;\sum_{j&#x3D;0}^nf(j)\sum_{i&#x3D;j}^n(-1)^{i+j}\binom{n}{j}\binom{n-j}{n-j}\<br>&amp;&#x3D;\sum_{j&#x3D;0}^n\binom{n}{j}f(j)\sum_{i&#x3D;j}^n(-1)^{i+j}\binom{n-j}{n-j}\<br>&amp;&#x3D;\sum_{j&#x3D;0}^n\binom{n}{j}f(j)\delta(n,j)\<br>&amp;&#x3D;f(n)<br>\<br>\delta(n,j)&#x3D;<br>\left{<br>\begin{array}{ll}<br>1 ,&amp; \text{if } j&#x3D;n \<br>0 ,&amp; \text{if } j \ne n<br>\end{array}<br>\right.<br>\end{aligned}<br>$$</p>
<h1 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h1><ol>
<li><p>错排问题：一个排列 $p$，保证 $\forall i,p_i \ne i$ 成立的方法数 $f_n$。</p>
<p> <strong>朴素思维方法</strong>：对于单个位置 $i$，需要有一个数字传入，同时将它自己传出，传入数字不能是他自己。假设传出 $i\rightarrow j，i\ne j$：</p>
<ul>
<li>$j \rightarrow i$，剩余 $n-2$ 个数构成一个子问题 $f_{n-2}$。</li>
<li>$j\not\rightarrow i$，可以将 $\rightarrow (i \rightarrow j) \rightarrow$ 看作一个整体，传入数字同样不能是自身，这样整个问题构成子问题 $f_{n-1}$。</li>
</ul>
<p> 递推关系式：$f_n&#x3D;(n-1)(f_{n-1}+f_{n-2}),f_0&#x3D;1,f_1&#x3D;0$。</p>
<p> <strong>二项式反演</strong>：易知 $n!&#x3D;\sum_{i&#x3D;0}^n \binom{n}{i}f_i$，所有情况为有 $i,(i&#x3D;0,1,…,n)$ 个数不在自己位置的情况的总和。设 $g(n)&#x3D;n!$：</p>
<p> $n!&#x3D;g(n)&#x3D;\sum_{i&#x3D;0}^n \binom{n}{i}f(i) \iff f(n)&#x3D;\sum_{i&#x3D;1}^n (-1)^{n-i}\binom{n}{i}g(i)$</p>
<p> $$<br> \begin{aligned}<br> f(n) &amp;&#x3D; \sum_{i&#x3D;0}^n (-1)^{n-i}\binom{n}{i}g(i) \<br> &amp;&#x3D;\sum_{i&#x3D;0}^n(-1)^{n-i}\frac{n!}{i!(n-i)!}\cdot i!\<br> &amp;&#x3D;\sum_{i&#x3D;0}^n(-1)^i\frac{n!}{i!}<br> \end{aligned}<br> $$</p>
</li>
</ol>
<p>‍</p>
<!-- From: 博弈论.md -->


<h1 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h1><p>‍</p>
<!-- From: 图论\README.md -->


<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><p>‍</p>
<!-- From: 图论\图专题\README.md -->


<h1 id="图专题"><a href="#图专题" class="headerlink" title="图专题"></a>图专题</h1><p>‍</p>
<!-- From: 图论\图专题\仙人掌树.md -->


<h1 id="仙人掌树"><a href="#仙人掌树" class="headerlink" title="仙人掌树"></a>仙人掌树</h1><h1 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h1><p>无向仙人掌树的定义是：任意一条边最多只出现在一个简单回路中的连通无向图称为仙人掌。</p>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5236">P5236 【模板】静态仙人掌 - 洛谷</a></p>
<p>仙人掌树可转化为圆方树进行处理</p>
<p>给定一个仙人掌树，求任意两点之间的最短路径</p>
<p>‍</p>
<!-- From: 图论\图专题\同余最短路.md -->


<h1 id="同余最短路"><a href="#同余最短路" class="headerlink" title="同余最短路"></a>同余最短路</h1><p>解决问题：<strong>总体积极大，单个物品体积较小的完全背包问题</strong>。</p>
<p>了解同余分组的概念。</p>
<h1 id="问题形式："><a href="#问题形式：" class="headerlink" title="问题形式："></a>问题形式：</h1><p>给定 $n$ 个正数，每种数的选择次数无限，问能凑出 $m$ 以内的多少数字。</p>
<h1 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h1><ol>
<li><p>将能够到达的所有总体积按照<strong>最小物品体积</strong> $x$ 划分同余类：$\equiv 0 \pmod x,\equiv 1\pmod x,\equiv 2\pmod x,…,\equiv x-1\pmod x$</p>
<p> 这样做可以：</p>
<ul>
<li>确定 $dis[0]&#x3D;0$</li>
<li>同一个同余类之间可通过增减 $x$ 直接到达</li>
<li>所建图节点数量和边数量最少</li>
</ul>
</li>
<li><p>建图：图顶点个数 $x$ 个，编号 $i&#x3D;0\sim x-1$，表示 $\equiv i\pmod x$ 的同余类</p>
</li>
<li><p>$dis[i]$ 表示能够到达的 $\equiv i\pmod x$ 的最小体积，从0开始，$dis[0]&#x3D;0$</p>
</li>
<li><p>将所有其他物品体积 $v$ 取 $v’&#x3D;v\mod x$，对所有 $0\sim x-1$，连接一条 $i\overset{v}\longrightarrow (i+v’)\mod x$ 的边，权重是 $v$</p>
</li>
<li><p>从0出发求单源最短路，所得的 $dis[i]$ 便是能够拼凑出的 $\equiv i\pmod x$ 的最小体积，注意要求要满足 $dis[i]\le m$</p>
</li>
</ol>
<h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><ol>
<li>对于 $\equiv i\pmod x$ 的所有体积，$dis[i]+kx,k&#x3D;0,1,2,…$ 均可以通过增加 $x$ 得到，而小于 $dis[i]$ 的同余 x 类均无法到达。</li>
<li>求最短路过程中，可用传统的 <em>dijkstra</em> 算法或者 <em>spfa</em> 算法</li>
<li>求最短路的过程中，可使用同余最短路独特的性质，使用<strong>二次转圈法</strong><ul>
<li>若当前物品体积为 $v$，可以证明 $cur\overset{v}\longrightarrow (cur+v)\mod x$，对于起点 $s&#x3D;0,1,2,…,\gcd(x,v)-1$，每个起点会形成一个包含 $\frac{x}{d}$ 个顶点的环，由于该环必为正权环，所以遍历两次即可将环上每个顶点更新为当前最值。</li>
</ul>
</li>
</ol>
<h1 id="例题-5"><a href="#例题-5" class="headerlink" title="例题"></a>例题</h1><ol>
<li><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3403">P3403 跳楼机 - 洛谷</a></p>
<p> 经典模板题</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2662">P2662 牛场围栏 - 洛谷</a></p>
<p> 用到了性质：$dis[i]$ 为当前能到达的 $\equiv i\pmod x$ 的最小值，则 $dis[i]-x$ 为 $\equiv i\pmod x$ 同余系下的不能到达的最大值</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc077/tasks/arc084_b">D - Small Multiple</a></p>
<p> 巧妙的构造</p>
<p> 问题大意：求 **K **的正倍数的小数位数的最小和 $2 \leq K \leq 10^5$</p>
<p> K的正倍数即为 $\equiv 0\pmod k$ 的同余系（排除0），从1开始，初始 $cost&#x3D;1$，<strong>可以通过</strong>​ **<em><strong>​</strong>10和+1两种操作将1变为其他任意数字</em><em>，其中*10的 $cost&#x3D;0$，+1的 $cost&#x3D;1$，使用</em>01bfs*求解，边为 $i \overset{0}\longrightarrow 10\cdot i \mod k,i\overset{1}\longrightarrow (i+1)\mod k$，寻找能到达0节点，也就是 $\equiv 0\pmod x$ 的最短路</p>
</li>
<li><p>[P2371 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2371">国家集训队] 墨墨的等式 - 洛谷</a></p>
<p> 模板题</p>
</li>
<li><p>[P9140 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P9140">THUPC 2023 初赛] 背包 - 洛谷</a></p>
<p> 用同余最短路优化dp过程：完全背包问题的加强版</p>
<ol>
<li><p>首先，找出所有物品中<strong>性价比最大</strong>的物品作为基准物品，设该物品体积为 $x$, 价值为 $y$（可同时挑选体积最小）</p>
</li>
<li><p>将背包的所有体积分成 $x$ 个 $\equiv i\pmod x$ 的同余类，设计数组 $dp[i]$，表示总体积为 $V \equiv i\pmod x$ 的前提下，若先选择 $\lfloor\frac{V}{x} \rfloor$ 个基准物品，应补偿 $dp[i]$ ，使其通过退回一些基准物品，选择一些其他物品，使其总体积达到V，此时的总价值为 $\lfloor\frac{V}{x} \rfloor\cdot y+dp[V\mod x]$，通过依次选取每个物品来最大化 $dp[i]$</p>
</li>
<li><p>对于当前物品，设其体积为 $v$，价值为 $c$，在其 $i\overset{v}\longrightarrow (i+v)\mod x$ 转移的过程中，添加了一个 $v$ 重的物品，相当于退还 $i+v$ 体积的基准物品，加入一个当前物品，因此状态转移方程为：</p>
<p> $$<br> dp[(i+v)\mod x]&#x3D;max(dp[(i+v)\mod x],dp[i]-\lfloor\frac{i+v}{x}\rfloor\cdot y+c)<br> $$</p>
</li>
<li><p>边权为 $-\lfloor\frac{i+v}{x}\rfloor\cdot y+c$ 可知在组成的所有边中存在负权，<strong>但是一定不存在负环</strong>，如果存在负环，则对于负环上某一点 $i$，在体积改变 $k\cdot x$ 后可以将它更新为最小，则不满足基准物品性价比最高的前提</p>
</li>
</ol>
</li>
</ol>
<!-- From: 图论\图专题\连通性问题\README.md -->


<h1 id="连通性问题"><a href="#连通性问题" class="headerlink" title="连通性问题"></a>连通性问题</h1><ol>
<li><p>强连通分量</p>
</li>
<li><p>双连通分量</p>
</li>
<li><p>割点和桥</p>
</li>
<li><p>圆方树</p>
</li>
<li><p>点&#x2F;边连通度</p>
<p> ‍</p>
</li>
</ol>
<!-- From: 图论\图专题\连通性问题\割点和桥.md -->


<h1 id="割点和桥"><a href="#割点和桥" class="headerlink" title="割点和桥"></a>割点和桥</h1><h1 id="割点"><a href="#割点" class="headerlink" title="割点"></a>割点</h1><blockquote>
<p>对于一个无向图，如果把一个点删除后这个图的极大连通分量数增加了，那么这个点就是这个图的割点（又称割顶）。</p>
</blockquote>
<p>首先，我们按照 DFS 序给他打上时间戳（访问的顺序）。</p>
<p><img src="/%5Cassets%5Cimage-20250606155526-xjr1h2v.png" alt="image"></p>
<p>这些信息被我们保存在一个叫做 <code>dfn</code> 的数组中。</p>
<p>还需要另外一个数组 <code>low</code>，用它来存储不经过其父亲能到达的最小的时间戳。</p>
<p>例如 <code>low[2]</code>​ 是 1，<code>low[5]</code>​ 和 <code>low[6]</code> 是 3。</p>
<p>然后我们开始 DFS，我们判断某个点是否是割点的根据是：对于某个顶点 $u$，如果存在至少一个顶点 $v$（$u$ 的儿子），使得 $low_v \geq dfn_u$，即不能回到祖先，那么 $u$ 点为割点。</p>
<p>此根据惟独不适用于搜索的起始点，其需要特殊考虑：若该点不是割点，则其他路径亦能到达全部结点，因此从起始点只「向下搜了一次」，即在搜索树内仅有一个子结点。如果在搜索树内有两个及以上的儿子，那么他一定是割点了（设想上图从 2 开始搜索，搜索树内应有两个子结点：3 或 4 及 5 或 6）。如果只有一个儿子，那么把它删掉，不会有任何的影响。比如下面这个图，此处形成了一个环。</p>
<p><img src="/%5Cassets%5Cimage-20250606155546-fur0hlw.png" alt="image"></p>
<p>我们在访问 1 的儿子时候，假设先 DFS 到了 2，然后标记用过，然后递归往下，来到了 4，4 又来到了 3，当递归回溯的时候，会发现 3 已经被访问过了，所以不是割点。</p>
<p>更新 <code>low</code> 的伪代码如下：</p>
<p>$$<br>\begin{array}{ll}<br>1 &amp; \textbf{if } v \text{ is a son of } u \<br>2 &amp; \qquad \text{low}_u &#x3D; \min(\text{low}_u, \text{low}_v) \<br>3 &amp; \textbf{else} \<br>4 &amp; \qquad \text{low}_u &#x3D; \min(\text{low}_u, \text{dfn}_v) \<br>\end{array}<br>$$</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3388">洛谷 P3388【模板】割点（割顶）</a></p>
<h1 id="割边（无重边时）"><a href="#割边（无重边时）" class="headerlink" title="割边（无重边时）"></a>割边（无重边时）</h1><p>和割点差不多，叫做桥。</p>
<blockquote>
<p>对于一个无向图，如果删掉一条边后图中的连通分量数增加了，则称这条边为桥或者割边。严谨来说，就是：假设有连通图 $G&#x3D;{V,E}$，$e$ 是其中一条边（即 $e \in E$），如果 $G-e$ 是不连通的，则边 $e$ 是图 $G$ 的一条割边（桥）。</p>
</blockquote>
<p>比如说，下图中，</p>
<p><img src="/%5Cassets%5Cimage-20250606155949-h4y8fot.png" alt="image"></p>
<p>红色的边就是割边。</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>和割点差不多，只要改一处：$low_v&gt;dfn_u$ 就可以了，而且不需要考虑根节点的问题。</p>
<p>割边是和是不是根节点没关系的，原来我们求割点的时候是指点 $v$ 是不可能不经过父节点 $u$ 为回到祖先节点（包括父节点），所以顶点 $u$ 是割点。如果 $low_v&#x3D;dfn_u$ 表示还可以回到父节点，如果顶点 $v$ 不能回到祖先也没有另外一条回到父亲的路，那么 $u-v$ 这条边就是割边。</p>
<h1 id="割边（有重边时）"><a href="#割边（有重边时）" class="headerlink" title="割边（有重边时）"></a>割边（有重边时）</h1><p>两节点间可能不止有一条边，此时它们都不会是桥。</p>
<h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><p>一种思路是将参数 <code>fa</code> 改为刚刚走过的边的编号（每条边的编号一致）即可，即将「不用父节点更新」改为「不用来时的边更新」。</p>
<p>另一种更简单的思路是设立一个标记判断是否已有一条边抵达父节点，标记后再访问到父节点时正常更新。</p>
<p>‍</p>
<!-- From: 图论\图专题\连通性问题\圆方树.md -->


<h1 id="圆方树"><a href="#圆方树" class="headerlink" title="圆方树"></a>圆方树</h1><h1 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h1><p>该模板为<strong>广义圆方树</strong>，在无向图中两圆点之间也会新建有一个方点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">RoundSquareTree</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, vdcc_cnt, timestamp = <span class="number">0</span>;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; dfn, low;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; g, t;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    <span class="built_in">RoundSquareTree</span>(<span class="type">int</span> n) : <span class="built_in">n</span>(n), <span class="built_in">vdcc_cnt</span>(n) &#123;</span><br><span class="line">        g.<span class="built_in">resize</span>(n);</span><br><span class="line">        t.<span class="built_in">resize</span>(n * <span class="number">2</span>);</span><br><span class="line">        dfn.<span class="built_in">resize</span>(n);</span><br><span class="line">        low.<span class="built_in">resize</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        dfn[u] = low[u] = ++timestamp;</span><br><span class="line">        stk.<span class="built_in">push</span>(u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : g[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">                <span class="built_in">tarjan</span>(v);</span><br><span class="line">                low[u] = std::<span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">                <span class="keyword">if</span> (dfn[u] == low[v]) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">-1</span>; x != v; ) &#123;</span><br><span class="line">                        x = stk.<span class="built_in">top</span>();</span><br><span class="line">                        stk.<span class="built_in">pop</span>();</span><br><span class="line">                        t[vdcc_cnt].<span class="built_in">push_back</span>(x);</span><br><span class="line">                        t[x].<span class="built_in">push_back</span>(vdcc_cnt);</span><br><span class="line">                    &#125;</span><br><span class="line">                    t[vdcc_cnt].<span class="built_in">push_back</span>(u);</span><br><span class="line">                    t[u].<span class="built_in">push_back</span>(vdcc_cnt);</span><br><span class="line">                    vdcc_cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low[u] = std::<span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfn[i]) &#123;</span><br><span class="line">                <span class="built_in">tarjan</span>(i);</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp; <span class="keyword">operator</span>[](<span class="type">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">return</span> t[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一种将图上问题转换为树上问题的方法。</p>
<h1 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h1><p>暂定点双图的定义为：不存在割点的图。点双连通分量则定义为极大点双连通子图。</p>
<p>在圆方树中，原来每个点对应一个圆点，每个点双对应一个方点，所以圆方树共有 $n+c$ 个点，$n$ 为原图的点数，$c$ 为点双连通分量的个数。总点数 $\le 2n$，从每个方点向属于它对应的点双的圆点连一条边。由于割点会属于多个点双连通分量，这样原图的一个连通分量可以转换为同样联通的一棵树。</p>
<p>如果原图一个连通分量中只存在一个点，则单独考虑。</p>
<p><img src="/%5Cassets%5Cimage-20250606160744-iecaqe0.png" alt="image"><img src="/%5Cassets%5Cimage-20250606160747-iki2ml0.png" alt="image"><img src="/%5Cassets%5Cimage-20250606160749-6wvq2p7.png" alt="image"></p>
<h1 id="过程-2"><a href="#过程-2" class="headerlink" title="过程"></a>过程</h1><p>对于一个图，如何构造出它的圆方树呢？首先可以发现如果图不连通，可以拆分成每个连通子图考虑，所以我们只考虑连通图。</p>
<p>因为圆方树是基于点双连通分量的，而点双连通分量又基于割点，所以只需要用类似求割点的方法即可。</p>
<p>求割点的常用算法是 Tarjan 算法，如果你会了理解下面的内容就很简单了，如果你不会也没关系。</p>
<p>我们跳过 Tarjan 求割点，直接介绍圆方树使用的算法（其实是 Tarjan 的变体）：</p>
<p>对图进行 DFS，并且中间用到了两个关键数组 <code>dfn</code>​ 和 <code>low</code>（类似于 Tarjan）。</p>
<p>​<code>dfn[u]</code> 存储的是节点 $u$ 的 DFS 序，即第一次访问到 $u$ 时它是第几个被访问的节点。<br>​<code>low[u]</code> 存储的是节点 $u$ 的 DFS 树中的子树中的某个点 $v$ 通过 <strong>最多一次返祖边或向父亲的树边</strong> 能访问到的点的 <strong>最小</strong> DFS 序。<br>如果没有听说过 Tarjan 算法可能会有点难理解，让我们举个例子吧：</p>
<p><img src="/%5Cassets%5Cimage-20250606161902-pqdfsms.png" alt="image"></p>
<p>（可以发现这张图其实和上面图片中的图等价）<br>这里树边从上至下用直线画出，返祖边从下至上用曲线画出。节点的编号便是它的 DFS 序。</p>
<p>则有 <code>low</code> 数组如下：</p>
<table>
<thead>
<tr>
<th align="center">$i$</th>
<th align="center">$1$</th>
<th align="center">$2$</th>
<th align="center">$3$</th>
<th align="center">$4$</th>
<th align="center">$5$</th>
<th align="center">$6$</th>
<th align="center">$7$</th>
<th align="center">$8$</th>
<th align="center">$9$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\mathrm{low}[i]$</td>
<td align="center">$1$</td>
<td align="center">$1$</td>
<td align="center">$1$</td>
<td align="center">$3$</td>
<td align="center">$3$</td>
<td align="center">$4$</td>
<td align="center">$3$</td>
<td align="center">$3$</td>
<td align="center">$7$</td>
</tr>
</tbody></table>
<p>并不是很难理解吧，注意这里 $9$ 的 <code>low</code> 是 $7$，与一些求割点的做法有差异，因为为了方便，我们规定了可以通过父边向上，但主要思想是相同的。</p>
<p>接下来，我们考虑点双和 DFS 树以及这两个数组之间的关联。</p>
<p>可以发现，每个点双在 DFS 树上是一棵连通子树，并至少包含两个点；特别地，最顶端节点仅往下接一个点。</p>
<p>同时还可以发现每条树边恰好在一个点双内。</p>
<p>我们考虑一个点双在 DFS 树中的最顶端节点 $u$，在 $u$ 处确定这个点双，因为 $u$ 的子树包含了整个点双的信息。</p>
<p>因为至少有两个点，考虑这个点双的下一个点 $v$，则有 $u$，$v$ 之间存在一条树边。</p>
<p>不难发现，此时一定有 $\mathrm{low}[v]&#x3D;\mathrm{dfn}[u]$。<br>更准确地说，对于一条树边 $u\to v$，$u,v$ 在同一个点双中，且 $u$ 是这个点双中深度最浅的节点 <strong>当且仅当</strong> $\mathrm{low}[v]&#x3D;\mathrm{dfn}[u]$。</p>
<p>那么我们可以在 DFS 的过程中确定哪些地方存在点双，但是还不能准确确定一个点双所包含的点集。</p>
<p>这并不难处理，我们可以在 DFS 过程中维护一个栈，存储还未确定所属点双（可能有多个）的节点。</p>
<p>在找到点双时，点双中除了 $u$ 以外的其他的点都集中在栈顶端，只需要不断弹栈直到弹出 $v$ 为止即可。</p>
<p>当然，我们可以同时处理被弹出的节点，只要将其和新建的方点连边即可。最后还要让 $u$ 和方点连边。</p>
<p>这样就很自然地完成了圆方树的构建，我们可以给方点标号为 $n+1$ 开始的整数，这样可以有效区分圆点和方点。</p>
<h1 id="例题-6"><a href="#例题-6" class="headerlink" title="例题"></a>例题</h1><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/article/cdut0j6a">圆方树学习笔记 - 洛谷专栏</a></p>
<p>‍</p>
<!-- From: 图论\图专题\连通性问题\无向图的双连通分量.md -->


<h1 id="无向图的双连通分量"><a href="#无向图的双连通分量" class="headerlink" title="无向图的双连通分量"></a>无向图的双连通分量</h1><h1 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h1><p>在一张连通的无向图中，对于两个点 $u$ 和 $v$，如果无论删去哪条边（只能删去一条）都不能使它们不连通，我们就说 $u$ 和 $v$  <strong>边双连通</strong>。</p>
<p>在一张连通的无向图中，对于两个点 $u$ 和 $v$，如果无论删去哪个点（只能删去一个，且不能删 $u$ 和 $v$ 自己）都不能使它们不连通，我们就说 $u$ 和 $v$  <strong>点双连通</strong>。</p>
<p>边双连通具有传递性，即，若 $x,y$ 边双连通，$y,z$ 边双连通，则 $x,z$ 边双连通。</p>
<p>点双连通 <strong>不</strong> 具有传递性，反例如下图，$A,B$ 点双连通，$B,C$ 点双连通，而 $A,C$  <strong>不</strong> 点双连通。</p>
<p><img src="/%5Cassets%5Cimage-20250606160207-b4qsqio.png" alt="image"></p>
<p>对于一个无向图中的 <strong>极大</strong> 边双连通的子图，我们称这个子图为一个 <strong>边双连通分量</strong>。</p>
<p>对于一个无向图中的 <strong>极大</strong> 点双连通的子图，我们称这个子图为一个 <strong>点双连通分量</strong>。</p>
<h1 id="DFS-生成树"><a href="#DFS-生成树" class="headerlink" title="DFS 生成树"></a>DFS 生成树</h1><p>对于一张连通的无向图，我们可以从任意一点开始 DFS，得到原图的一棵 DFS 生成树（以开始 DFS 的那个点为根），这棵生成树上的边称作 <strong>树边</strong>，不在生成树上的边称作 <strong>非树边</strong>。</p>
<p>由于 DFS 的性质，我们可以保证所有非树边连接的两个点在生成树上都满足其中一个是另一个的祖先。</p>
<h1 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h1><h2 id="V-DCC"><a href="#V-DCC" class="headerlink" title="V-DCC"></a>V-DCC</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">VDCC</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m, _cnt, timestamp, vdcc_cnt, cut_cnt;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; head, next, to;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; dfn, low, id;</span><br><span class="line">    std::vector&lt;<span class="type">bool</span>&gt; is_cut;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; vdcc;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    <span class="built_in">VDCC</span>(<span class="type">int</span> n = <span class="number">0</span>, <span class="type">int</span> m = <span class="number">0</span>) : <span class="built_in">n</span>(n), <span class="built_in">m</span>(m * <span class="number">2</span>) &#123;</span><br><span class="line">        _init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> _init() &#123;</span><br><span class="line">        _cnt = timestamp = vdcc_cnt= cut_cnt = <span class="number">0</span>;</span><br><span class="line">        head.<span class="built_in">resize</span>(n);</span><br><span class="line">        next.<span class="built_in">resize</span>(m);</span><br><span class="line">        to.<span class="built_in">resize</span>(m);</span><br><span class="line">        dfn.<span class="built_in">resize</span>(n);</span><br><span class="line">        low.<span class="built_in">resize</span>(n);</span><br><span class="line">        id.<span class="built_in">resize</span>(n);</span><br><span class="line">        is_cut.<span class="built_in">resize</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        next[_cnt] = head[u];</span><br><span class="line">        to[_cnt] = v;</span><br><span class="line">        head[u] = _cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">        dfn[u] = low[u] = ++timestamp;</span><br><span class="line">        <span class="keyword">if</span> (u == root &amp;&amp; head[u] == <span class="number">-1</span>) &#123;</span><br><span class="line">            vdcc.<span class="built_in">emplace_back</span>(std::vector&lt;<span class="type">int</span>&gt;&#123;u&#125;);</span><br><span class="line">            vdcc_cnt++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stk.<span class="built_in">push</span>(u);</span><br><span class="line">        <span class="type">int</span> cil = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> ne = head[u]; ~ne; ne = next[ne]) &#123;</span><br><span class="line">            <span class="type">int</span> v = to[ne];</span><br><span class="line">            <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">                <span class="built_in">tarjan</span>(v, root);</span><br><span class="line">                low[u] = std::<span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">                <span class="keyword">if</span> (dfn[u] &lt;= low[v]) &#123;</span><br><span class="line">                    cil++;</span><br><span class="line">                    <span class="keyword">if</span> (u != root || cil &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                        is_cut[u] = <span class="literal">true</span>;</span><br><span class="line">                        cut_cnt++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    std::vector&lt;<span class="type">int</span>&gt; tvdcc;</span><br><span class="line">                    <span class="type">int</span> y;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        y = stk.<span class="built_in">top</span>();</span><br><span class="line">                        stk.<span class="built_in">pop</span>();</span><br><span class="line">                        tvdcc.<span class="built_in">push_back</span>(y);</span><br><span class="line">                    &#125; <span class="keyword">while</span> (y != v);</span><br><span class="line">                    tvdcc.<span class="built_in">push_back</span>(u);</span><br><span class="line">                    vdcc.<span class="built_in">emplace_back</span>(tvdcc);</span><br><span class="line">                    vdcc_cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low[u] = std::<span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfn[i]) &#123;</span><br><span class="line">                <span class="built_in">tarjan</span>(i, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>‍</p>
<h2 id="E-DCC"><a href="#E-DCC" class="headerlink" title="E-DCC"></a>E-DCC</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">EDCC</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m, _cnt, timestamp, edcc_cnt;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; head, next, to;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; dfn, low, id;</span><br><span class="line">    std::vector&lt;<span class="type">bool</span>&gt; is_bridge;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; edcc;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    <span class="built_in">EDCC</span>(<span class="type">int</span> n = <span class="number">0</span>, <span class="type">int</span> m = <span class="number">0</span>) : <span class="built_in">n</span>(n), <span class="built_in">m</span>(m * <span class="number">2</span>) &#123;</span><br><span class="line">        _init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> _init() &#123;</span><br><span class="line">        _cnt = timestamp = edcc_cnt = <span class="number">0</span>;</span><br><span class="line">        head.<span class="built_in">resize</span>(n, <span class="number">-1</span>);</span><br><span class="line">        next.<span class="built_in">resize</span>(m);</span><br><span class="line">        to.<span class="built_in">resize</span>(m);</span><br><span class="line">        dfn.<span class="built_in">resize</span>(n);</span><br><span class="line">        low.<span class="built_in">resize</span>(n);</span><br><span class="line">        id.<span class="built_in">resize</span>(n);</span><br><span class="line">        is_bridge.<span class="built_in">resize</span>(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        next[_cnt] = head[u];</span><br><span class="line">        to[_cnt] = v;</span><br><span class="line">        head[u] = _cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> from)</span> </span>&#123;</span><br><span class="line">        dfn[u] = low[u] = ++timestamp;</span><br><span class="line">        stk.<span class="built_in">push</span>(u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> ne = head[u]; ~ne; ne = next[ne]) &#123;</span><br><span class="line">            <span class="type">int</span> v = to[ne];</span><br><span class="line">            <span class="keyword">if</span> (ne == (from ^ <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">                <span class="built_in">tarjan</span>(v, ne);</span><br><span class="line">                low[u] = std::<span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">                <span class="keyword">if</span> (dfn[u] &lt; low[u]) &#123;</span><br><span class="line">                    is_bridge[ne] = is_bridge[ne ^ <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low[u] = std::<span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dfn[u] == low[u]) &#123;</span><br><span class="line">            <span class="type">int</span> v;</span><br><span class="line">            std::vector&lt;<span class="type">int</span>&gt; tedcc;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                v = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                id[v] = edcc_cnt;</span><br><span class="line">                tedcc.<span class="built_in">push_back</span>(v);</span><br><span class="line">            &#125; <span class="keyword">while</span> (u != v);</span><br><span class="line">            edcc.<span class="built_in">emplace_back</span>(tedcc);</span><br><span class="line">            edcc_cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfn[i]) &#123;</span><br><span class="line">                <span class="built_in">tarjan</span>(i, <span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>‍</p>
<!-- From: 图论\图专题\连通性问题\有向图的强连通分量 SCC.md -->


<h1 id="有向图的强连通分量-SCC"><a href="#有向图的强连通分量-SCC" class="headerlink" title="有向图的强连通分量 SCC"></a>有向图的强连通分量 SCC</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SCC</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, _cnt, timestamp, scc_cnt;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; dfn, low, id;</span><br><span class="line">    std::vector&lt;<span class="type">bool</span>&gt; in_stk;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; g, scc;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    <span class="built_in">SCC</span>(<span class="type">int</span> n) : <span class="built_in">n</span>(n) &#123;</span><br><span class="line">        g.<span class="built_in">resize</span>(n);</span><br><span class="line">        _cnt = timestamp = scc_cnt = <span class="number">0</span>;</span><br><span class="line">        dfn.<span class="built_in">resize</span>(n);</span><br><span class="line">        low.<span class="built_in">resize</span>(n);</span><br><span class="line">        id.<span class="built_in">resize</span>(n);</span><br><span class="line">		in_stk.<span class="built_in">resize</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        dfn[u] = low[u] = ++timestamp;</span><br><span class="line">        stk.<span class="built_in">push</span>(u);</span><br><span class="line">        in_stk[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : g[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">                <span class="built_in">tarjan</span>(v);</span><br><span class="line">                low[u] = std::<span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (in_stk[v]) &#123;</span><br><span class="line">                low[u] = std::<span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dfn[u] == low[u]) &#123;</span><br><span class="line">            <span class="type">int</span> v;</span><br><span class="line">            std::vector&lt;<span class="type">int</span>&gt; tscc;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                v = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                in_stk[v] = <span class="literal">false</span>;</span><br><span class="line">                id[v] = scc_cnt;</span><br><span class="line">                tscc.<span class="built_in">push_back</span>(v);</span><br><span class="line">            &#125; <span class="keyword">while</span> (v != u);</span><br><span class="line">            scc.<span class="built_in">emplace_back</span>(tscc);</span><br><span class="line">            scc_cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfn[i]) &#123;</span><br><span class="line">                <span class="built_in">tarjan</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>‍</p>
<h1 id="DFS-生成树-1"><a href="#DFS-生成树-1" class="headerlink" title="DFS 生成树"></a>DFS 生成树</h1><p>在介绍该算法之前，先来了解 <strong>DFS 生成树</strong>，我们以下面的有向图为例：</p>
<p><img src="/%5Cassets%5Cimage-20250606154604-bbpqrwl.png" alt="image"></p>
<p>有向图的 DFS 生成树主要有 4 种边（不一定全部出现）：</p>
<ol>
<li>树边（tree edge）：示意图中以黑色边表示，每次搜索找到一个还没有访问过的结点的时候就形成了一条树边。</li>
<li>反祖边（back edge）：示意图中以红色边表示（即 $7 \rightarrow 1$），也被叫做回边，即指向祖先结点的边。</li>
<li>横叉边（cross edge）：示意图中以蓝色边表示（即 $9 \rightarrow 7$），它主要是在搜索的时候遇到了一个已经访问过的结点，但是这个结点 <strong>并不是</strong> 当前结点的祖先。</li>
<li>前向边（forward edge）：示意图中以绿色边表示（即 $3 \rightarrow 6$），它是在搜索的时候遇到子树中的结点的时候形成的。</li>
</ol>
<p>我们考虑 DFS 生成树与强连通分量之间的关系。</p>
<p>如果结点 $u$ 是某个强连通分量在搜索树中遇到的第一个结点，那么这个强连通分量的其余结点肯定是在搜索树中以 $u$ 为根的子树中。结点 $u$ 被称为这个强连通分量的根。</p>
<blockquote>
<p>反证法：假设有个结点 $v$ 在该强连通分量中但是不在以 $u$ 为根的子树中，那么 $u$ 到 $v$ 的路径中肯定有一条离开子树的边。但是这样的边只可能是横叉边或者反祖边，然而这两条边都要求指向的结点已经被访问过了，这就和 $v$ 不在以 $u$ 为根的子树中矛盾了。得证。</p>
</blockquote>
<h1 id="Tarjan-算法求强连通分量"><a href="#Tarjan-算法求强连通分量" class="headerlink" title="Tarjan 算法求强连通分量"></a>Tarjan 算法求强连通分量</h1><p>Tarjan 算法基于对图进行 <a target="_blank" rel="noopener" href="https://oi-wiki.org/graph/dfs/">深度优先搜索</a>。我们视每个连通分量为搜索树中的一棵子树，在搜索过程中，维护一个栈，每次把搜索树中尚未处理的节点加入栈中。</p>
<p>在 Tarjan 算法中为每个结点 $u$ 维护了以下几个变量：</p>
<ol>
<li>$\textit{dfn}_u$：深度优先搜索遍历时结点 $u$ 被搜索的次序。</li>
<li>$\textit{low}_u$：在 $u$ 的子树中能够回溯到的最早的已经在栈中的结点。设以 $u$ 为根的子树为 $\textit{Subtree}_u$。$\textit{low}_u$ 定义为以下结点的 $\textit{dfn}$ 的最小值：$\textit{Subtree}_u$ 中的结点；从 $\textit{Subtree}_u$ 通过一条不在搜索树上的边能到达的结点。</li>
</ol>
<p>一个结点的子树内结点的 dfn 都大于该结点的 dfn。</p>
<p>从根开始的一条路径上的 dfn 严格递增，low 严格非降。</p>
<p>按照深度优先搜索算法搜索的次序对图中所有的结点进行搜索，维护每个结点的 <code>dfn</code>​ 与 <code>low</code> 变量，且让搜索到的结点入栈。每当找到一个强连通元素，就按照该元素包含结点数目让栈中元素出栈。在搜索过程中，对于结点 $u$ 和与其相邻的结点 $v$（$v$ 不是 $u$ 的父节点）考虑 3 种情况：</p>
<ol>
<li>$v$ 未被访问：继续对 $v$ 进行深度搜索。在回溯过程中，用 $\textit{low}_v$ 更新 $\textit{low}_u$。因为存在从 $u$ 到 $v$ 的直接路径，所以 $v$ 能够回溯到的已经在栈中的结点，$u$ 也一定能够回溯到。</li>
<li>$v$ 被访问过，已经在栈中：根据 low 值的定义，用 $\textit{dfn}_v$ 更新 $\textit{low}_u$。</li>
<li>$v$ 被访问过，已不在栈中：说明 $v$ 已搜索完毕，其所在连通分量已被处理，所以不用对其做操作。</li>
</ol>
<h1 id="分量标号和拓扑序的关系"><a href="#分量标号和拓扑序的关系" class="headerlink" title="分量标号和拓扑序的关系"></a>分量标号和拓扑序的关系</h1><p>Tarjan 算法在处理过程中，实际上是按照某种 <strong>逆拓扑序</strong> 来发现强连通分量的，这是因为算法在深度优先搜索的过程中会先访问那些没有出边的节点，而这与拓扑排序的过程是相反的。</p>
<p>如果我们将图中的所有强连通分量缩成单个节点，那么在这些缩点后的节点形成的 DAG 中进行拓扑排序，得到的顺序将与 Tarjan 算法给出的强连通分量的标号顺序相反。</p>
<p>因此，可以说，在缩点后的 DAG 中，<strong>强连通分量（缩点后）的标号顺序是其拓扑序的逆序</strong>。但要注意的是，这种说法仅在考虑了强连通分量之间的依赖关系（即从一个强连通分量到另一个强连通分量的有向边）时才成立。单个强连通分量内部的节点由于存在环，所以内部并不满足拓扑序的定义。</p>
<p>‍</p>
<!-- From: 图论\树专题\Kruskal重构树.md -->


<h1 id="Kruskal重构树"><a href="#Kruskal重构树" class="headerlink" title="Kruskal重构树"></a>Kruskal重构树</h1><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><ol>
<li>原图所有节点是 kruskal 重构树中的叶节点，边变为非叶节点</li>
<li>首先有 $1\sim n$ 个叶节点，考虑加入一条边，该条边是当前最小（最优）的，并且可以连接两个不连通的树，那就把它<strong>转换为一个点</strong>加入到当前重构树中，连接的两个代表节点是两个连通区域的最优代表节点。之后将这个合并后的连通区域的最优节点设为该点（通过并查集实现）</li>
<li>边权从小到大考虑（具体看如何统计信息），如果不能增加连通性，则舍弃；否则作为一个节点加入当前树，节点权值为该边边权</li>
<li>在节点 $(u,v)$ 之间的 $lca$ 点的权值即为两点之间最大边的最小边权</li>
</ol>
<h1 id="适用问题"><a href="#适用问题" class="headerlink" title="适用问题"></a>适用问题</h1><p>由此看，kruskal 重构树适合解决的问题：适用于图，<strong>对边有限制</strong>的点之间的问题。</p>
<p>kruskal 重构树与<strong>最小瓶颈树</strong>紧密结合，最简单地，给定一个图，求两个点之间所有路径的最大边权的最小值。</p>
<h1 id="例题-7"><a href="#例题-7" class="headerlink" title="例题"></a>例题</h1><ol>
<li><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2245">P2245 星际导航 - 洛谷</a></p>
<p> 模板题，一个图两点间所有路径上的最大边权的最小值</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P9638">P9638 「yyOI R1」youyou 的军训 - 洛谷</a></p>
<p> 满足一定边的条件下某点所在连通块的大小。因为原图的点均为重构树的叶子节点，所以只有叶子节点计算权值，然后将重构树上所有点子树的权值求出</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/agc002/tasks/agc002_d">D - Stamp Rally</a></p>
<p> 没有明显的边权，挖掘隐含条件，用输入边的编号索引作为权值</p>
<p> 二分可能的最大索引，若两棵树相交，则能够到达的点为 $siz[lca]$，否则为 $siz[u]+siz[v]$</p>
<p> 判断数量是否满足即可</p>
</li>
<li><p>[P4768 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4768">NOI2018] 归程 - 洛谷</a></p>
<p> 最短路+kruskal 生成树</p>
</li>
</ol>
<!-- From: 图论\树专题\README.md -->


<h1 id="树专题"><a href="#树专题" class="headerlink" title="树专题"></a>树专题</h1><p>‍</p>
<!-- From: 图论\树专题\基环树（pseudotree）.md -->


<h1 id="基环树（pseudotree）"><a href="#基环树（pseudotree）" class="headerlink" title="基环树（pseudotree）"></a>基环树（pseudotree）</h1><h1 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h1><ol>
<li>如果一张无向连通图包含恰好一个环，则称它是一棵<strong>基环树</strong>。</li>
<li>如果一张有向弱连通图每个点的入度都为 1，则称它是一棵<strong>基环外向树</strong>。环内点指向环外树。</li>
<li>如果一张有向弱连通图每个点的出度都为 1，则称它是一棵<strong>基环内向树</strong>。环外树指向环内点。</li>
</ol>
<h1 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h1><ol>
<li>n 个点，n 条边。</li>
<li>每个点<strong>有且仅有一个</strong>对应关系（恰好一个出边或者入边）。</li>
</ol>
<p>‍</p>
<!-- From: 图论\树专题\树上启发式合并（dsu on tree）.md -->


<h1 id="树上启发式合并（dsu-on-tree）"><a href="#树上启发式合并（dsu-on-tree）" class="headerlink" title="树上启发式合并（dsu on tree）"></a>树上启发式合并（dsu on tree）</h1><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>在 dfs 的过程中，当前节点<strong>直接继承重儿子的信息，然后暴力合并轻儿子的信息</strong>。对于每个点，如果它开始属于某个点的轻儿子的子树中，那么合并这个集合，集合大小至少扩大一倍，这样每个节点<strong>最多</strong>被遍历 $\log n$ 遍，这样，算法的时间复杂度为 $O(n\log n)$。</p>
<h1 id="过程-3"><a href="#过程-3" class="headerlink" title="过程"></a>过程</h1><ol>
<li><p><code>dfs0</code>：求 $siz$，$son$。</p>
</li>
<li><p><code>dfs1(int u, int f, int keep)</code>：求 $dfn$。</p>
</li>
<li><p>先遍历轻儿子，<code>keep=false</code>，表示节点信息不保留，以免干扰其轻儿子子树的信息计算。</p>
</li>
<li><p>之后遍历重儿子，<code>keep=true</code>，表示重儿子子树信息保留。</p>
</li>
<li><p>将当前节点信息合并。</p>
</li>
<li><p>再遍历一遍所有轻儿子，使用<code>dfn</code>序，因为之前已经全部遍历过一遍。</p>
</li>
<li><p>得出当前节点的答案。</p>
</li>
<li><p>如果<code>keep=false</code>，则清除该子树的所有节点贡献的信息。（由于<code>keep=false</code>意味着这是个轻儿子子树，那么当刚开始遍历它时，记录的信息一定全为空，则把对应节点的信息直接清空就行）。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">col</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; col[i];</span><br><span class="line">    &#125;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        u--;</span><br><span class="line">        v--;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">son</span><span class="params">(n, <span class="number">-1</span>)</span>, <span class="title">siz</span><span class="params">(n, <span class="number">1</span>)</span>, <span class="title">dfn</span><span class="params">(n)</span>, <span class="title">rnk</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">int</span> _tim = <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(N)</span>, <span class="title">maxcnt</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;i64&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> dfs0 = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span> &amp;&amp; dfs0, <span class="type">int</span> u, <span class="type">int</span> f) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">        rnk[_tim] = u;</span><br><span class="line">        dfn[u] = _tim++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : g[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v != f) &#123;</span><br><span class="line">                <span class="built_in">dfs0</span>(v, u);</span><br><span class="line">                siz[u] += siz[v];</span><br><span class="line">                <span class="keyword">if</span> (son[u] == <span class="number">-1</span> || siz[son[u]] &lt; siz[v]) &#123;</span><br><span class="line">                    son[u] = v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> dfs1 = [&amp;](<span class="keyword">this</span> <span class="keyword">auto</span> &amp;&amp; dfs1, <span class="type">int</span> u, <span class="type">int</span> f, <span class="type">bool</span> keep) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : g[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == son[u] || v == f) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs1</span>(v, u, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (~son[u]) &#123;</span><br><span class="line">            <span class="built_in">dfs1</span>(son[u], u, <span class="literal">true</span>);</span><br><span class="line">            maxcnt[u] = maxcnt[son[u]];</span><br><span class="line">            ans[u] = ans[son[u]];</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[col[u]]++;</span><br><span class="line">        <span class="keyword">if</span> (cnt[col[u]] &gt; maxcnt[u]) &#123;</span><br><span class="line">            maxcnt[u] = cnt[col[u]];</span><br><span class="line">            ans[u] = col[u];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnt[col[u]] == maxcnt[u]) &#123;</span><br><span class="line">            ans[u] += col[u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : g[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == son[u] || v == f) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = dfn[v]; i &lt; dfn[v] + siz[v]; i++) &#123;</span><br><span class="line">                cnt[col[rnk[i]]]++;</span><br><span class="line">                <span class="keyword">if</span> (cnt[col[rnk[i]]] &gt; maxcnt[u]) &#123;</span><br><span class="line">                    maxcnt[u] = cnt[col[rnk[i]]];</span><br><span class="line">                    ans[u] = col[rnk[i]];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnt[col[rnk[i]]] == maxcnt[u]) &#123;</span><br><span class="line">                    ans[u] += col[rnk[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = dfn[u]; i &lt; dfn[u] + siz[u]; i++) &#123;</span><br><span class="line">                maxcnt[rnk[i]] = <span class="number">0</span>;</span><br><span class="line">                cnt[col[rnk[i]]] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">dfs0</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">0</span>, <span class="number">-1</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="例题-8"><a href="#例题-8" class="headerlink" title="例题"></a>例题</h1><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/U41492">U41492 树上数颜色 - 洛谷</a></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P9233">P9233 蓝桥杯 2023 省 A 颜色平衡树 - 洛谷</a></p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/600/E">Problem - 600E - Codeforces</a></p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/246/E">Problem - 246E - Codeforces</a></p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/208/E">Problem - 208E - Codeforces</a></p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/741/D">Problem - 741D - Codeforces</a></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3302">P3302 SDOI2013 森林 - 洛谷</a></p>
<!-- From: 图论\树专题\树模板.md -->


<h1 id="树模板"><a href="#树模板" class="headerlink" title="树模板"></a>树模板</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; g, g2;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; dfn, son, top, rnk;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; f, dep, siz;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; nodeWeight, rankNodeWeight;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Tree</span>(<span class="type">int</span> _n) : <span class="built_in">n</span>(_n) &#123;</span><br><span class="line">    g.<span class="built_in">resize</span>(n);</span><br><span class="line">    g<span class="number">2.</span><span class="built_in">resize</span>(n);</span><br><span class="line">    dep.<span class="built_in">resize</span>(n, INF);</span><br><span class="line">    siz.<span class="built_in">resize</span>(n, <span class="number">1</span>);</span><br><span class="line">    f.<span class="built_in">resize</span>(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123; g[u].<span class="built_in">push_back</span>(v); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">NodeWeight</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;_a)</span> </span>&#123;</span><br><span class="line">    nodeWeight = _a;</span><br><span class="line">    rankNodeWeight.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      rankNodeWeight[i] = nodeWeight[rnk[i]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">HLD</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> _time = <span class="number">0</span>;</span><br><span class="line">    dfn.<span class="built_in">resize</span>(n);</span><br><span class="line">    son.<span class="built_in">resize</span>(n, <span class="number">-1</span>);</span><br><span class="line">    top.<span class="built_in">resize</span>(n);</span><br><span class="line">    rnk.<span class="built_in">resize</span>(n);</span><br><span class="line">    dep[root] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> dfs0 = [&amp;](<span class="keyword">auto</span> &amp;&amp;dfs0, <span class="type">int</span> u) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> v : g[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[v] &gt; dep[u] + <span class="number">1</span>) &#123;</span><br><span class="line">          dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">          f[v] = u;</span><br><span class="line">          <span class="built_in">dfs0</span>(dfs0, v);</span><br><span class="line">          siz[u] += siz[v];</span><br><span class="line">          <span class="keyword">if</span> (son[u] == <span class="number">-1</span> || siz[son[u]] &lt; siz[v]) &#123;</span><br><span class="line">            son[u] = v;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> dfs1 = [&amp;](<span class="keyword">auto</span> &amp;&amp;dfs1, <span class="type">int</span> u, <span class="type">int</span> topn) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">      rnk[_time] = u;</span><br><span class="line">      dfn[u] = _time++;</span><br><span class="line">      top[u] = topn;</span><br><span class="line">      <span class="keyword">if</span> (son[u] == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="built_in">dfs1</span>(dfs1, son[u], topn);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> v : g[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == f[u] || v == son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(dfs1, v, v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">dfs0</span>(dfs0, root);</span><br><span class="line">    <span class="built_in">dfs1</span>(dfs1, root, root);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[u] != top[v]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dep[top[u]] &gt; dep[top[v]]) &#123;</span><br><span class="line">        u = f[top[u]];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        v = f[top[v]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[u] &lt; dep[v] ? u : v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SegmentTree, <span class="keyword">typename</span> Info&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">const</span> Info &amp;info, <span class="type">const</span> SegmentTree &amp;seg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[u] != top[v]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dep[top[u]] &gt; dep[top[v]]) &#123;</span><br><span class="line">        seg.<span class="built_in">modify</span>(dfn[top[u]], dfn[u] + <span class="number">1</span>, info);</span><br><span class="line">        u = f[top[u]];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        seg.<span class="built_in">modify</span>(dfn[top[v]], dfn[v] + <span class="number">1</span>, info);</span><br><span class="line">        v = f[top[v]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    seg.<span class="built_in">modify</span>(std::<span class="built_in">min</span>(dfn[u], dfn[v]), std::<span class="built_in">max</span>(dfn[u], dfn[v]) + <span class="number">1</span>, info);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> SegmentTree, <span class="keyword">typename</span> Info&gt;</span><br><span class="line">  <span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">const</span> SegmentTree &amp;seg)</span> </span>&#123;</span><br><span class="line">    Info ans;</span><br><span class="line">    <span class="keyword">while</span> (top[u] != top[v]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dep[top[u]] &gt; dep[top[v]]) &#123;</span><br><span class="line">        ans = ans + seg.<span class="built_in">rangeQuery</span>(dfn[top[u]], dfn[u] + <span class="number">1</span>);</span><br><span class="line">        u = f[top[u]];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ans = ans + seg.<span class="built_in">rangeQuery</span>(dfn[top[v]], dfn[v] + <span class="number">1</span>);</span><br><span class="line">        v = f[top[v]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = ans + seg.<span class="built_in">rangeQuery</span>(std::<span class="built_in">min</span>(dfn[u], dfn[v]),</span><br><span class="line">                               std::<span class="built_in">max</span>(dfn[u], dfn[v]) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">Diameter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">vis</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(n, <span class="number">-1</span>)</span>, path</span>;</span><br><span class="line">    <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> &amp;&amp;dfs, <span class="type">int</span> u, <span class="type">int</span> f) -&gt; std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &#123;</span><br><span class="line">      pii cur = &#123;<span class="number">1</span>, u&#125;;</span><br><span class="line">      pre[u] = f;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> v : g[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">auto</span> tmp = <span class="built_in">dfs</span>(dfs, v, u);</span><br><span class="line">        tmp.fi++;</span><br><span class="line">        cur = std::<span class="built_in">max</span>(cur, tmp);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> [d1, s] = <span class="built_in">dfs</span>(dfs, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">auto</span> [d2, t] = <span class="built_in">dfs</span>(dfs, s, <span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> x = t;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      path.<span class="built_in">push_back</span>(x);</span><br><span class="line">      x = pre[x];</span><br><span class="line">    &#125; <span class="keyword">while</span> (x != s);</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">VirtualTree</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;_a)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = _a.<span class="built_in">size</span>();</span><br><span class="line">    std::<span class="built_in">sort</span>(_a.<span class="built_in">begin</span>(), _a.<span class="built_in">end</span>(),</span><br><span class="line">              [&amp;](<span class="type">int</span> i, <span class="type">int</span> j) -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> dfn[i] &lt; dfn[j]; &#125;);</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">stk</span><span class="params">(<span class="number">2</span> * k)</span></span>;</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    stk[top] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (_a[<span class="number">0</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">      stk[++top] = _a[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">      <span class="type">int</span> l = <span class="built_in">lca</span>(_a[i], stk[top]);</span><br><span class="line">      <span class="keyword">while</span> (top &gt; <span class="number">0</span> &amp;&amp; dep[l] &lt;= dep[stk[top - <span class="number">1</span>]]) &#123;</span><br><span class="line">        g2[stk[top - <span class="number">1</span>]].<span class="built_in">push_back</span>(stk[top]);</span><br><span class="line">        top--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (l != stk[top]) &#123;</span><br><span class="line">        g2[l].<span class="built_in">push_back</span>(stk[top]);</span><br><span class="line">        top--;</span><br><span class="line">        stk[++top] = l;</span><br><span class="line">      &#125;</span><br><span class="line">      stk[++top] = _a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (top &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      g2[stk[top - <span class="number">1</span>]].<span class="built_in">push_back</span>(stk[top]);</span><br><span class="line">      top--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>‍</p>
<!-- From: 图论\树专题\树链剖分.md -->


<h1 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h1><h1 id="重链剖分"><a href="#重链剖分" class="headerlink" title="重链剖分"></a>重链剖分</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>对于一个点，如果它属于某条重链，那么在转移时</p>
<!-- From: 图论\树专题\虚树.md -->


<h1 id="虚树"><a href="#虚树" class="headerlink" title="虚树"></a>虚树</h1><h1 id="模板-3"><a href="#模板-3" class="headerlink" title="模板"></a>模板</h1><p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/613/problem/D/">Problem - D - Codeforces</a></p>
<p>虚树适用于：树问题，多组询问，每组询问的点数之和有限</p>
<p>若一个询问涉及一组关键点：$[a_1,a_2,a_3,…,a_k]$，对于该棵树，建立一棵虚树，只保留这 $k$ 棵节点和两两节点间的最近公共祖先，然后结合树型 dp</p>
<h1 id="建树方式"><a href="#建树方式" class="headerlink" title="建树方式"></a>建树方式</h1><p>一般可以人为添加原树的根节点，以便问题求解</p>
<ol>
<li><p>二次排序 + LCA 连边 $O(k\log n)$</p>
<ul>
<li>对整棵树跑一遍 dfn 序</li>
<li>将 ${a}$ 按照 dfn 序从小到大排序，添加相邻两个点之间的 LCA，排序去重，设最终 ${a}$ 大小为 $k’ $</li>
<li>对 $1\le i &lt; k’$，新建树，连接 $LCA(a_i,a_{i+1})\rightarrow a_{i+1}$，共计 $k’-1$ 条边</li>
</ul>
</li>
<li><p>单调栈</p>
</li>
</ol>
<p>‍</p>
<!-- From: 图论\网络流\README.md -->


<h1 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h1><p>‍</p>
<!-- From: 图论\网络流\最大流_.md -->


<h1 id="最大流"><a href="#最大流" class="headerlink" title="最大流_"></a>最大流_</h1><p>令 $G&#x3D;(V,E)$ 是一个有源汇点的网络，我们希望在 $G$ 上指定合适的流 $f$，以最大化整个网络的流量 $|f|$（即 $\sum_{x \in V} f(s, x) - \sum_{x \in V} f(x, s)$），这一问题被称作最大流问题（Maximum flow problem）。</p>
<h1 id="Ford-Fulkerson-方法"><a href="#Ford-Fulkerson-方法" class="headerlink" title="Ford-Fulkerson 方法"></a>Ford-Fulkerson 方法</h1><p>Ford-Fulkerson 方法包括了几种时间复杂度不同的算法实现，依赖于三种重要思想</p>
<p>Ford-Fulkerson 方法循环增加流的值，在最开始，对 $\forall u, v \in E,f(u,v)&#x3D;0$，每次迭代，从原流网络的残存网络中寻找一条<strong>增广路径</strong>，之后根据增广路径对原网络流进行修改，从而增加流的值，直至原网络流不再存在增广路径为止。</p>
<p>如何更新原网络流：对于点 $u,v$，在 $G_f$ 中与 $f$ 同向的边，$c(u,v)\leftarrow c(u,v)+c’(u,v)$，反向的边 $c(u,v)\leftarrow c(u,v)-c’(u,v)$</p>
<p>增广路径就是残存网络从 $s \rightsquigarrow t$ 的一条由容量大于0的边组成的简单路径，**当不存在增广路时，流 <strong>​</strong>$f$<strong>​ ** 到达最大流</strong></p>
<h1 id="EK-算法-O-V-E-2"><a href="#EK-算法-O-V-E-2" class="headerlink" title="EK 算法 $O(|V||E|^2)$"></a>EK 算法 $O(|V||E|^2)$</h1><p>每次寻找增广路，并在残存网络中做修改即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">EK</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m, s, t;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; prev;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; head, next, to, cap;</span><br><span class="line">    <span class="type">int</span> _cnt;</span><br><span class="line">    <span class="built_in">EK</span>() : <span class="built_in">n</span>(<span class="number">0</span>), <span class="built_in">m</span>(<span class="number">0</span>), <span class="built_in">s</span>(<span class="number">0</span>), <span class="built_in">t</span>(<span class="number">0</span>), _cnt(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">EK</span>(<span class="type">int</span> n, <span class="type">int</span> m) : <span class="built_in">n</span>(n), <span class="built_in">m</span>(m), _cnt(<span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="number">0</span>;</span><br><span class="line">        t = n - <span class="number">1</span>;</span><br><span class="line">        _init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">EK</span>(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> s, <span class="type">int</span> t) : <span class="built_in">n</span>(n), <span class="built_in">m</span>(m), <span class="built_in">s</span>(s), <span class="built_in">t</span>(t), _cnt(<span class="number">0</span>) &#123;</span><br><span class="line">        _init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> _init() &#123;</span><br><span class="line">        prev.<span class="built_in">resize</span>(n);</span><br><span class="line">        head.<span class="built_in">resize</span>(n, <span class="number">-1</span>);</span><br><span class="line">        next.<span class="built_in">resize</span>(m * <span class="number">2</span>);</span><br><span class="line">        to.<span class="built_in">resize</span>(m * <span class="number">2</span>);</span><br><span class="line">        cap.<span class="built_in">resize</span>(m * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(_cnt &lt; m * <span class="number">2</span>);</span><br><span class="line">        next[_cnt] = head[u];</span><br><span class="line">        to[_cnt] = v;</span><br><span class="line">        cap[_cnt] = w;</span><br><span class="line">        head[u] = _cnt++;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert</span>(_cnt &lt; m * <span class="number">2</span>);</span><br><span class="line">        next[_cnt] = head[v];</span><br><span class="line">        to[_cnt] = u;</span><br><span class="line">        cap[_cnt] = <span class="number">0</span>;</span><br><span class="line">        head[v] = _cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::queue&lt;PII&gt; q;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">vis</span><span class="params">(n)</span></span>;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;s, INF&#125;);</span><br><span class="line">        vis[s] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [u, min] = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (u == t) <span class="keyword">return</span> min;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> ne = head[u]; ~ne; ne = next[ne]) &#123;</span><br><span class="line">                <span class="type">int</span> v = to[ne];</span><br><span class="line">                <span class="keyword">if</span> (!vis[v] &amp;&amp; cap[ne]) &#123;</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                    prev[v] = ne;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;v, std::<span class="built_in">min</span>(min, cap[ne])&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(i64 flow)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> u = t;</span><br><span class="line">        <span class="keyword">while</span> (u != s) &#123;</span><br><span class="line">            <span class="type">int</span> e = prev[u];</span><br><span class="line">            cap[e] -= flow;</span><br><span class="line">            cap[e ^ <span class="number">1</span>] += flow;</span><br><span class="line">            u = to[e ^ <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">i64 <span class="title">maxFlow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i64 maxflow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = <span class="built_in">bfs</span>();</span><br><span class="line">            <span class="keyword">if</span> (tmp) &#123;</span><br><span class="line">                maxflow += tmp;</span><br><span class="line">                <span class="built_in">modify</span>(tmp);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxflow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Dinic-算法-O-V-2-E"><a href="#Dinic-算法-O-V-2-E" class="headerlink" title="Dinic 算法 $O(|V|^2|E|)$"></a>Dinic 算法 $O(|V|^2|E|)$</h1><p>借助分层图最短路思想，每次尽可能多地增广</p>
<p>bfs 分层：建立分层图并检查有无增广路，用 u 点到 s 的最短01距离来区分点 u 所在的层数，共 $|V|$ 层</p>
<p>dfs 暴搜：找出所有能在当前分层图上能够增广的路径</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Dinic</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m, s, t;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; dep, cur;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; head, next, to, cap;</span><br><span class="line">    <span class="type">int</span> _cnt;</span><br><span class="line">    <span class="built_in">Dinic</span>() : <span class="built_in">n</span>(<span class="number">0</span>), <span class="built_in">m</span>(<span class="number">0</span>), <span class="built_in">s</span>(<span class="number">0</span>), <span class="built_in">t</span>(<span class="number">0</span>), _cnt(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Dinic</span>(<span class="type">int</span> n, <span class="type">int</span> m) : <span class="built_in">n</span>(n), <span class="built_in">m</span>(m), _cnt(<span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="number">0</span>;</span><br><span class="line">        t = n - <span class="number">1</span>;</span><br><span class="line">        _init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Dinic</span>(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> s, <span class="type">int</span> t) : <span class="built_in">n</span>(n), <span class="built_in">m</span>(m), <span class="built_in">s</span>(s), <span class="built_in">t</span>(t), _cnt(<span class="number">0</span>) &#123;</span><br><span class="line">        _init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> _init() &#123;</span><br><span class="line">        dep.<span class="built_in">resize</span>(n, <span class="number">-1</span>);</span><br><span class="line">        head.<span class="built_in">resize</span>(n, <span class="number">-1</span>);</span><br><span class="line">        cur.<span class="built_in">resize</span>(n, <span class="number">-1</span>);</span><br><span class="line">        next.<span class="built_in">resize</span>(m * <span class="number">2</span>);</span><br><span class="line">        to.<span class="built_in">resize</span>(m * <span class="number">2</span>);</span><br><span class="line">        cap.<span class="built_in">resize</span>(m * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(_cnt &lt; m * <span class="number">2</span>);</span><br><span class="line">        next[_cnt] = head[u];</span><br><span class="line">        to[_cnt] = v;</span><br><span class="line">        cap[_cnt] = w;</span><br><span class="line">        head[u] = _cnt++;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert</span>(_cnt &lt; m * <span class="number">2</span>);</span><br><span class="line">        next[_cnt] = head[v];</span><br><span class="line">        to[_cnt] = u;</span><br><span class="line">        cap[_cnt] = <span class="number">0</span>;</span><br><span class="line">        head[v] = _cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">fill</span>(dep.<span class="built_in">begin</span>(), dep.<span class="built_in">end</span>(), <span class="number">-1</span>);</span><br><span class="line">        std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(s);</span><br><span class="line">        dep[s] = <span class="number">0</span>;</span><br><span class="line">        cur[s] = head[s];</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> ne = head[u]; ~ne; ne = next[ne]) &#123;</span><br><span class="line">                <span class="type">int</span> v = to[ne];</span><br><span class="line">                <span class="keyword">if</span> (dep[v] == <span class="number">-1</span> &amp;&amp; cap[ne] != <span class="number">0</span>) &#123;</span><br><span class="line">                    dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">                    cur[v] = head[v];</span><br><span class="line">                    <span class="keyword">if</span> (v == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> flow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == t || flow == <span class="number">0</span>) <span class="keyword">return</span> flow;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> &amp;ne = cur[u]; ~ne; ne = next[ne]) &#123;</span><br><span class="line">            <span class="type">int</span> v = to[ne], nxt;</span><br><span class="line">            <span class="keyword">if</span> ((dep[v] == dep[u] + <span class="number">1</span>)</span><br><span class="line">                &amp;&amp; (nxt = <span class="built_in">find</span>(v, std::<span class="built_in">min</span>(flow - ret, cap[ne])))) &#123;</span><br><span class="line">                ret += nxt;</span><br><span class="line">                cap[ne] -= nxt;</span><br><span class="line">                cap[ne ^ <span class="number">1</span>] += nxt;</span><br><span class="line">                <span class="keyword">if</span> (ret == flow) <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">i64 <span class="title">maxFlow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i64 maxflow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">bfs</span>()) &#123;</span><br><span class="line">            maxflow += <span class="built_in">find</span>(s, INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxflow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="ISAP算法（优化的Dinic）"><a href="#ISAP算法（优化的Dinic）" class="headerlink" title="ISAP算法（优化的Dinic）"></a>ISAP算法（优化的Dinic）</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ISAP</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m, s, t;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; dep, cur, num, prev, from;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; head, next, to, cap, f;</span><br><span class="line">    <span class="type">int</span> _cnt;</span><br><span class="line">    <span class="built_in">ISAP</span>() : <span class="built_in">n</span>(<span class="number">0</span>), <span class="built_in">m</span>(<span class="number">0</span>), <span class="built_in">s</span>(<span class="number">0</span>), <span class="built_in">t</span>(<span class="number">0</span>), _cnt(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ISAP</span>(<span class="type">int</span> n, <span class="type">int</span> m) : <span class="built_in">n</span>(n), <span class="built_in">m</span>(m), _cnt(<span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="number">0</span>;</span><br><span class="line">        t = n - <span class="number">1</span>;</span><br><span class="line">        _init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ISAP</span>(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> s, <span class="type">int</span> t) : <span class="built_in">n</span>(n), <span class="built_in">m</span>(m), <span class="built_in">s</span>(s), <span class="built_in">t</span>(t), _cnt(<span class="number">0</span>) &#123;</span><br><span class="line">        _init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> _init() &#123;</span><br><span class="line">        dep.<span class="built_in">resize</span>(n, <span class="number">0</span>);</span><br><span class="line">        cur.<span class="built_in">resize</span>(n);</span><br><span class="line">        num.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        prev.<span class="built_in">resize</span>(n);</span><br><span class="line">        head.<span class="built_in">resize</span>(n, <span class="number">-1</span>);</span><br><span class="line">        next.<span class="built_in">resize</span>(m * <span class="number">2</span>);</span><br><span class="line">        to.<span class="built_in">resize</span>(m * <span class="number">2</span>);</span><br><span class="line">        cap.<span class="built_in">resize</span>(m * <span class="number">2</span>);</span><br><span class="line">        f.<span class="built_in">resize</span>(m * <span class="number">2</span>);</span><br><span class="line">        from.<span class="built_in">resize</span>(m * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">        next[_cnt] = head[u];</span><br><span class="line">        to[_cnt] = v;</span><br><span class="line">        cap[_cnt] = w;</span><br><span class="line">        from[_cnt] = u;</span><br><span class="line">        head[u] = _cnt++;</span><br><span class="line"></span><br><span class="line">        next[_cnt] = head[v];</span><br><span class="line">        to[_cnt] = u;</span><br><span class="line">        from[_cnt] = v;</span><br><span class="line">        head[v] = _cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">vis</span><span class="params">(n)</span></span>;</span><br><span class="line">        std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(t);</span><br><span class="line">        vis[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> ne = head[u]; ~ne; ne = next[ne]) &#123;</span><br><span class="line">                <span class="type">int</span> rne = ne ^ <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (!vis[from[rne]] &amp;&amp; cap[rne] &gt; f[rne]) &#123;</span><br><span class="line">                    vis[from[rne]] = <span class="literal">true</span>;</span><br><span class="line">                    dep[from[rne]] = dep[u] + <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(from[rne]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vis[s];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = t, flow = INF;</span><br><span class="line">        <span class="keyword">while</span> (x != s) &#123;</span><br><span class="line">            <span class="type">int</span> ne = prev[x];</span><br><span class="line">            flow = std::<span class="built_in">min</span>(flow, cap[ne] - f[ne]);</span><br><span class="line">            x = from[ne];</span><br><span class="line">        &#125;</span><br><span class="line">        x = t;</span><br><span class="line">        <span class="keyword">while</span> (x != s) &#123;</span><br><span class="line">            f[prev[x]] += flow;</span><br><span class="line">            f[prev[x] ^ <span class="number">1</span>] -= flow;</span><br><span class="line">            x = from[prev[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">i64 <span class="title">maxFlow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i64 maxflow = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">bfs</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            num[dep[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x = s;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (dep[s] &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == t) &#123;</span><br><span class="line">                maxflow += <span class="built_in">find</span>();</span><br><span class="line">                x = s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> ne = cur[x]; ~ne; ne = next[ne]) &#123;</span><br><span class="line">                <span class="type">int</span> v = to[ne];</span><br><span class="line">                <span class="keyword">if</span> (cap[ne] &gt; f[ne] &amp;&amp; dep[x] == dep[v] + <span class="number">1</span>) &#123;</span><br><span class="line">                    ok = <span class="literal">true</span>;</span><br><span class="line">                    prev[v] = ne;</span><br><span class="line">                    cur[x] = ne;</span><br><span class="line">                    x = v;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">                <span class="type">int</span> m = n - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> ne = head[x]; ~ne; ne = next[ne]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cap[ne] &gt; f[ne]) &#123;</span><br><span class="line">                        m = std::<span class="built_in">min</span>(m, dep[to[ne]]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (--num[dep[x]] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                num[dep[x] = m + <span class="number">1</span>]++;</span><br><span class="line">                cur[x] = head[x];</span><br><span class="line">                <span class="keyword">if</span> (x != s) &#123;</span><br><span class="line">                    x = from[prev[x]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxflow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">i64 <span class="title">maxFlow</span><span class="params">(<span class="type">int</span> S, <span class="type">int</span> T)</span> </span>&#123;</span><br><span class="line">        s = S;</span><br><span class="line">        t = T;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">maxFlow</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<!-- From: 图论\网络流\网络流基本概念_.md -->


<h1 id="网络流基本概念"><a href="#网络流基本概念" class="headerlink" title="网络流基本概念_"></a>网络流基本概念_</h1><p>解决有关物料流动方面的问题。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ol>
<li><p><strong>流网络</strong>：一个<strong>网络</strong> $G &#x3D; (V,E)$ 是一个有向图，图中的每一条有向边 $(u,v)\in E$ 都有一个给定的权值 $c(u,v)\ge0$，称为边的<strong>容量</strong>。如果一条边 $(u,v)\in E$，则图中不存在反向边 $(v,u)\in E$。特别的，若 $(u,v)\notin E$，则 $c(u,v)&#x3D;0$。途中还有一个（或多个）<strong>源点</strong> ${S}$，和一个或多个<strong>汇点</strong> ${T}$。</p>
</li>
<li><p>（可行）<strong>流函数</strong> $f:V\times V\rightarrow \R$：</p>
<ul>
<li>流量限制：$\forall u,v\in V,0\le f(u,v)\le c(u,v)$</li>
<li>流量守恒：$\forall u\in V-{s,t},\sum_{v\in V}f(v,u)&#x3D;\sum_{v\in V}f(u,v)$</li>
<li>整个网络的流：$|f|&#x3D;\sum_{v\in V}f(s,v)-\sum_{v\in V}f(v,s)$</li>
<li>最大（可行）流：$|f|_{max}$</li>
</ul>
</li>
<li><p><strong>反平行边</strong>：一对有向边和它的反向边称为一对反平行边。$(v_1,v_2)\in E \land (v_2,v_1)\in E$</p>
</li>
<li><p><strong>残存网络</strong>：给定流网络$G$ 和流量 $f$，定义残存网络 $G_f$ ，有</p>
<p> $$<br> c_f(u,v) &#x3D;<br> \begin{cases}<br> c(u,v)-f(u,v)  &amp; \text{if }(u,v)\in E \<br> f(v,u) &amp; \text{if }(v,u)\in E \<br> 0 &amp; \text{other}<br> \end{cases}<br> $$</p>
<p> 有 $|f\uparrow f’|&#x3D;|f|+|f’|$，原网络的可行流加上残存网络的可行流构成一个新的可行流，当残存网络没有可行流时，原网络形成最大流。</p>
</li>
<li><p><strong>切割</strong>：将 $V$ 分为两部分 $S,T$，满足 $s\in S \land t \in T \land S\cup T&#x3D;V \land S\cap T&#x3D;\emptyset$，则称 $(S,T)$ 为一个切割。</p>
<ul>
<li>切割的<strong>净流量</strong>：$f(S,T)&#x3D;\sum_{u\in S}\sum_{v\in T}f(u,v)-\sum_{u\in S}\sum_{v\in T}f(v,u)$</li>
<li>切割的<strong>容量</strong>：$c(S,T)&#x3D;\sum_{u\in S}\sum_{v\in T}c(u,v)$</li>
<li>$c(S,T)\ge f(S,T)$</li>
<li>$f(Z,X\cup Y)&#x3D;f(Z,X)+f(Z,Y),X\cap Y&#x3D;\emptyset$</li>
<li><strong>最小割</strong>指的是所有割的最小容量</li>
<li>切割的数量 $2^{|V|-1}$</li>
</ul>
</li>
<li><p><strong>最大流最小割定理</strong>：$|f|\le c(S,T),min(f(S,T))&#x3D;|f|_{max}$，$流f是最大流 \iff G_f中不存在增广路 \iff \exist [S,T],|f|&#x3D;c(S,T)$</p>
</li>
</ol>
<!-- From: 数据结构\README.md -->


<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>‍</p>
<!-- From: 数据结构\可持久化数据结构\README.md -->


<h1 id="可持久化数据结构"><a href="#可持久化数据结构" class="headerlink" title="可持久化数据结构"></a>可持久化数据结构</h1><p>‍</p>
<!-- From: 数据结构\可持久化数据结构\可持久化Trie.md -->


<h1 id="可持久化Trie"><a href="#可持久化Trie" class="headerlink" title="可持久化Trie"></a>可持久化Trie</h1><p>‍</p>
<!-- From: 数据结构\可持久化数据结构\可持久化并查集和可撤销并查集.md -->


<h1 id="可持久化并查集和可撤销并查集"><a href="#可持久化并查集和可撤销并查集" class="headerlink" title="可持久化并查集和可撤销并查集"></a>可持久化并查集和可撤销并查集</h1><h1 id="可持久化并查集-1"><a href="#可持久化并查集-1" class="headerlink" title="可持久化并查集"></a>可持久化并查集</h1><p>可以查询任意版本的并查集，本质就是可持久化数组，将 $f$ 数组与 $siz$ 可持久化</p>
<p>为了减少每次合并操作的修改元素数量，只做按秩合并，不做路径压缩。假设要合并 $a$ 所在元素集合和 $b$ 所在元素集合，集合代表节点和集合大小分别为 $f_a,siz_a,f_b,siz_b(siz_a&gt;siz_b)$，这样每次合并的操作就只有</p>
<ol>
<li>$f[f_b]&#x3D;f_a  $</li>
<li>$siz[f_a]&#x3D;siz_a+siz_b$</li>
</ol>
<p>只需进行两次操作，大大减小了操作量，并且由于启发式合并，每次查询操作也只会跳转 $O(\log n)$ 次。</p>
<h1 id="可撤销并查集-1"><a href="#可撤销并查集-1" class="headerlink" title="可撤销并查集"></a>可撤销并查集</h1><p>可以按照<code>FIFO</code>回滚所做操作，用一个栈来存储当前版本修改了哪些信息，以便回退到它上一个版本。</p>
<p>由于只维护了两个集合代表节点在合并时的相关信息，同样不能做路径压缩</p>
<p>模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span> &#123;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; f, siz;</span><br><span class="line">  std::stack&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; his;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DSU</span>() &#123;&#125;</span><br><span class="line">  <span class="built_in">DSU</span>(<span class="type">int</span> n) &#123; <span class="built_in">init</span>(n); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    f.<span class="built_in">resize</span>(n);</span><br><span class="line">    std::<span class="built_in">iota</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    siz.<span class="built_in">assign</span>(n, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != f[x]) &#123;</span><br><span class="line">      x = f[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = <span class="built_in">find</span>(x);</span><br><span class="line">    y = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (siz[x] &lt; siz[y]) &#123;</span><br><span class="line">      std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    his.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    siz[x] += siz[y];</span><br><span class="line">    f[y] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">time</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> his.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">revert</span><span class="params">(<span class="type">int</span> tm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (his.<span class="built_in">size</span>() &gt; tm) &#123;</span><br><span class="line">      <span class="keyword">auto</span> [x, y] = his.<span class="built_in">top</span>();</span><br><span class="line">      his.<span class="built_in">pop</span>();</span><br><span class="line">      f[y] = y;</span><br><span class="line">      siz[x] -= siz[y];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">revert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [x, y] = his.<span class="built_in">top</span>();</span><br><span class="line">    his.<span class="built_in">pop</span>();</span><br><span class="line">    f[y] = y;</span><br><span class="line">    siz[x] -= siz[y];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> siz[<span class="built_in">find</span>(x)]; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="例题-9"><a href="#例题-9" class="headerlink" title="例题"></a>例题</h1><ol>
<li><p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc302/tasks/abc302_h">AT_abc302_h</a></p>
<p> 每个点有两个权值 $A,B$，经过一个点只能选择其中一个，问根节点 0 到其他节点，走最短路径所能取的权值最大种类数量是多少</p>
<p> 对于同一个点上的权值 $A_i,B_i$，用一条边连接，表示可以取这条边两个端点之一</p>
<p> 考虑一张连通图 $G(n,m) $：</p>
<ol>
<li>若 $m&#x3D; n-1$：则 $G$ 为一棵树，按照上述规则可以取到 $n-1$ 个不同权值</li>
<li>若 $m&#x3D;n$：可以发现经过调整，可以取到 $n$ 个不同权值</li>
<li>若 $m&gt;n$：能取到的权值种类数量已到达上限，仍为 $n$ 个</li>
</ol>
<p> 所以总结规律：假如当前路径加入点 $u$，其两个权值为 $A_u,B_u$，向 $A_u,B_u$ 之间连接一条边，并查集记录连通分量，存储每个连通分量中边的数量：</p>
<ol>
<li><p>如果 $A_u,B_u$ 不在同一连通分量：</p>
<ul>
<li>若 $A_u,B_u$ 所在连通分量中，存在边数 &lt; 点数的情况，则计数 +1</li>
<li>若 $A_u,B_u$ 所在连通分量中，不存在边数 &lt; 点数的情况，不会产生贡献</li>
</ul>
</li>
<li><p>如果 $A_u,B_u$ 在同一连通分量：</p>
<ul>
<li>若该连通分量，边数 &lt; 点数，则计数+1</li>
<li>否则，不会产生贡献</li>
</ul>
</li>
</ol>
<p> 利用 dfs 的递归特性，在计算完一个点后删除其影响（可撤销并查集），这样一次 dfs 就可以得到所有点的答案</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="function">std::vector&lt;pii&gt; <span class="title">ball</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> A, B;</span><br><span class="line">    cin &gt;&gt; A &gt;&gt; B;</span><br><span class="line">    A--;</span><br><span class="line">    B--;</span><br><span class="line">    ball[i] = &#123;A, B&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    u--;</span><br><span class="line">    v--;</span><br><span class="line">    g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="function">DSU <span class="title">dsu</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp;&amp; self, <span class="type">int</span> u, <span class="type">int</span> f) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> [A, B] = ball[u];</span><br><span class="line">    <span class="type">int</span> fA = dsu.<span class="built_in">find</span>(A), fB = dsu.<span class="built_in">find</span>(B);</span><br><span class="line">    <span class="type">bool</span> add = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (fA == fB) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dsu.siz[fA] &gt; dsu.ecnt[fA]) &#123;</span><br><span class="line">        add = <span class="literal">true</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">      &#125;</span><br><span class="line">      dsu.ecnt[fA]++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (dsu.siz[fA] &lt; dsu.siz[fB]) &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(fA, fB);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (dsu.siz[fA] &gt; dsu.ecnt[fA] || dsu.siz[fB] &gt; dsu.ecnt[fB]) &#123;</span><br><span class="line">        add = <span class="literal">true</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">      &#125;</span><br><span class="line">      dsu.ecnt[fA] += dsu.ecnt[fB] + <span class="number">1</span>;</span><br><span class="line">      dsu.siz[fA] += dsu.siz[fB];</span><br><span class="line">      dsu.f[fB] = fA;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[u] = cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : g[u]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (v == f) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="built_in">self</span>(self, v, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (add) &#123;</span><br><span class="line">      cnt--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fA != fB) &#123;</span><br><span class="line">      dsu.f[fB] = fB;</span><br><span class="line">      dsu.siz[fA] -= dsu.siz[fB];</span><br><span class="line">      dsu.ecnt[fA] -= dsu.ecnt[fB];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dsu.ecnt[fA]--;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">dfs</span>(dfs, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/891/C">CF891C</a></p>
<p> 给定 $G(n,m)$，每组询问给出若干条边，判断这若干条边是否都能够存在于 $G$ 的一个最小生成树中。</p>
<p> 考虑离线做法，将所有询问存储起来，用 $[u,v,w,id]$ 表示，以 $w$ 为第一关键字，$id$ 为第二关键字排序，这样就能按照 $w$ 和 $id$ 进行分组。</p>
<p> 考虑一个性质：对于一组权值相同的所有边，按照 $kruscal$ 算法流程，无论选择哪些边加入当前最小生成树中，都不会改变其最后生成的图的连通性（考虑反证）。这样在考虑一到 $[u,v,w,id]$ 时，$kruscal$ 算法考虑所有权值小于 $w$ 的边，再看这条边能否加入到最小生成树当中。由于上述性质存在，不必考虑权值比它小的边加入最小生成树时，不同的选择会导致不同的连通性，从而不会对当前选择产生影响。在权值相同，但不同组的 $[u,v,w,id]$ 中，用可撤销并查集去除上一组的影响。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;Edge&gt; e;</span><br><span class="line">  e.<span class="built_in">reserve</span>(m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">    e.<span class="built_in">emplace_back</span>(u - <span class="number">1</span>, v - <span class="number">1</span>, w);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> q;</span><br><span class="line">  cin &gt;&gt; q;</span><br><span class="line">  std::vector&lt;Q&gt; que;</span><br><span class="line">  que.<span class="built_in">reserve</span>(q);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; t; j++) &#123;</span><br><span class="line">      <span class="type">int</span> x;</span><br><span class="line">      cin &gt;&gt; x;</span><br><span class="line">      x--;</span><br><span class="line">      que.<span class="built_in">emplace_back</span>(e[x].u, e[x].v, e[x].w, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">sort</span>(que.<span class="built_in">begin</span>(), que.<span class="built_in">end</span>());</span><br><span class="line">  std::<span class="built_in">sort</span>(e.<span class="built_in">begin</span>(), e.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">ans</span><span class="params">(q, <span class="literal">true</span>)</span></span>;</span><br><span class="line">  <span class="function">DSU <span class="title">dsu</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, p = <span class="number">0</span>; l &lt; que.<span class="built_in">size</span>(); l = r + <span class="number">1</span>, r = l) &#123;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; m &amp;&amp; e[p].w &lt; que[l].w) &#123;</span><br><span class="line">      dsu.<span class="built_in">merge</span>(e[p].u, e[p].v);</span><br><span class="line">      p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (r &lt; que.<span class="built_in">size</span>() &amp;&amp; que[r].w == que[l].w &amp;&amp; que[r].id == que[l].id) &#123;</span><br><span class="line">      r++;</span><br><span class="line">    &#125;</span><br><span class="line">    r--;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = l; j &lt;= r; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!dsu.<span class="built_in">same</span>(que[j].u, que[j].v)) &#123;</span><br><span class="line">        dsu.<span class="built_in">merge</span>(que[j].u, que[j].v);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ans[que[j].id] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len = j - l;</span><br><span class="line">    <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">      dsu.<span class="built_in">revert</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">    cout &lt;&lt; (ans[i] ? <span class="string">&quot;YES\n&quot;</span> : <span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1444/C">CF1444C</a></p>
<p> $n$ 个点有 $m$ 个不相容关系，另外有若干组，将任意两组配对，问有多少种配对，可以将两个组中的所有点导出一个二分图（分成两部分，每部分里的所有点之间无不相容关系）。</p>
<p> 使用<strong>扩展域并查集</strong>来判断相容关系，如果同一组中点无法导出二分图，则事先排除这个组，反之需要加入配对。</p>
<p> 先用 $\binom{k}{2}$ 计算总的配对数量，再从不在同一组的不相容关系中排除不合法的配对数量，使用可撤销并查集撤销上一次不相容关系的影响。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">int</span> n, m, k;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">check</span><span class="params">(k, <span class="literal">true</span>)</span></span>;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">belong</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    cin &gt;&gt; id;</span><br><span class="line">    id--;</span><br><span class="line">    belong[i] = id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::array&lt;<span class="type">int</span>, 4&gt;&gt; e;</span><br><span class="line">  e.<span class="built_in">reserve</span>(m);</span><br><span class="line">  <span class="type">int</span> cnt = k;</span><br><span class="line"></span><br><span class="line">  <span class="function">DSU <span class="title">dsu</span><span class="params">(n * <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    u--;</span><br><span class="line">    v--;</span><br><span class="line">    <span class="keyword">if</span> (belong[u] == belong[v]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!check[belong[u]]) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (dsu.<span class="built_in">same</span>(u, v)) &#123;</span><br><span class="line">        check[belong[u]] = <span class="literal">false</span>;</span><br><span class="line">        cnt--;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dsu.<span class="built_in">merge</span>(u, v + n);</span><br><span class="line">        dsu.<span class="built_in">merge</span>(v, u + n);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (belong[u] &gt; belong[v]) &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">      &#125;</span><br><span class="line">      e.<span class="built_in">push_back</span>(&#123;belong[u], belong[v], u, v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  i64 ans = <span class="number">1LL</span> * (cnt - <span class="number">1</span>) * cnt / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (e.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">sort</span>(e.<span class="built_in">begin</span>(), e.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; l &lt; e.<span class="built_in">size</span>(); l = r + <span class="number">1</span>, r++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; e.<span class="built_in">size</span>() &amp;&amp; e[l][<span class="number">0</span>] == e[r][<span class="number">0</span>] &amp;&amp; e[l][<span class="number">1</span>] == e[r][<span class="number">1</span>]) &#123;</span><br><span class="line">      r++;</span><br><span class="line">    &#125;</span><br><span class="line">    r--;</span><br><span class="line">    <span class="keyword">if</span> (!check[e[l][<span class="number">0</span>]] || !check[e[l][<span class="number">1</span>]]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dsu.<span class="built_in">same</span>(e[i][<span class="number">2</span>], e[i][<span class="number">3</span>])) &#123;</span><br><span class="line">        ans--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t += dsu.<span class="built_in">merge</span>(e[i][<span class="number">2</span>], e[i][<span class="number">3</span>] + n);</span><br><span class="line">        t += dsu.<span class="built_in">merge</span>(e[i][<span class="number">2</span>] + n, e[i][<span class="number">3</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">      dsu.<span class="built_in">revert</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>‍</p>
<!-- From: 数据结构\可持久化数据结构\可持久化线段树.md -->


<h1 id="可持久化线段树"><a href="#可持久化线段树" class="headerlink" title="可持久化线段树"></a>可持久化线段树</h1><h1 id="单点修改，单点查询的可持久化线段树（可持久化数组）"><a href="#单点修改，单点查询的可持久化线段树（可持久化数组）" class="headerlink" title="单点修改，单点查询的可持久化线段树（可持久化数组）"></a>单点修改，单点查询的可持久化线段树（可持久化数组）</h1><ol>
<li>不需要懒更新</li>
<li>沿途节点新建，其他节点复用</li>
</ol>
<p>例题：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3919">P3919 【模板】可持久化线段树 1（可持久化数组） - 洛谷</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __LOCAL__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;F:/local.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __GNUG__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> PII = std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> u32 = <span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> u64 = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> i128 = __int128;</span><br><span class="line"><span class="keyword">using</span> u128 = <span class="type">unsigned</span> __int128;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> i64 LINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> esp = <span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Info&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line">    <span class="type">int</span> _cnt = <span class="number">0</span>, n;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; left, right, version;</span><br><span class="line">    std::vector&lt;Info&gt; info;</span><br><span class="line">    <span class="built_in">SegmentTree</span>(<span class="type">int</span> n, <span class="type">int</span> q) &#123;</span><br><span class="line">        <span class="built_in">init</span>(std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>), q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="built_in">SegmentTree</span>(std::vector&lt;U&gt; _init, <span class="type">int</span> q) &#123;</span><br><span class="line">        <span class="built_in">init</span>(_init, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(std::vector&lt;U&gt; _init, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">        n = _init.<span class="built_in">size</span>();</span><br><span class="line">        left.<span class="built_in">resize</span>((<span class="number">4</span> &lt;&lt; std::__lg(n)) + <span class="number">2</span> * q * std::__lg(n));</span><br><span class="line">        right.<span class="built_in">resize</span>((<span class="number">4</span> &lt;&lt; std::__lg(n)) + <span class="number">2</span> * q * std::__lg(n));</span><br><span class="line">        info.<span class="built_in">resize</span>((<span class="number">4</span> &lt;&lt; std::__lg(n)) + <span class="number">2</span> * q * std::__lg(n));</span><br><span class="line">        version.<span class="built_in">resize</span>(q + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">auto</span> build = [&amp;](<span class="keyword">auto</span> &amp;&amp; self, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="type">int</span> cur = _cnt++;</span><br><span class="line">            <span class="keyword">if</span> (l + <span class="number">1</span> == r) &#123;</span><br><span class="line">                info[cur] = _init[l];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">                left[cur] = <span class="built_in">self</span>(self, l, m);</span><br><span class="line">                right[cur] = <span class="built_in">self</span>(self, m, r);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;;</span><br><span class="line">        version[<span class="number">0</span>] = <span class="built_in">build</span>(build, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">copy</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cur = _cnt++;</span><br><span class="line">        info[cur] = info[i];</span><br><span class="line">        left[cur] = left[i];</span><br><span class="line">        right[cur] = right[i];</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> newVersion, <span class="type">int</span> modifyVersion, <span class="type">int</span> x, <span class="type">const</span> Info &amp;v)</span> </span>&#123;</span><br><span class="line">        version[newVersion] = <span class="built_in">modify</span>(version[modifyVersion], <span class="number">0</span>, n, x, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">const</span> Info &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cur = <span class="built_in">copy</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (l + <span class="number">1</span> == r) &#123;</span><br><span class="line">            info[cur] = v;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; m) &#123;</span><br><span class="line">                left[cur] = <span class="built_in">modify</span>(left[p], l, m, x, v);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right[cur] = <span class="built_in">modify</span>(right[p], m, r, x, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> newVersion, <span class="type">int</span> queryVersion, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        version[newVersion] = version[queryVersion];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeQuery</span>(version[queryVersion], <span class="number">0</span>, n, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l + <span class="number">1</span> == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> info[p];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (y &lt;= m) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">rangeQuery</span>(left[p], l, m, x, y);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(x &gt;= m) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">rangeQuery</span>(right[p], m, r, x, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">    <span class="type">int</span> g = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Info</span>(<span class="type">int</span> _g = <span class="number">0</span>) : <span class="built_in">g</span>(_g) &#123;&#125;</span><br><span class="line">    Info <span class="keyword">operator</span>+(<span class="type">const</span> Info &amp;other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;g + other.g&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;x : a) &#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ver = <span class="number">0</span>;</span><br><span class="line">    <span class="function">SegmentTree&lt;Info&gt; <span class="title">seg</span><span class="params">(a, q)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        <span class="type">int</span> v, t;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> p, c;</span><br><span class="line">            cin &gt;&gt; p &gt;&gt; c;</span><br><span class="line">            seg.<span class="built_in">modify</span>(++ver, v, p - <span class="number">1</span>, c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> p;</span><br><span class="line">            cin &gt;&gt; p;</span><br><span class="line">            cout &lt;&lt; seg.<span class="built_in">rangeQuery</span>(++ver, v, p - <span class="number">1</span>, p).g &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="单点修改，区间查询的可持久化线段树"><a href="#单点修改，区间查询的可持久化线段树" class="headerlink" title="单点修改，区间查询的可持久化线段树"></a>单点修改，区间查询的可持久化线段树</h1><p>与上面同理，但是要注意<code>push</code>操作节点一定要新建<code>copy</code></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3834">P3834 【模板】可持久化线段树 2 - 洛谷</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">&#125;<span class="meta">#<span class="keyword">ifdef</span> __LOCAL__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;F:/local.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __GNUG__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> PII = std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> u32 = <span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> u64 = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> i128 = __int128;</span><br><span class="line"><span class="keyword">using</span> u128 = <span class="type">unsigned</span> __int128;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> i64 LINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> esp = <span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1</span> &lt;&lt; <span class="number">21</span>], *p1 = buf, *p2 = buf;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> getchar() (p1 == p2 &amp;&amp; (p1 = buf, p2 = (p1 + fread(buf, 1, 1 &lt;&lt; 21, stdin))) == p1 ? EOF : *p1++)</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> T <span class="title">read</span><span class="params">()</span> </span>&#123; T x = <span class="number">0</span>, w = <span class="number">0</span>; <span class="type">char</span> ch = <span class="built_in">getchar</span>(); <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) w |= (ch == <span class="string">&#x27;-&#x27;</span>), ch = <span class="built_in">getchar</span>(); <span class="keyword">while</span> (<span class="string">&#x27;0&#x27;</span> &lt;= ch &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) x = x * <span class="number">10</span> + (ch ^ <span class="string">&#x27;0&#x27;</span>), ch = <span class="built_in">getchar</span>(); <span class="keyword">return</span> w ? -x : x; &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(T x)</span> </span>&#123; <span class="keyword">if</span> (!x) <span class="keyword">return</span>; <span class="built_in">write</span>&lt;T&gt;(x / <span class="number">10</span>), <span class="built_in">putchar</span>((x % <span class="number">10</span>) ^ <span class="string">&#x27;0&#x27;</span>); &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">(T x)</span> </span>&#123; <span class="keyword">if</span> (x &gt; <span class="number">0</span>) <span class="built_in">write</span>&lt;T&gt;(x); <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), <span class="built_in">write</span>&lt;T&gt;(-x); <span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>); &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">(T x, <span class="type">char</span> en)</span> </span>&#123; <span class="built_in">print</span>&lt;T&gt;(x), <span class="built_in">putchar</span>(en); &#125;</span><br><span class="line">&#125;; <span class="keyword">using</span> <span class="keyword">namespace</span> FastIO;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> getchar()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Info&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line">    <span class="type">int</span> _cnt = <span class="number">0</span>, n;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; left, right, version;</span><br><span class="line">    std::vector&lt;Info&gt; info;</span><br><span class="line">    <span class="built_in">SegmentTree</span>(<span class="type">int</span> n, <span class="type">int</span> q) &#123;</span><br><span class="line">        <span class="built_in">init</span>(std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>), q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SegmentTree</span>(std::vector&lt;<span class="type">int</span>&gt; _init, <span class="type">int</span> q) &#123;</span><br><span class="line">        <span class="built_in">init</span>(_init, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; _init, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">        n = _init.<span class="built_in">size</span>();</span><br><span class="line">        left.<span class="built_in">resize</span>((<span class="number">4</span> &lt;&lt; std::__lg(n)) + <span class="number">2</span> * q * std::__lg(n), <span class="number">-1</span>);</span><br><span class="line">        right.<span class="built_in">resize</span>((<span class="number">4</span> &lt;&lt; std::__lg(n)) + <span class="number">2</span> * q * std::__lg(n), <span class="number">-1</span>);</span><br><span class="line">        info.<span class="built_in">resize</span>((<span class="number">4</span> &lt;&lt; std::__lg(n)) + <span class="number">2</span> * q * std::__lg(n));</span><br><span class="line">        version.<span class="built_in">resize</span>(q + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">auto</span> build = [&amp;](<span class="keyword">auto</span> &amp;&amp; self, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="type">int</span> cur = _cnt++;</span><br><span class="line">            <span class="keyword">if</span> (l + <span class="number">1</span> == r) &#123;</span><br><span class="line">                info[cur] = _init[l];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">                left[cur] = <span class="built_in">self</span>(self, l, m);</span><br><span class="line">                right[cur] = <span class="built_in">self</span>(self, m, r);</span><br><span class="line">                <span class="built_in">pull</span>(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;;</span><br><span class="line">        version[<span class="number">0</span>] = <span class="built_in">build</span>(build, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        info[p] = info[left[p]] + info[right[p]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">copy</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cur = _cnt++;</span><br><span class="line">        left[cur] = left[i];</span><br><span class="line">        right[cur] = right[i];</span><br><span class="line">        info[cur] = info[i];</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> newVersion, <span class="type">int</span> modifyVersion, <span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        version[newVersion] = <span class="built_in">modify</span>(version[modifyVersion], <span class="number">0</span>, n, x, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cur = <span class="built_in">copy</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (l + <span class="number">1</span> == r) &#123;</span><br><span class="line">            info[cur].g += v;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; m) &#123;</span><br><span class="line">                left[cur] = <span class="built_in">modify</span>(left[p], l, m, x, v);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right[cur] = <span class="built_in">modify</span>(right[p], m, r, x, v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">pull</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> newVersion, <span class="type">int</span> queryVersion, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        version[newVersion] = version[queryVersion];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeQuery</span>(version[queryVersion], <span class="number">0</span>, n, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> Version, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeQuery</span>(version[Version], <span class="number">0</span>, n, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) <span class="keyword">return</span> info[p];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            Info ans;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; m) &#123;</span><br><span class="line">                ans = ans + <span class="built_in">rangeQuery</span>(left[p], l, m, x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (y &gt; m) &#123;</span><br><span class="line">                ans = ans + <span class="built_in">rangeQuery</span>(right[p], m, r, x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">    <span class="type">int</span> g = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Info</span>(<span class="type">int</span> _g = <span class="number">0</span>) : <span class="built_in">g</span>(_g) &#123;&#125;</span><br><span class="line">    Info <span class="keyword">operator</span>+(<span class="type">const</span> Info &amp;other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;g + other.g&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    n = <span class="built_in">read</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    m = <span class="built_in">read</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span>, <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        a[i] = <span class="built_in">read</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">        b[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">    b.<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>()), b.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">auto</span> id = [&amp;](<span class="type">int</span> x) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">lower_bound</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), x) - b.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> siz = b.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">SegmentTree&lt;Info&gt; <span class="title">seg</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;(siz, <span class="number">0</span>), n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        seg.<span class="built_in">modify</span>(i + <span class="number">1</span>, i, <span class="built_in">id</span>(a[i]), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> query = [&amp;](<span class="keyword">auto</span> &amp;&amp; query, <span class="type">int</span> p1, <span class="type">int</span> p2, <span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (l + <span class="number">1</span> &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> lsiz = seg.info[seg.left[p2]].g - seg.info[seg.left[p1]].g;</span><br><span class="line">            <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (lsiz &gt;= k) &#123;</span><br><span class="line">                p1 = seg.left[p1];</span><br><span class="line">                p2 = seg.left[p2];</span><br><span class="line">                r = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= lsiz;</span><br><span class="line">                p1 = seg.right[p1];</span><br><span class="line">                p2 = seg.right[p2];</span><br><span class="line">                l = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b[l];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> l, r, k;</span><br><span class="line">        l = <span class="built_in">read</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">        r = <span class="built_in">read</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">        k = <span class="built_in">read</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">        l--;</span><br><span class="line">        <span class="type">int</span> p1 = seg.version[l], p2 = seg.version[r];</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">query</span>(query, p1, p2, k, <span class="number">0</span>, siz), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="区间修改，区间查询的可持久化线段树"><a href="#区间修改，区间查询的可持久化线段树" class="headerlink" title="区间修改，区间查询的可持久化线段树"></a>区间修改，区间查询的可持久化线段树</h1><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/SP11470">SP11470 TTM - To the moon - 洛谷</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __LOCAL__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;F:/local.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __GNUG__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> PII = std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> u32 = <span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> u64 = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> i128 = __int128;</span><br><span class="line"><span class="keyword">using</span> u128 = <span class="type">unsigned</span> __int128;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> i64 LINF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> esp = <span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Info, <span class="keyword">typename</span> Tag&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line">    <span class="type">int</span> _cnt = <span class="number">0</span>, n, vercnt = <span class="number">1</span>;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; left, right, version;</span><br><span class="line">    std::vector&lt;Info&gt; info;</span><br><span class="line">    std::vector&lt;Tag&gt; tag;</span><br><span class="line">    <span class="built_in">SegmentTree</span>(<span class="type">int</span> n, <span class="type">int</span> q) &#123;</span><br><span class="line">        <span class="built_in">init</span>(std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>), q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SegmentTree</span>(<span class="keyword">auto</span> &amp;&amp;_init, <span class="type">int</span> q) &#123;</span><br><span class="line">        <span class="built_in">init</span>(_init, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="keyword">auto</span> &amp;&amp;_init, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">        n = _init.<span class="built_in">size</span>();</span><br><span class="line">        left.<span class="built_in">resize</span>((<span class="number">4</span> &lt;&lt; std::__lg(n)) + <span class="number">16</span> * q * std::__lg(n));</span><br><span class="line">        right.<span class="built_in">resize</span>((<span class="number">4</span> &lt;&lt; std::__lg(n)) + <span class="number">16</span> * q * std::__lg(n));</span><br><span class="line">        info.<span class="built_in">resize</span>((<span class="number">4</span> &lt;&lt; std::__lg(n)) + <span class="number">16</span> * q * std::__lg(n));</span><br><span class="line">        tag.<span class="built_in">resize</span>((<span class="number">4</span> &lt;&lt; std::__lg(n)) + <span class="number">16</span> * q * std::__lg(n));</span><br><span class="line">        version.<span class="built_in">resize</span>(q + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">auto</span> build = [&amp;](<span class="keyword">auto</span> &amp;&amp; build, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="type">int</span> cur = _cnt++;</span><br><span class="line">            <span class="keyword">if</span> (l + <span class="number">1</span> == r) &#123;</span><br><span class="line">                info[cur] = _init[l];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">                left[cur] = <span class="built_in">build</span>(build, l, m);</span><br><span class="line">                right[cur] = <span class="built_in">build</span>(build, m, r);</span><br><span class="line">                <span class="built_in">pull</span>(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;;</span><br><span class="line">        version[<span class="number">0</span>] = <span class="built_in">build</span>(build, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        info[p] = info[left[p]] + info[right[p]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> p, <span class="type">const</span> Tag &amp;v, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        info[p].<span class="built_in">push</span>(v, len);</span><br><span class="line">        tag[p].<span class="built_in">push</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        left[p] = <span class="built_in">copy</span>(left[p]);</span><br><span class="line">        right[p] = <span class="built_in">copy</span>(right[p]);</span><br><span class="line">        <span class="built_in">push</span>(left[p], tag[p], len / <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">push</span>(right[p], tag[p], len - len / <span class="number">2</span>);</span><br><span class="line">        tag[p] = <span class="built_in">Tag</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">copy</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cur = _cnt++;</span><br><span class="line">        left[cur] = left[i];</span><br><span class="line">        right[cur] = right[i];</span><br><span class="line">        info[cur] = info[i];</span><br><span class="line">        tag[cur] = tag[i];</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> newVersion, <span class="type">int</span> modifyVer, <span class="type">int</span> x, <span class="type">const</span> Tag &amp;v)</span> </span>&#123;</span><br><span class="line">        version[newVersion] = <span class="built_in">modify</span>(version[modifyVer], <span class="number">0</span>, n, x, x + <span class="number">1</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> newVersion, <span class="type">int</span> modifyVer, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">const</span> Tag &amp;v)</span> </span>&#123;</span><br><span class="line">        version[newVersion] = <span class="built_in">modify</span>(version[modifyVer], <span class="number">0</span>, n, l, r, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Tag &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cur = <span class="built_in">copy</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">            <span class="built_in">push</span>(cur, v, r - l);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">push</span>(cur, r - l);</span><br><span class="line">            <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; m) &#123;</span><br><span class="line">                left[cur] = <span class="built_in">modify</span>(left[cur], l, m, x, y, v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (y &gt; m) &#123;</span><br><span class="line">                right[cur] = <span class="built_in">modify</span>(right[cur], m, r, x, y, v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">pull</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> newVersion, <span class="type">int</span> queryVersion, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        version[newVersion] = version[queryVersion];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeQuery</span>(version[queryVersion], <span class="number">0</span>, n, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> queryVersion, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeQuery</span>(version[queryVersion], <span class="number">0</span>, n, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">            <span class="keyword">return</span> info[p];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">push</span>(p, r - l);</span><br><span class="line">            <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            Info ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; m) &#123;</span><br><span class="line">                ans = ans + <span class="built_in">rangeQuery</span>(left[p], l, m, x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (y &gt; m) &#123;</span><br><span class="line">                ans = ans + <span class="built_in">rangeQuery</span>(right[p], m, r, x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tag</span> &#123;</span><br><span class="line">    i64 lazy = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Tag</span>(i64 _lazy = <span class="number">0</span>): <span class="built_in">lazy</span>(_lazy) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(Tag t)</span> </span>&#123;</span><br><span class="line">        lazy = lazy + t.lazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">    i64 g = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Info</span>(i64 _g = <span class="number">0</span>) : <span class="built_in">g</span>(_g) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(Tag t, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        g = g + t.lazy * len;</span><br><span class="line">    &#125;</span><br><span class="line">    Info <span class="keyword">operator</span>+(<span class="type">const</span> Info &amp;other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;g + other.g&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> tm = m;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;x : a) &#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">SegmentTree&lt;Info, Tag&gt; <span class="title">seg</span><span class="params">(a, m + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">char</span> opt;</span><br><span class="line">        cin &gt;&gt; opt;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> l, r, d;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r &gt;&gt; d;</span><br><span class="line">            l--;</span><br><span class="line">            seg.version[t + <span class="number">1</span>] = seg.<span class="built_in">modify</span>(seg.version[t], <span class="number">0</span>, n, l, r, d);</span><br><span class="line">            t++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> l, r;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            l--;</span><br><span class="line">            cout &lt;&lt; seg.<span class="built_in">rangeQuery</span>(t, l, r).g &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="string">&#x27;H&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> l, r, x;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;</span><br><span class="line">            l--;</span><br><span class="line">            cout &lt;&lt; seg.<span class="built_in">rangeQuery</span>(x, l, r).g &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            t = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="标记永久化"><a href="#标记永久化" class="headerlink" title="*标记永久化"></a>*标记永久化</h1><p>‍</p>
<!-- From: 数据结构\有序表\AVL树（平衡搜索二叉树）.md -->


<h1 id="AVL树（平衡搜索二叉树）"><a href="#AVL树（平衡搜索二叉树）" class="headerlink" title="AVL树（平衡搜索二叉树）"></a>AVL树（平衡搜索二叉树）</h1><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/AVL_tree">AVL 树 - 维基百科 — AVL tree - Wikipedia</a></p>
<h1 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AVL</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; key, height, left, right, count, siz, rnk;</span><br><span class="line">    <span class="type">int</span> _cnt = <span class="number">0</span>, head = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">AVL</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">AVL</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        key.<span class="built_in">resize</span>(n);</span><br><span class="line">        height.<span class="built_in">resize</span>(n);</span><br><span class="line">        left.<span class="built_in">resize</span>(n);</span><br><span class="line">        right.<span class="built_in">resize</span>(n);</span><br><span class="line">        count.<span class="built_in">resize</span>(n);</span><br><span class="line">        siz.<span class="built_in">resize</span>(n);</span><br><span class="line">        rnk.<span class="built_in">resize</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        siz[i] = siz[left[i]] + siz[right[i]] + count[i];</span><br><span class="line">        height[i] = std::<span class="built_in">max</span>(height[left[i]], height[right[i]]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">leftRotate</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> r = right[i];</span><br><span class="line">        right[i] = left[r];</span><br><span class="line">        left[r] = i;</span><br><span class="line">        <span class="built_in">pull</span>(i);</span><br><span class="line">        <span class="built_in">pull</span>(r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rightRotate</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = left[i];</span><br><span class="line">        left[i] = right[l];</span><br><span class="line">        right[l] = i;</span><br><span class="line">        <span class="built_in">pull</span>(i);</span><br><span class="line">        <span class="built_in">pull</span>(l);</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maintain</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> lh = height[left[i]], rh = height[right[i]];</span><br><span class="line">        <span class="keyword">if</span> (lh &gt; rh + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[left[left[i]]] &gt;= height[right[left[i]]]) &#123;</span><br><span class="line">                i = <span class="built_in">rightRotate</span>(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left[i] = <span class="built_in">leftRotate</span>(left[i]);</span><br><span class="line">                i = <span class="built_in">rightRotate</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rh &gt; lh + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[right[right[i]]] &gt;= height[left[right[i]]]) &#123;</span><br><span class="line">                i = <span class="built_in">leftRotate</span>(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right[i] = <span class="built_in">rightRotate</span>(right[i]);</span><br><span class="line">                i = <span class="built_in">leftRotate</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        head = <span class="built_in">insert</span>(head, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            key[++_cnt] = num;</span><br><span class="line">            count[_cnt] = siz[_cnt] = height[_cnt] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> _cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key[i] == num) &#123;</span><br><span class="line">            count[i]++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key[i] &gt; num) &#123;</span><br><span class="line">            left[i] = <span class="built_in">insert</span>(left[i], num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right[i] = <span class="built_in">insert</span>(right[i], num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pull</span>(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">maintain</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRank</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getRank</span>(head, num) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRank</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key[i] &gt;= num) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getRank</span>(left[i], num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> siz[left[i]] + count[i] + <span class="built_in">getRank</span>(right[i], num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">index</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">index</span>(head, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">index</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (siz[left[i]] &gt;= x) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">index</span>(left[i], x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (siz[left[i]] + count[i] &lt; x) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">index</span>(right[i], x - siz[left[i]] - count[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> key[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pre</span>(head, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key[i] &gt;= num) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pre</span>(left[i], num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">max</span>(key[i], <span class="built_in">pre</span>(right[i], num));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">post</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">post</span>(head, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">post</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key[i] &lt;= num) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">post</span>(right[i], num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">min</span>(key[i], <span class="built_in">post</span>(left[i], num));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getRank</span>(num) != <span class="built_in">getRank</span>(num + <span class="number">1</span>)) &#123;</span><br><span class="line">            head = <span class="built_in">remove</span>(head, num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key[i] &lt; num) &#123;</span><br><span class="line">            right[i] = <span class="built_in">remove</span>(right[i], num);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key[i] &gt; num) &#123;</span><br><span class="line">            left[i] = <span class="built_in">remove</span>(left[i], num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[i] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                count[i]--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (left[i] == <span class="number">0</span> &amp;&amp; right[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left[i] != <span class="number">0</span> &amp;&amp; right[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    i = left[i];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left[i] == <span class="number">0</span> &amp;&amp; right[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    i = right[i];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">int</span> mostLeft = right[i];</span><br><span class="line">                    <span class="keyword">while</span> (left[mostLeft] != <span class="number">0</span>) &#123;</span><br><span class="line">                        mostLeft = left[mostLeft];</span><br><span class="line">                    &#125;</span><br><span class="line">                    right[i] = <span class="built_in">removeMostLeft</span>(right[i], mostLeft);</span><br><span class="line">                    left[mostLeft] = left[i];</span><br><span class="line">                    right[mostLeft] = right[i];</span><br><span class="line">                    i = mostLeft;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pull</span>(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">maintain</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeMostLeft</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> mostLeft)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == mostLeft) &#123;</span><br><span class="line">            <span class="keyword">return</span> right[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left[i] = <span class="built_in">removeMostLeft</span>(left[i], mostLeft);</span><br><span class="line">            <span class="built_in">pull</span>(i);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">maintain</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(head, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key[i] == num) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key[i] &lt; num &amp;&amp; right[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">find</span>(right[i], num);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">find</span>(left[i], num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h1><p>定义：一个<strong>搜索二叉树</strong>，对所有节点，满足 $|siz_{left}-siz_{right}|\le1$ （平衡性）成立</p>
<h1 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h1><ol>
<li>​<code>空间（节点）编号</code>：实际不存在，从 0 递增 ${0,1,2,3,\dots}$，0节点代表 $null$.</li>
<li>​<code>key</code>数组： key 值</li>
<li>​<code>height</code>数组：以对应节点为根的子树高度</li>
<li>​<code>left</code>数组：左子节点编号</li>
<li>​<code>right</code>数组：右子节点编号</li>
<li>​<code>count</code>数组：词频统计</li>
<li>​<code>siz</code>数组：以对应节点为根的子树大小（包含词频）</li>
</ol>
<h1 id="左旋和右旋"><a href="#左旋和右旋" class="headerlink" title="左旋和右旋"></a>左旋和右旋</h1><h2 id="LL型和RR型"><a href="#LL型和RR型" class="headerlink" title="LL型和RR型"></a>LL型和RR型</h2><p>图示RR型<img src="/%5Cassets%5Cimage-20250813075851-uepota1.png" alt="image"></p>
<h2 id="LR型和RL型"><a href="#LR型和RL型" class="headerlink" title="LR型和RL型"></a>LR型和RL型</h2><p>图示RL型：<img src="/%5Cassets%5Cimage-20250813075902-kgffqy4.png" alt="image"></p>
<h1 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h1><ol>
<li>插入时，最多只会出现一种违规情况</li>
<li>删除时，最多会出现两种违规情况，同时出现 LL&amp;LR&#x2F;RR&amp;RL 型，此时必须要选择 LL&#x2F;RR 型平衡操作</li>
</ol>
<p>检查节点平衡性时，递归检查每个经过的节点，最多只会发生一次平衡操作</p>
<p>‍</p>
<!-- From: 数据结构\有序表\C++STL：pbds平衡树.md -->


<h1 id="C-STL：pbds平衡树"><a href="#C-STL：pbds平衡树" class="headerlink" title="C++STL：pbds平衡树"></a>C++STL：pbds平衡树</h1><p>__gnu_pbds::tree</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span>  <span class="comment">// 因为 tree 定义在这里 所以需要包含这个头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ext/pb_ds/tree_policy.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line">__gnu_pbds::tree&lt;Key, Mapped, Cmp_Fn = std::less&lt;Key&gt;, Tag = rb_tree_tag,</span><br><span class="line">                 Node_Update = null_tree_node_update,</span><br><span class="line">                 Allocator = std::allocator&lt;<span class="type">char</span>&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="模板形参"><a href="#模板形参" class="headerlink" title="模板形参"></a>模板形参</h2><ul>
<li><p>​<code>Key</code>​: 储存的元素类型，如果想要存储多个相同的 <code>Key</code>​ 元素，则需要使用类似于 <code>std::pair</code>​ 和 <code>struct</code>​ 的方法，并配合使用 <code>lower_bound</code>​ 和 <code>upper_bound</code> 成员函数进行查找</p>
</li>
<li><p>​<code>Mapped</code>​: 映射规则（Mapped-Policy）类型，如果要指示关联容器是 <strong>集合</strong>，类似于存储元素在 <code>std::set</code>​ 中，此处填入 <code>null_type</code>​，低版本 <code>g++</code>​ 此处为 <code>null_mapped_type</code>​；如果要指示关联容器是 <strong>带值的集合</strong>，类似于存储元素在 <code>std::map</code>​ 中，此处填入类似于 <code>std::map&lt;Key, Value&gt;</code>​ 的 <code>Value</code> 类型</p>
</li>
<li><p>​<code>Cmp_Fn</code>​: 关键字比较函子，例如 <code>std::less&lt;Key&gt;</code></p>
</li>
<li><p>​<code>Tag</code>​: 选择使用何种底层数据结构类型，默认是 <code>rb_tree_tag</code>​。<code>__gnu_pbds</code> 提供不同的三种平衡树，分别是：</p>
<ul>
<li>​<code>rb_tree_tag</code>：红黑树，一般使用这个，后两者的性能一般不如红黑树</li>
<li>​<code>splay_tree_tag</code>：splay 树</li>
<li>​<code>ov_tree_tag</code>​：有序向量树，只是一个由 <code>vector</code>​ 实现的有序结构，类似于排序的 <code>vector</code> 来实现平衡树，性能取决于数据想不想卡你</li>
</ul>
</li>
<li><p>​<code>Node_Update</code>​：用于更新节点的策略，默认使用 <code>null_node_update</code>​，若要使用 <code>order_of_key</code>​ 和 <code>find_by_order</code>​ 方法，需要使用 <code>tree_order_statistics_node_update</code></p>
</li>
<li><p>​<code>Allocator</code>：空间分配器类型</p>
</li>
</ul>
<h2 id="构造方式"><a href="#构造方式" class="headerlink" title="构造方式"></a>构造方式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__gnu_pbds::tree&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, __gnu_pbds::null_type,</span><br><span class="line">                 std::less&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, __gnu_pbds::rb_tree_tag,</span><br><span class="line">                 __gnu_pbds::tree_order_statistics_node_update&gt;</span><br><span class="line">    trr;</span><br></pre></td></tr></table></figure>

<h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><ul>
<li>​<code>insert(x)</code>​：向树中插入一个元素 <code>x</code>​，返回 <code>std::pair&lt;point_iterator, bool&gt;</code>，其中第一个元素代表插入位置的迭代器，第二个元素代表是否插入成功。</li>
<li>​<code>erase(x)</code>​：从树中删除一个元素&#x2F;迭代器 <code>x</code>​。如果 <code>x</code>​ 是迭代器，则返回指向 <code>x</code>​ 下一个的迭代器（如果 <code>x</code>​ 是 <code>end()</code>​ 则返回 <code>end()</code>​）；如果 <code>x</code>​ 是 <code>Key</code>，则返回是否删除成功（如果不存在则删除失败）。</li>
<li>​<code>order_of_key(x)</code>​：返回严格小于 <code>x</code>​ 的元素个数（以 <code>Cmp_Fn</code> 作为比较逻辑），即从 $0$ 开始的排名。</li>
<li>​<code>find_by_order(x)</code>​：返回 <code>Cmp_Fn</code> 比较的排名所对应元素的迭代器。</li>
<li>​<code>lower_bound(x)</code>​：返回第一个不小于 <code>x</code>​ 的元素所对应的迭代器（以 <code>Cmp_Fn</code> 作为比较逻辑）。</li>
<li>​<code>upper_bound(x)</code>​：返回第一个严格大于 <code>x</code>​ 的元素所对应的迭代器（以 <code>Cmp_Fn</code> 作为比较逻辑）。</li>
<li>​<code>join(x)</code>​：将 <code>x</code>​ 树并入当前树，<code>x</code>​ 树被清空（必须确保两树的 <strong>比较函数</strong> 和 <strong>元素类型</strong> 相同）。</li>
<li>​<code>split(x,b)</code>​：以 <code>Cmp_Fn</code>​ 比较，小于等于 <code>x</code>​ 的属于当前树，其余的属于 <code>b</code> 树。</li>
<li>​<code>empty()</code>：返回是否为空。</li>
<li>​<code>size()</code>：返回大小。</li>
</ul>
<p>注意： <code>join(x)</code>​ 函数需要保证并入树的键的值域与被并入树的键的值域 <strong>不相交</strong>（也就是说并入树内所有值必须全部大于&#x2F;小于当前树内的所有值），否则会抛出 <code>join_error</code> 异常。如果要合并两棵值域有交集的树，需要将一棵树的元素一一插入到另一棵树中。</p>
<h1 id="P3369-【模板】普通平衡树"><a href="#P3369-【模板】普通平衡树" class="headerlink" title="P3369 【模板】普通平衡树"></a>P3369 【模板】普通平衡树</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>您需要动态地维护一个可重集合 $M$，并且提供以下操作：</p>
<ol>
<li>向 $M$ 中插入一个数 $x$。</li>
<li>从 $M$ 中删除一个数 $x$（若有多个相同的数，应只删除一个）。</li>
<li>查询 $M$ 中有多少个数比 $x$ 小，并且将得到的答案加一。</li>
<li>查询如果将 $M$ 从小到大排列后，排名位于第 $x$ 位的数。</li>
<li>查询 $M$ 中 $x$ 的前驱（前驱定义为小于 $x$，且最大的数）。</li>
<li>查询 $M$ 中 $x$ 的后继（后继定义为大于 $x$，且最小的数）。</li>
</ol>
<p>对于操作 $3,5,6$，<strong>不保证</strong>当前可重集中存在数 $x$。</p>
<p>对于操作 $5,6$，保证答案一定存在。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  __gnu_pbds::tree&lt;pii, __gnu_pbds::null_type, std::less&lt;pii&gt;,</span><br><span class="line">                   __gnu_pbds::rb_tree_tag,</span><br><span class="line">                   __gnu_pbds::tree_order_statistics_node_update&gt;</span><br><span class="line">      tr;</span><br><span class="line">  <span class="type">int</span> n, cnt = <span class="number">0</span>;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    <span class="type">int</span> t, x;</span><br><span class="line">    cin &gt;&gt; t &gt;&gt; x;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">1</span>) &#123;</span><br><span class="line">      tr.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(x, cnt++));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">2</span>) &#123;</span><br><span class="line">      tr.<span class="built_in">erase</span>(tr.<span class="built_in">lower_bound</span>(std::<span class="built_in">make_pair</span>(x, <span class="number">0</span>)));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">3</span>) &#123;</span><br><span class="line">      cout &lt;&lt; tr.<span class="built_in">order_of_key</span>(std::<span class="built_in">make_pair</span>(x, <span class="number">0</span>)) + <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">4</span>) &#123;</span><br><span class="line">      cout &lt;&lt; tr.<span class="built_in">find_by_order</span>(x - <span class="number">1</span>)-&gt;fi &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">5</span>) &#123;</span><br><span class="line">      cout &lt;&lt; std::<span class="built_in">prev</span>(tr.<span class="built_in">lower_bound</span>(std::<span class="built_in">make_pair</span>(x, <span class="number">0</span>)))-&gt;fi &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cout &lt;&lt; tr.<span class="built_in">upper_bound</span>(std::<span class="built_in">make_pair</span>(x, INF))-&gt;fi &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<!-- From: 数据结构\有序表\README.md -->


<h1 id="有序表"><a href="#有序表" class="headerlink" title="有序表"></a>有序表</h1><h1 id="有序表-1"><a href="#有序表-1" class="headerlink" title="有序表"></a>有序表</h1><p>一个抽象类，有序表中的key按序组织，并且支持和序有关的查询操作，增加或者删减某个key时，也要维护序。增删改查的时间复杂度为 $O(\log n)$。</p>
<h1 id="通用接口"><a href="#通用接口" class="headerlink" title="通用接口"></a>通用接口</h1><p>设有一个可重集合 $M$，需要支持以下操作：</p>
<ol>
<li>向 $M$ 中插入一个数 $x$</li>
<li>从 $M$ 中删除一个数 $x$</li>
<li>查询 $M$ 中有多少数字比 $x$ 小，并将答案 $+1$（查询 $x$ 从小到大的排名）</li>
<li>查询 $M$ 中从小到大排名为 $x$ 的元素</li>
<li>查询 $x$ 的前驱（小于 $x$ 且最大的数字）</li>
<li>查询 $x$ 的后继（大于 $x$ 且最小的数字）</li>
</ol>
<!-- From: 数据结构\有序表\Splay\LCT.md -->


<h1 id="LCT"><a href="#LCT" class="headerlink" title="LCT"></a>LCT</h1><p>Link-Cut-Tree</p>
<p>在树链剖分支持的操作的基础上，加入“增加一些边并删除一些边，保证操作后仍是一棵树，但结构发生改变”操作，成为动态树问题</p>
<h1 id="动态树问题"><a href="#动态树问题" class="headerlink" title="动态树问题"></a>动态树问题</h1><p>维护一个 ​<strong>森林</strong>，支持删除某条边，加入某条边，并保证加边，删边之后仍是森林。我们要维护这个森林的一些信息。</p>
<p>一般的操作有两点连通性，两点路径权值和，连接两点和切断某条边、修改信息等。</p>
<h1 id="实链剖分"><a href="#实链剖分" class="headerlink" title="实链剖分"></a>实链剖分</h1><p>对于一个点连向它所有儿子的边，我们自己选择一条边进行剖分，我们称被选择的边为实边，其他边则为虚边。对于实边，我们称它所连接的儿子为实儿子。对于一条由实边组成的链，我们同样称之为实链。请记住我们选择实链剖分的最重要的原因：它是我们选择的，灵活且可变。正是它的这种灵活可变性，我们采用 Splay Tree 来维护这些实链。</p>
<p>一个节点只能选一个子节点作为实子节点，其他都是虚子节点</p>
<p><strong>实边：</strong> 父节点与实儿子之间的边，为双向边</p>
<p><strong>虚边：</strong> 由虚儿子指向父节点的边，为单向边（认子不认父）</p>
<p><strong>实链：</strong> 由实边构成的链，每条实链的节点深度都是严格递增的。</p>
<h1 id="LCT-1"><a href="#LCT-1" class="headerlink" title="LCT"></a>LCT</h1><p>我们可以简单的把 LCT 理解成用一些 Splay 来维护动态的树链剖分，以期实现动态树上的区间操作。对于每条实链，我们建一个 Splay 来维护整个链区间的信息。</p>
<p><strong>辅助树：</strong> 由若干 splay 树构成，与原树等价，只需要维护辅助树即可</p>
<p><strong>性质：</strong></p>
<ol>
<li>每条实链用一个 splay 维护，辅助树中序遍历的节点序列在原树中的深度严格递增，中序遍历这棵 Splay 得到的点序列，从前到后对应原树「从上到下」的一条路径</li>
<li>原树每个节点与辅助树的 Splay 节点一一对应</li>
<li>辅助树的各棵 Splay 之间并不是独立的。每棵 Splay 的根节点的父亲节点本应是空，但在 LCT 中每棵 Splay 的根节点的父亲节点指向原树中 <strong>这条链</strong> 的父亲节点（即链最顶端的点的父亲节点）。这类父亲链接与通常 Splay 的父亲链接区别在于儿子认父亲，而父亲不认儿子，对应原树的一条 ​<strong>虚边</strong>​。因此，<strong>每个连通块恰好有一个点的父亲节点为空</strong>。</li>
</ol>
<p>由于辅助树的以上性质，我们维护任何操作都不需要维护原树，辅助树可以在任何情况下拿出一个<strong>唯一的原树</strong>，我们只需要维护辅助树即可。</p>
<p><strong>注意：</strong></p>
<ol>
<li>区分树根和 splay 的树根</li>
<li>虚边从下面 splay 的根指向上面 splay 中的父亲</li>
<li>实边和虚边是动态变化的</li>
</ol>
<p><strong>考虑原树和辅助树的结构关系</strong></p>
<ul>
<li>原树中的实链 : 在辅助树中节点都在一棵 Splay 中。</li>
<li>原树中的虚链 : 在辅助树中，子节点所在 Splay 的 Father 指向父节点，但是父节点的两个儿子都不指向子节点。</li>
<li>注意：原树的根不等于辅助树的根。</li>
<li>原树的 Father 指向不等于辅助树的 Father 指向。</li>
<li>辅助树是可以在满足辅助树、Splay 的性质下任意换根的。</li>
<li>虚实链变换可以轻松在辅助树上完成，这也就是实现了动态维护树链剖分。</li>
</ul>
<h1 id="模板-4"><a href="#模板-4" class="headerlink" title="模板"></a>模板</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> fa(x) tr[x].f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls(x) tr[x].son[0]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(x) tr[x].son[1]</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="type">int</span> son[<span class="number">2</span>], f, siz = <span class="number">1</span>, val, sum;</span><br><span class="line">  <span class="type">int</span> tag;</span><br><span class="line">&#125;;</span><br><span class="line">Node tr[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isRoot</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> (x != <span class="built_in">ls</span>(<span class="built_in">fa</span>(x)) &amp;&amp; x != <span class="built_in">rs</span>(<span class="built_in">fa</span>(x))); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tr[x].tag) &#123;</span><br><span class="line">    std::<span class="built_in">swap</span>(<span class="built_in">ls</span>(x), <span class="built_in">rs</span>(x));</span><br><span class="line">    tr[<span class="built_in">ls</span>(x)].tag ^= <span class="number">1</span>;</span><br><span class="line">    tr[<span class="built_in">rs</span>(x)].tag ^= <span class="number">1</span>;</span><br><span class="line">    tr[x].tag = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  tr[x].sum = tr[x].val ^ tr[<span class="built_in">ls</span>(x)].sum ^ tr[<span class="built_in">rs</span>(x)].sum;</span><br><span class="line">  tr[x].siz = tr[<span class="built_in">ls</span>(x)].siz + tr[<span class="built_in">rs</span>(x)].siz + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">isRoot</span>(x)) &#123;</span><br><span class="line">    <span class="built_in">Update</span>(<span class="built_in">fa</span>(x));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">push</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Rotate</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> y = <span class="built_in">fa</span>(x), z = <span class="built_in">fa</span>(y);</span><br><span class="line">  <span class="type">int</span> k = <span class="built_in">rs</span>(y) == x;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">isRoot</span>(y)) &#123;</span><br><span class="line">    tr[z].son[<span class="built_in">rs</span>(z) == y] = x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">fa</span>(x) = z;</span><br><span class="line">  tr[y].son[k] = tr[x].son[!k];</span><br><span class="line">  <span class="built_in">fa</span>(tr[x].son[!k]) = y;</span><br><span class="line">  tr[x].son[!k] = y;</span><br><span class="line">  <span class="built_in">fa</span>(y) = x;</span><br><span class="line">  <span class="built_in">pull</span>(y);</span><br><span class="line">  <span class="built_in">pull</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Splay</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Update</span>(x);</span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">isRoot</span>(x)) &#123;</span><br><span class="line">    <span class="type">int</span> y = <span class="built_in">fa</span>(x), z = <span class="built_in">fa</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isRoot</span>(y)) &#123;</span><br><span class="line">      (<span class="built_in">rs</span>(y) == x) ^ (<span class="built_in">rs</span>(z) == y) ? <span class="built_in">Rotate</span>(x) : <span class="built_in">Rotate</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Rotate</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Access</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; x;) &#123;</span><br><span class="line">    <span class="built_in">Splay</span>(x);</span><br><span class="line">    <span class="built_in">rs</span>(x) = y;</span><br><span class="line">    <span class="built_in">pull</span>(x);</span><br><span class="line">    y = x;</span><br><span class="line">    x = <span class="built_in">fa</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeRoot</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Access</span>(x);</span><br><span class="line">  <span class="built_in">Splay</span>(x);</span><br><span class="line">  tr[x].tag ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">makeRoot</span>(x);</span><br><span class="line">  <span class="built_in">Access</span>(y);</span><br><span class="line">  <span class="built_in">Splay</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findRoot</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Access</span>(x);</span><br><span class="line">  <span class="built_in">Splay</span>(x);</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">ls</span>(x)) &#123;</span><br><span class="line">    <span class="built_in">push</span>(x);</span><br><span class="line">    x = <span class="built_in">ls</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Splay</span>(x);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">link</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">makeRoot</span>(x);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">findRoot</span>(y) != x) &#123;</span><br><span class="line">    <span class="built_in">fa</span>(x) = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cut</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">makeRoot</span>(x);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">findRoot</span>(y) == x &amp;&amp; <span class="built_in">fa</span>(y) == x &amp;&amp; !<span class="built_in">ls</span>(y)) &#123;</span><br><span class="line">    <span class="built_in">rs</span>(x) = <span class="built_in">fa</span>(y) = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pull</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Splay</span>(x);</span><br><span class="line">  tr[x].val = val;</span><br><span class="line">  <span class="built_in">pull</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>‍</p>
<!-- From: 数据结构\有序表\Splay\README.md -->


<h1 id="Splay"><a href="#Splay" class="headerlink" title="Splay"></a>Splay</h1><p>Link-Cut-Tree 的基础</p>
<p>使用提根操作释放势能，时间复杂度 $O(\log n)$，常数较大</p>
<h1 id="splay操作"><a href="#splay操作" class="headerlink" title="splay操作"></a>splay操作</h1><p>每次插入、删除、查找操作后，将最后一个节点上升到根节点位置，能保证不会出现过长链</p>
<p>设最后一个节点为 $x$，父节点 $f$，父节点的父节点 $g$</p>
<p>$splay(x,0)$，将 $x$ 提跟到 0 的子节点的位置</p>
<h2 id="zig"><a href="#zig" class="headerlink" title="zig"></a>zig</h2><p>$g$ 为 $goal$ 节点，只需要将 $x$ 旋转到 $f$ 位置</p>
<h2 id="zig-zig"><a href="#zig-zig" class="headerlink" title="zig-zig"></a>zig-zig</h2><p>$g$ 与 $f$，$f$ 与 $x$ 在同侧</p>
<p>先旋转 $f$，再旋转 $x$</p>
<h2 id="zig-zag"><a href="#zig-zag" class="headerlink" title="zig-zag"></a>zig-zag</h2><p>$g$ 与 $f$，$f$ 与 $x$ 在异侧</p>
<p>旋转两次 $x$</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>具体实现尽量使用循环，减少递归操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Splay</span> &#123;</span><br><span class="line">  <span class="type">int</span> _cnt, head;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; key, left, right, siz, father;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Splay</span>(<span class="type">int</span> _n = <span class="number">0</span>) &#123;</span><br><span class="line">    _cnt = <span class="number">0</span>;</span><br><span class="line">    head = <span class="number">0</span>;</span><br><span class="line">    key.<span class="built_in">resize</span>(_n);</span><br><span class="line">    left.<span class="built_in">resize</span>(_n);</span><br><span class="line">    right.<span class="built_in">resize</span>(_n);</span><br><span class="line">    siz.<span class="built_in">resize</span>(_n);</span><br><span class="line">    father.<span class="built_in">resize</span>(_n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; siz[i] = siz[left[i]] + siz[right[i]] + <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isLeft</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; <span class="keyword">return</span> left[father[i]] == i ? <span class="literal">true</span> : <span class="literal">false</span>; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> f = father[i], g = father[f], islefti = <span class="built_in">isLeft</span>(i), isleftf = <span class="built_in">isLeft</span>(f);</span><br><span class="line">    <span class="keyword">if</span> (islefti) &#123;</span><br><span class="line">      left[f] = right[i];</span><br><span class="line">      right[i] = f;</span><br><span class="line">      <span class="keyword">if</span> (left[f]) &#123;</span><br><span class="line">        father[left[f]] = f;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right[f] = left[i];</span><br><span class="line">      left[i] = f;</span><br><span class="line">      <span class="keyword">if</span> (right[f]) &#123;</span><br><span class="line">        father[right[f]] = f;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (g) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isleftf) &#123;</span><br><span class="line">        left[g] = i;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        right[g] = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    father[i] = g;</span><br><span class="line">    father[f] = i;</span><br><span class="line">    <span class="built_in">pull</span>(f);</span><br><span class="line">    <span class="built_in">pull</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> goal)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> f = father[i], g = father[f];</span><br><span class="line">    <span class="keyword">while</span> (f != goal) &#123;</span><br><span class="line">      <span class="keyword">if</span> (g != goal) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isLeft</span>(i) == <span class="built_in">isLeft</span>(f)) &#123;</span><br><span class="line">          <span class="built_in">rotate</span>(f);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">rotate</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">rotate</span>(i);</span><br><span class="line">      f = father[i];</span><br><span class="line">      g = father[f];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (goal == <span class="number">0</span>) &#123;</span><br><span class="line">      head = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> rnk)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = head;</span><br><span class="line">    <span class="keyword">while</span> (i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (siz[left[i]] + <span class="number">1</span> == rnk) &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (siz[left[i]] &gt;= rnk) &#123;</span><br><span class="line">        i = left[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rnk -= siz[left[i]] + <span class="number">1</span>;</span><br><span class="line">        i = right[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    key[++_cnt] = num;</span><br><span class="line">    siz[_cnt] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="number">0</span>) &#123;</span><br><span class="line">      head = _cnt;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">int</span> f = <span class="number">0</span>, i = head;</span><br><span class="line">      <span class="type">bool</span> isleft = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">while</span> (i) &#123;</span><br><span class="line">        f = i;</span><br><span class="line">        <span class="keyword">if</span> (key[i] &lt;= num) &#123;</span><br><span class="line">          i = right[i];</span><br><span class="line">          isleft = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          i = left[i];</span><br><span class="line">          isleft = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isleft) &#123;</span><br><span class="line">        left[f] = _cnt;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        right[f] = _cnt;</span><br><span class="line">      &#125;</span><br><span class="line">      father[_cnt] = f;</span><br><span class="line">      <span class="built_in">splay</span>(_cnt, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> kth;</span><br><span class="line">    <span class="keyword">if</span> ((kth = <span class="built_in">getRank</span>(num)) != <span class="built_in">getRank</span>(num + <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="type">int</span> i = <span class="built_in">find</span>(kth);</span><br><span class="line">      <span class="built_in">splay</span>(i, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (left[i] == <span class="number">0</span>) &#123;</span><br><span class="line">        head = right[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right[i] == <span class="number">0</span>) &#123;</span><br><span class="line">        head = left[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="built_in">find</span>(kth + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">splay</span>(j, i);</span><br><span class="line">        left[j] = left[i];</span><br><span class="line">        father[left[j]] = j;</span><br><span class="line">        <span class="built_in">pull</span>(j);</span><br><span class="line">        head = j;</span><br><span class="line">      &#125;</span><br><span class="line">      father[head] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getRank</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = head, last = head;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i) &#123;</span><br><span class="line">      last = i;</span><br><span class="line">      <span class="keyword">if</span> (key[i] &lt; num) &#123;</span><br><span class="line">        ans += siz[left[i]] + <span class="number">1</span>;</span><br><span class="line">        i = right[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i = left[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">splay</span>(last, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">index</span><span class="params">(<span class="type">int</span> rnk)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">find</span>(rnk);</span><br><span class="line">    <span class="built_in">splay</span>(i, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> key[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">post</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = head, last = head;</span><br><span class="line">    <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span> (i) &#123;</span><br><span class="line">      last = i;</span><br><span class="line">      <span class="keyword">if</span> (key[i] &lt;= num) &#123;</span><br><span class="line">        i = right[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ans = std::<span class="built_in">min</span>(ans, key[i]);</span><br><span class="line">        i = left[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">splay</span>(last, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = head, last = head;</span><br><span class="line">    <span class="type">int</span> ans = INT_MIN;</span><br><span class="line">    <span class="keyword">while</span> (i) &#123;</span><br><span class="line">      last = i;</span><br><span class="line">      <span class="keyword">if</span> (key[i] &gt;= num) &#123;</span><br><span class="line">        i = left[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ans = std::<span class="built_in">max</span>(ans, key[i]);</span><br><span class="line">        i = right[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">splay</span>(last, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>‍</p>
<!-- From: 数据结构\有序表\笛卡尔树，旋转Treap，FHQ Treap.md -->


<h1 id="笛卡尔树，旋转Treap，FHQ-Treap"><a href="#笛卡尔树，旋转Treap，FHQ-Treap" class="headerlink" title="笛卡尔树，旋转Treap，FHQ Treap"></a>笛卡尔树，旋转Treap，FHQ Treap</h1><h1 id="笛卡尔树"><a href="#笛卡尔树" class="headerlink" title="笛卡尔树"></a>笛卡尔树</h1><h2 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h2><p>笛卡尔树是一种二叉树，每一个节点由一个键值二元组 $(k,w)$ 构成。要求 $k$ 满足二叉搜索树的性质，而 $w$ 满足堆的性质。如果笛卡尔树的 $k,w$ 键值确定，且 $k$ 互不相同，$w$ 也互不相同，那么这棵笛卡尔树的结构是唯一的。</p>
<p><img src="/%5Cassets%5Cimage-20251014152119-3xsvl0j.png" alt="image"></p>
<p>如图，$k$$ey$ 为数组索引，$val$ 为数组值。可以发现，这棵树的键值 $k$ 满足<strong>二叉搜索树</strong>的性质，而键值 $w$ 满足<strong>小根堆</strong>的性质。同时根据二叉搜索树的性质，可以发现这种特殊的笛卡尔树满足<strong>一棵子树内的下标是一个连续区间</strong>。竞赛中使用笛卡尔树时，常用<strong>数组下标</strong>作为二元组的键值 $k$。</p>
<h2 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h2><p>使用单调栈，栈元素为 $(key, val)$，栈顶元素 $top$，当前插入元素为 $cur$，插入顺序为一次插入，假设 $val$ 组织方式为小根堆：</p>
<ol>
<li><p>栈为空或 $val_{top}\le val_{cur}$：$top\rightarrow right&#x3D;cur$，直接插入</p>
</li>
<li><p>$val_{top}&gt;val_{cur}$：依次弹出 $top$，设最后弹出的元素为 $last$，直至：</p>
<ul>
<li>$val_{top}\le val_{cur}$：设 $cur\rightarrow left &#x3D; last,top\rightarrow right &#x3D; cur$</li>
<li>栈为空：$cur\rightarrow left &#x3D; last$</li>
</ul>
</li>
<li><p>最后一个元素插入后，栈底元素即为树头结点</p>
</li>
</ol>
<p>每次连树边都保证子树值大于根节点值，满足 $val$ 组成小根堆的性质；</p>
<p>加入的 $key$ 单调递增，被弹出的放在 $cur$ 的左子树，$cur$ 放在 $top$ 的右子树，$key$ 满足二叉搜索树性质</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">std::stack&lt;pii&gt; stk;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n, <span class="number">-1</span>)</span>, <span class="title">right</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="type">int</span> p;</span><br><span class="line">  std::cin &gt;&gt; p;</span><br><span class="line">  <span class="keyword">if</span> (stk.<span class="built_in">empty</span>() || stk.<span class="built_in">top</span>().se &lt;= p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      right[stk.<span class="built_in">top</span>().fi] = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">int</span> last = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; stk.<span class="built_in">top</span>().se &gt; p) &#123;</span><br><span class="line">      last = stk.<span class="built_in">top</span>().fi;</span><br><span class="line">      stk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    left[i] = last;</span><br><span class="line">    <span class="keyword">if</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      right[stk.<span class="built_in">top</span>().fi] = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  stk.<span class="built_in">push</span>(&#123;i, p&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="旋转Treap"><a href="#旋转Treap" class="headerlink" title="旋转Treap"></a>旋转Treap</h1><p>节点信息为 $(key, priority)$，$key$ 为指定输入信息，$priority$ 为新建该节点时 $random$ 出的优先级</p>
<p>保证 $key$ 满足二叉搜索树的性质，同时要保证子节点的优先级小于父节点，$priority$ 满足大&#x2F;小根堆性质</p>
<p>在给朴素搜索树插入一个新节点时，我们需要从这个搜索树的根节点开始递归，如果新节点比当前节点小，那就向左递归，反之亦然。</p>
<p>最后当发现当前节点没有子节点时，就根据新节点的值的大小，让新节点成为当前节点的左或右子节点。</p>
<p>如果插入结点的权值是随机的（换言之，是随机插入的），那这个朴素搜索树的高度较小（接近 $\log n$，其中 $n$ 为结点数），而每一层的节点数较多，即它的形状会非常的「胖」。上图的 Treap 就是一个例子。因此此时的任意操作复杂度都将会是 $O(\log n)$ 左右。</p>
<p>节点信息：$key[],count[],siz[],left[],right[]$</p>
<p>实现代码同 AVL 树，插入，删除操作略有不同</p>
<ol>
<li><p>插入，若新建节点插入后，依次回溯过程中：</p>
<ul>
<li>该节点有左子树且左子树头节点优先级更高，右旋当前头节点</li>
<li>该节点有右子树且又子树头节点优先级更高，左旋当前头节点</li>
</ul>
</li>
<li><p>删除，若删除了某个节点：</p>
<ul>
<li>如果没有左子树并且没有右子树，直接删除</li>
<li>如果只有左子树或者只有右子树，则将左子树&#x2F;右子树头节点替换当前头节点</li>
<li>如果既有左子树又有右子树，选择优先值更大的，通过左旋或者右旋操作交换当前节点，直至遇到前两种情况</li>
</ul>
</li>
<li><p>其余操作与 AVL 树相同</p>
</li>
</ol>
<p>不提供代码，只提供 FHQTreap 代码</p>
<h1 id="无旋Treap（FHQ-Treap）"><a href="#无旋Treap（FHQ-Treap）" class="headerlink" title="无旋Treap（FHQ Treap）"></a>无旋Treap（FHQ Treap）</h1><p>建树时，节点按照旋转 Treap 组织，特殊之处在于 split 操作和 merge 操作，用以优化插入和删除，可显著降低常数时间，并且可以实现区间删除，区间平移，区间旋转等特殊操作。</p>
<h2 id="分裂-split-操作"><a href="#分裂-split-操作" class="headerlink" title="分裂 split 操作"></a>分裂 split 操作</h2><h3 id="按值分裂"><a href="#按值分裂" class="headerlink" title="按值分裂"></a>按值分裂</h3><p>将原树分解为两棵二叉搜索树，满足左树所有值 $\le num$，右树所有值 $&gt;num$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">splitByVal</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> i, <span class="type">int</span> num)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数为：当前左树移动到的节点，当前右树移动到的节点，当前等待分配的节点，num值</p>
<ol>
<li>初始 $l&#x3D;0,r&#x3D;0,i&#x3D;初始头节点$</li>
<li><ul>
<li>若当前节点 $i$ 的值 $\le num$，<code>right[l] = i; splitByVal(i, r, right[i], num);</code></li>
<li>若当前节点 $i$ 的值 $&gt;num$， <code>left[r] = i; splitByVal(l, i, left[i], num);</code></li>
<li>直至 $i$ 节点不存在（$i&#x3D;0$），设置<code>right[l] = left[r] = 0;</code></li>
</ul>
</li>
<li>$right[0]$是左树根节点，$left[0]$是右树根节点</li>
</ol>
<h3 id="按排名分裂（无词频压缩）"><a href="#按排名分裂（无词频压缩）" class="headerlink" title="按排名分裂（无词频压缩）"></a>按排名分裂（无词频压缩）</h3><p>略</p>
<h2 id="合并-merge-操作"><a href="#合并-merge-操作" class="headerlink" title="合并 merge 操作"></a>合并 merge 操作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>;</span><br></pre></td></tr></table></figure>

<p>$l$，$r$ 是要合并的两棵树，按照 $priority$ 决定优先级，返回合成树的根节点</p>
<ol>
<li>如果 $priority[l] \ge priority[r]$，用 $l$ 做当前节点</li>
<li>反之用 $r$ 做当前节点</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FHQTreap</span> &#123;</span><br><span class="line">  <span class="type">int</span> head, _cnt;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; left, right, key, count, siz;</span><br><span class="line">  std::vector&lt;<span class="type">double</span>&gt; priority;</span><br><span class="line">  std::random_device rd;</span><br><span class="line">  std::mt19937 gen;</span><br><span class="line">  std::uniform_real_distribution&lt;<span class="type">double</span>&gt; dis;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FHQTreap</span>(<span class="type">int</span> _n = <span class="number">1e5</span>) : <span class="built_in">gen</span>(<span class="built_in">rd</span>()), <span class="built_in">dis</span>(<span class="number">0.0</span>, <span class="number">1.0</span>) &#123;</span><br><span class="line">    head = _cnt = <span class="number">0</span>;</span><br><span class="line">    left.<span class="built_in">resize</span>(_n);</span><br><span class="line">    right.<span class="built_in">resize</span>(_n);</span><br><span class="line">    key.<span class="built_in">resize</span>(_n);</span><br><span class="line">    count.<span class="built_in">resize</span>(_n);</span><br><span class="line">    siz.<span class="built_in">resize</span>(_n);</span><br><span class="line">    priority.<span class="built_in">resize</span>(_n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; siz[i] = siz[left[i]] + siz[right[i]] + count[i]; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">splitByVal</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> i, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">      right[l] = left[r] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (key[i] &lt;= val) &#123;</span><br><span class="line">        right[l] = i;</span><br><span class="line">        <span class="built_in">splitByVal</span>(i, r, right[i], val);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left[r] = i;</span><br><span class="line">        <span class="built_in">splitByVal</span>(l, i, left[i], val);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">pull</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">splitByRnk</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> i, <span class="type">int</span> rnk)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">      right[l] = left[r] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (siz[left[i]] + <span class="number">1</span> &lt;= rnk) &#123;</span><br><span class="line">        right[l] = i;</span><br><span class="line">        <span class="built_in">splitByRnk</span>(i, r, right[i], rnk - siz[left[i]] - <span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left[r] = i;</span><br><span class="line">        <span class="built_in">splitByRnk</span>(l, i, left[i], rnk);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">pull</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!l || !r) &#123;</span><br><span class="line">      <span class="keyword">return</span> l + r;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (priority[l] &gt;= priority[r]) &#123;</span><br><span class="line">      right[l] = <span class="built_in">merge</span>(right[l], r);</span><br><span class="line">      <span class="built_in">pull</span>(l);</span><br><span class="line">      <span class="keyword">return</span> l;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      left[r] = <span class="built_in">merge</span>(l, left[r]);</span><br><span class="line">      <span class="built_in">pull</span>(r);</span><br><span class="line">      <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key[i] == val) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key[i] &lt; val) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">find</span>(right[i], val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">find</span>(left[i], val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">changeCount</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> val, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key[i] == val) &#123;</span><br><span class="line">      count[i] += v;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key[i] &lt; val) &#123;</span><br><span class="line">      <span class="built_in">changeCount</span>(right[i], val, v);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">changeCount</span>(left[i], val, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pull</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(head, val) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">changeCount</span>(head, val, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">splitByVal</span>(<span class="number">0</span>, <span class="number">0</span>, head, val);</span><br><span class="line">      key[++_cnt] = val;</span><br><span class="line">      priority[_cnt] = <span class="built_in">dis</span>(gen);</span><br><span class="line">      count[_cnt] = siz[_cnt] = <span class="number">1</span>;</span><br><span class="line">      head = <span class="built_in">merge</span>(<span class="built_in">merge</span>(right[<span class="number">0</span>], _cnt), left[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">find</span>(head, val);</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (count[i] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">changeCount</span>(head, val, <span class="number">-1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">splitByVal</span>(<span class="number">0</span>, <span class="number">0</span>, head, val);</span><br><span class="line">        <span class="type">int</span> lm = right[<span class="number">0</span>], r = left[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">splitByVal</span>(<span class="number">0</span>, <span class="number">0</span>, lm, val - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> l = right[<span class="number">0</span>];</span><br><span class="line">        head = <span class="built_in">merge</span>(l, r);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">small</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key[i] &lt; val) &#123;</span><br><span class="line">      <span class="keyword">return</span> siz[left[i]] + count[i] + <span class="built_in">small</span>(right[i], val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">small</span>(left[i], val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getRank</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">small</span>(head, val) + <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">index</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (siz[left[i]] &gt;= x) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">index</span>(left[i], x);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (siz[left[i]] + count[i] &gt;= x) &#123;</span><br><span class="line">      <span class="keyword">return</span> key[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">index</span>(right[i], x - siz[left[i]] - count[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">index</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">index</span>(head, x); &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> -INF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key[i] &gt;= val) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">pre</span>(left[i], val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">max</span>(key[i], <span class="built_in">pre</span>(right[i], val));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pre</span>(head, val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">post</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> INF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key[i] &lt;= val) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">post</span>(right[i], val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">min</span>(key[i], <span class="built_in">post</span>(left[i], val));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">post</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">post</span>(head, val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>无词频压缩版本：主要修改 <code>remove</code> 函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="built_in">find</span>(head, val);</span><br><span class="line">  <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">splitByVal</span>(<span class="number">0</span>, <span class="number">0</span>, head, val);</span><br><span class="line">    <span class="type">int</span> lm = right[<span class="number">0</span>], r = left[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">splitByVal</span>(<span class="number">0</span>, <span class="number">0</span>, lm, val - <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> l = right[<span class="number">0</span>], m = left[<span class="number">0</span>];</span><br><span class="line">    head = <span class="built_in">merge</span>(<span class="built_in">merge</span>(l, <span class="built_in">merge</span>(right[m], left[m])), r);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其余 <code>count</code> 数组值改为 1 即可</p>
<h1 id="文艺树"><a href="#文艺树" class="headerlink" title="文艺树"></a>文艺树</h1><p>实现区间反转的 Treap 树</p>
<p>假设要反转区间 $[l,r]$，将树分裂为 $[1,l-1]$，$[l, r]$，$[r+1.n]$ 三部分，给 $[l,r]$ 这棵树进行懒标记，标记下发时，交换该节点的左右子树，最后中序遍历，得到最终的序列。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lazy[i]) &#123;</span><br><span class="line">    std::<span class="built_in">swap</span>(left[i], right[i]);</span><br><span class="line">    lazy[left[i]] = !lazy[left[i]];</span><br><span class="line">    lazy[right[i]] = !lazy[right[i]];</span><br><span class="line">    lazy[i] = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splitByRnk</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> i, <span class="type">int</span> rnk)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">    right[l] = left[r] = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">if</span> (siz[left[i]] + <span class="number">1</span> &lt;= rnk) &#123;</span><br><span class="line">      right[l] = i;</span><br><span class="line">      <span class="built_in">splitByRnk</span>(i, r, right[i], rnk - siz[left[i]] - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      left[r] = i;</span><br><span class="line">      <span class="built_in">splitByRnk</span>(l, i, left[i], rnk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pull</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!l || !r) &#123;</span><br><span class="line">    <span class="keyword">return</span> l + r;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (priority[l] &gt;= priority[r]) &#123;</span><br><span class="line">    <span class="built_in">push</span>(l);</span><br><span class="line">    right[l] = <span class="built_in">merge</span>(right[l], r);</span><br><span class="line">    <span class="built_in">pull</span>(l);</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">push</span>(r);</span><br><span class="line">    left[r] = <span class="built_in">merge</span>(l, left[r]);</span><br><span class="line">    <span class="built_in">pull</span>(r);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">push</span>(i);</span><br><span class="line">    <span class="built_in">inorder</span>(left[i]);</span><br><span class="line">    std::cout &lt;&lt; key[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">inorder</span>(right[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">inorder</span>(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>‍</p>
<!-- From: 数据结构\有序表\跳表.md -->


<h1 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h1><h1 id="模板-5"><a href="#模板-5" class="headerlink" title="模板"></a>模板</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SkipList</span> &#123;</span><br><span class="line">  std::random_device rd;</span><br><span class="line">  std::mt19937 gen;</span><br><span class="line">  std::uniform_real_distribution&lt;<span class="type">double</span>&gt; dis;</span><br><span class="line">  <span class="type">int</span> MAXN, MAXL;</span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; key, count, level;</span><br><span class="line">  std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; next, len;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SkipList</span>(<span class="type">int</span> _n) : <span class="built_in">MAXN</span>(_n + <span class="number">1</span>), <span class="built_in">MAXL</span>(std::__lg(_n) + <span class="number">1</span>), <span class="built_in">gen</span>(<span class="built_in">rd</span>()), <span class="built_in">dis</span>(<span class="number">0.0</span>, <span class="number">1.0</span>), <span class="built_in">cnt</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    key.<span class="built_in">resize</span>(MAXN);</span><br><span class="line">    count.<span class="built_in">resize</span>(MAXN);</span><br><span class="line">    level.<span class="built_in">resize</span>(MAXN);</span><br><span class="line">    next.<span class="built_in">resize</span>(MAXN, std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(MAXL + <span class="number">1</span>));</span><br><span class="line">    len.<span class="built_in">resize</span>(MAXN, std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(MAXL + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    key[cnt] = INT_MIN;</span><br><span class="line">    level[cnt] = MAXL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">fill</span>(key.<span class="built_in">begin</span>(), key.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    std::<span class="built_in">fill</span>(count.<span class="built_in">begin</span>(), count.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    std::<span class="built_in">fill</span>(level.<span class="built_in">begin</span>(), level.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    std::for_each(next.<span class="built_in">begin</span>(), next.<span class="built_in">end</span>(), [&amp;](<span class="keyword">auto</span> &amp;vec) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">      std::<span class="built_in">fill</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    std::for_each(len.<span class="built_in">begin</span>(), len.<span class="built_in">end</span>(), [&amp;](<span class="keyword">auto</span> &amp;vec) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">      std::<span class="built_in">fill</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">randomLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">dis</span>(gen) &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">      ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">min</span>(ans, MAXL);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> h, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (next[p][h] &amp;&amp; key[next[p][h]] &lt; num) &#123;</span><br><span class="line">      p = next[p][h];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (next[p][h] &amp;&amp; key[next[p][h]] == num) &#123;</span><br><span class="line">        <span class="keyword">return</span> next[p][h];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(p, h - <span class="number">1</span>, num);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">addCound</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> h, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (next[p][h] &amp;&amp; key[next[p][h]] &lt; num) &#123;</span><br><span class="line">      p = next[p][h];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">1</span>) &#123;</span><br><span class="line">      count[next[p][h]]++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">addCound</span>(p, h - <span class="number">1</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">    len[p][h]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">addNode</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> h, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rightCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (next[p][h] &amp;&amp; key[next[p][h]] &lt; key[q]) &#123;</span><br><span class="line">      rightCnt += len[p][h];</span><br><span class="line">      p = next[p][h];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">1</span>) &#123;</span><br><span class="line">      next[q][h] = next[p][h];</span><br><span class="line">      next[p][h] = q;</span><br><span class="line">      len[q][h] = count[next[q][h]];</span><br><span class="line">      len[p][h] = count[next[p][h]];</span><br><span class="line">      <span class="keyword">return</span> rightCnt;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">int</span> downCnt = <span class="built_in">addNode</span>(p, h - <span class="number">1</span>, q);</span><br><span class="line">      <span class="keyword">if</span> (h &gt; level[q]) &#123;</span><br><span class="line">        len[p][h]++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next[q][h] = next[p][h];</span><br><span class="line">        next[p][h] = q;</span><br><span class="line">        len[q][h] = len[p][h] + <span class="number">1</span> - downCnt - count[q];</span><br><span class="line">        len[p][h] = downCnt + count[q];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> rightCnt + downCnt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(<span class="number">1</span>, MAXL, num) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">addCound</span>(<span class="number">1</span>, MAXL, num);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      key[++cnt] = num;</span><br><span class="line">      count[cnt] = <span class="number">1</span>;</span><br><span class="line">      level[cnt] = <span class="built_in">randomLevel</span>();</span><br><span class="line">      <span class="built_in">addNode</span>(<span class="number">1</span>, MAXL, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">removeCount</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> h, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (next[p][h] &amp;&amp; key[next[p][h]] &lt; num) &#123;</span><br><span class="line">      p = next[p][h];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">1</span>) &#123;</span><br><span class="line">      count[next[p][h]]--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">removeCount</span>(p, h - <span class="number">1</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">    len[p][h]--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">removeNode</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> h, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span> (next[p][h] &amp;&amp; key[next[p][h]] &lt; key[q]) &#123;</span><br><span class="line">      p = next[p][h];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h &gt; level[q]) &#123;</span><br><span class="line">      len[p][h]--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      next[p][h] = next[q][h];</span><br><span class="line">      len[p][h] += len[q][h] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">removeNode</span>(p, h - <span class="number">1</span>, q);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> q = <span class="built_in">find</span>(<span class="number">1</span>, MAXL, num);</span><br><span class="line">    <span class="keyword">if</span> (q) &#123;</span><br><span class="line">      <span class="keyword">if</span> (count[q] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">removeCount</span>(<span class="number">1</span>, MAXL, num);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">removeNode</span>(<span class="number">1</span>, MAXL, q);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">smallCount</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> h, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rightCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (next[p][h] &amp;&amp; key[next[p][h]] &lt; num) &#123;</span><br><span class="line">      rightCnt += len[p][h];</span><br><span class="line">      p = next[p][h];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">1</span>) <span class="keyword">return</span> rightCnt;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> rightCnt + <span class="built_in">smallCount</span>(p, h - <span class="number">1</span>, num);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getRank</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">smallCount</span>(<span class="number">1</span>, MAXL, num) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">findByIndex</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> h, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (next[p][h] &amp;&amp; c + len[p][h] &lt; x) &#123;</span><br><span class="line">      c += len[p][h];</span><br><span class="line">      p = next[p][h];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">1</span>) <span class="keyword">return</span> key[next[p][h]];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">findByIndex</span>(p, h - <span class="number">1</span>, x - c);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">index</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">findByIndex</span>(<span class="number">1</span>, MAXL, x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getPre</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> h, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (next[p][h] &amp;&amp; key[next[p][h]] &lt; num) &#123;</span><br><span class="line">      p = next[p][h];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">1</span>) <span class="keyword">return</span> (p == <span class="number">1</span> ? INT_MIN : key[p]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">getPre</span>(p, h - <span class="number">1</span>, num);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getPre</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getPre</span>(<span class="number">1</span>, MAXL, num);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getPost</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> h, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (next[p][h] &amp;&amp; key[next[p][h]] &lt; num) &#123;</span><br><span class="line">      p = next[p][h];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!next[p][h]) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">      <span class="keyword">if</span> (key[next[p][h]] &gt; num) <span class="keyword">return</span> key[next[p][h]];</span><br><span class="line">      p = next[p][h];</span><br><span class="line">      <span class="keyword">if</span> (!next[p][h]) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> key[next[p][h]];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">getPost</span>(p, h - <span class="number">1</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getPost</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getPost</span>(<span class="number">1</span>, MAXL, num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<!-- From: 数据结构\线段树\README.md -->


<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><h1 id="单点修改，区间查询"><a href="#单点修改，区间查询" class="headerlink" title="单点修改，区间查询"></a>单点修改，区间查询</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Info&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Segment_Tree</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> T = <span class="keyword">typename</span> Info::_vt;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;Info&gt; info;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">int</span> __lg(_Tp __n) &#123;</span><br><span class="line">        <span class="keyword">constexpr</span> <span class="type">int</span> _BIT_WIDTH = <span class="built_in">sizeof</span>(_Tp) * __CHAR_BIT__;</span><br><span class="line">        <span class="keyword">return</span> _BIT_WIDTH - <span class="number">1</span> - __builtin_clz(__n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Segment_Tree</span>() : <span class="built_in">n</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Segment_Tree</span>(<span class="type">int</span> n_, Info v_ = <span class="built_in">Info</span>()) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n_, v_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="built_in">Segment_Tree</span>(std::vector&lt;U&gt; init_) &#123;</span><br><span class="line">        <span class="built_in">init</span>(init_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n_, Info v_ = Info())</span> </span>&#123;</span><br><span class="line">        <span class="built_in">init</span>(std::<span class="built_in">vector</span>(n_, v_));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(std::vector&lt;U&gt; init_)</span> </span>&#123;</span><br><span class="line">        n = init_.<span class="built_in">size</span>();</span><br><span class="line">        info.<span class="built_in">assign</span>(<span class="number">4</span> &lt;&lt; __lg(n), <span class="built_in">Info</span>());</span><br><span class="line">        std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; build = [&amp;](<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">                info[p] = init_[l];</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, m);</span><br><span class="line">            <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m, r);</span><br><span class="line">            <span class="built_in">pull</span>(p);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        info[p] = info[p &lt;&lt; <span class="number">1</span>] + info[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">const</span> Info &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; x || r &lt;= x) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">            info[p] = v;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">modify</span>(p &lt;&lt; <span class="number">1</span>, l, m, x, v);</span><br><span class="line">            <span class="built_in">modify</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m, r, x, v);</span><br><span class="line">            <span class="built_in">pull</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">const</span> Info &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">0</span>, n, x, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x) <span class="keyword">return</span> <span class="built_in">Info</span>();</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) <span class="keyword">return</span> info[p];</span><br><span class="line">        <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeQuery</span>(p &lt;&lt; <span class="number">1</span>, l, m, x, y) + <span class="built_in">rangeQuery</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m, r, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeQuery</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findFirst</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, F &amp;&amp;pred)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y &amp;&amp; !<span class="built_in">pred</span>(info[p])) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">findFirst</span>(p &lt;&lt; <span class="number">1</span>, l, m, x, y, pred);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">            res = <span class="built_in">findFirst</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m, r, x, y, pred);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findFirst</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, F &amp;&amp;pred)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findFirst</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r, pred);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLast</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, F &amp;&amp;pred)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y &amp;&amp; !<span class="built_in">pred</span>(info[p])) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">findLast</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m, r, x, y, pred);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">            res = <span class="built_in">findLast</span>(p &lt;&lt; <span class="number">1</span>, l, m, x, y, pred);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLast</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, F &amp;&amp;pred)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findLast</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r, pred);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> _vt = T;</span><br><span class="line"></span><br><span class="line">    T g = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Info</span>(T g = <span class="number">0</span>) : <span class="built_in">g</span>(g) &#123;&#125;</span><br><span class="line">    Info <span class="keyword">operator</span>+(<span class="type">const</span> Info &amp;other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;g + other.g&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="区间修改，区间查询"><a href="#区间修改，区间查询" class="headerlink" title="区间修改，区间查询"></a>区间修改，区间查询</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Info&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Segment_Tree2</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> T = <span class="keyword">typename</span> Info::_vt;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;Info&gt; info;</span><br><span class="line">    std::vector&lt;T&gt; lazy;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">int</span> __lg(_Tp __n) &#123;</span><br><span class="line">        <span class="keyword">constexpr</span> <span class="type">int</span> _BIT_WIDTH = <span class="built_in">sizeof</span>(_Tp) * __CHAR_BIT__;</span><br><span class="line">        <span class="keyword">return</span> _BIT_WIDTH - <span class="number">1</span> - __builtin_clz(__n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Segment_Tree2</span>() : <span class="built_in">n</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Segment_Tree2</span>(<span class="type">int</span> n_, Info v_ = <span class="built_in">Info</span>()) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n_, v_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="built_in">Segment_Tree2</span>(std::vector&lt;U&gt; init_) &#123;</span><br><span class="line">        <span class="built_in">init</span>(init_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n_, Info v_ = Info())</span> </span>&#123;</span><br><span class="line">        <span class="built_in">init</span>(std::<span class="built_in">vector</span>(n_, v_));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(std::vector&lt;U&gt; init_)</span> </span>&#123;</span><br><span class="line">        n = init_.<span class="built_in">size</span>();</span><br><span class="line">        info.<span class="built_in">assign</span>(<span class="number">4</span> &lt;&lt; __lg(n), <span class="built_in">Info</span>());</span><br><span class="line">        lazy.<span class="built_in">assign</span>(<span class="number">4</span> &lt;&lt; __lg(n), <span class="number">0</span>);</span><br><span class="line">        std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; build = [&amp;](<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">                info[p] = init_[l];</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, m);</span><br><span class="line">            <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m, r);</span><br><span class="line">            <span class="built_in">pull</span>(p);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Lazy</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">const</span> T &amp; v)</span> </span>&#123;</span><br><span class="line">        info[p].g += (r - l) * v;</span><br><span class="line">        lazy[p] += v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        info[p] = info[p &lt;&lt; <span class="number">1</span>] + info[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazy[p] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">Lazy</span>(p &lt;&lt; <span class="number">1</span>, l, m, lazy[p]);</span><br><span class="line">            <span class="built_in">Lazy</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m, r, lazy[p]);</span><br><span class="line">            lazy[p] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Info &amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">            <span class="built_in">Lazy</span>(p, l, r, v.g);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">apply</span>(p, l, r);</span><br><span class="line">            <span class="built_in">modify</span>(p &lt;&lt; <span class="number">1</span>, l, m, x, y, v);</span><br><span class="line">            <span class="built_in">modify</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m, r, x, y, v);</span><br><span class="line">            <span class="built_in">pull</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Info &amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">0</span>, n, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">const</span> Info &amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">0</span>, n, p, p + <span class="number">1</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x) <span class="keyword">return</span> <span class="built_in">Info</span>();</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) <span class="keyword">return</span> info[p];</span><br><span class="line">        <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">apply</span>(p, l, r);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeQuery</span>(p &lt;&lt; <span class="number">1</span>, l, m, x, y) + <span class="built_in">rangeQuery</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m, r, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeQuery</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findFirst</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, F &amp;&amp;pred)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y &amp;&amp; !<span class="built_in">pred</span>(info[p])) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">findFirst</span>(p &lt;&lt; <span class="number">1</span>, l, m, x, y, pred);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">            res = <span class="built_in">findFirst</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m, r, x, y, pred);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findFirst</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, F &amp;&amp;pred)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findFirst</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r, pred);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLast</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, F &amp;&amp;pred)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y &amp;&amp; !<span class="built_in">pred</span>(info[p])) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">findLast</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m, r, x, y, pred);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">            res = <span class="built_in">findLast</span>(p &lt;&lt; <span class="number">1</span>, l, m, x, y, pred);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLast</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, F &amp;&amp;pred)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findLast</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r, pred);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> _vt = T;</span><br><span class="line">    T g = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Info</span>(T g = <span class="number">0</span>) : <span class="built_in">g</span>(g) &#123;&#125;</span><br><span class="line">    Info <span class="keyword">operator</span>+(<span class="type">const</span> Info &amp;other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;g + other.g&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="动态开点线段树"><a href="#动态开点线段树" class="headerlink" title="动态开点线段树"></a>动态开点线段树</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point_Update_Segment_Tree</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        T g = <span class="number">0</span>, lazy = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    i64 n;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    std::vector&lt;Node&gt; info;</span><br><span class="line">    <span class="built_in">Point_Update_Segment_Tree</span>(i64 n) : <span class="built_in">n</span>(n), <span class="built_in">cnt</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        info.<span class="built_in">assign</span>(<span class="number">2</span>, &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lazy</span><span class="params">(<span class="type">int</span> p, i64 l, i64 r, <span class="type">const</span> T &amp; v)</span> </span>&#123;</span><br><span class="line">        info[p].g += v * (r - l);</span><br><span class="line">        info[p].lazy += v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        info[p].g = info[l].g + info[r].g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">int</span> p, i64 l, i64 r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (info[p].lazy) &#123;</span><br><span class="line">            <span class="keyword">if</span> (info[p].l == <span class="number">0</span>) &#123;</span><br><span class="line">                info.<span class="built_in">emplace_back</span>();</span><br><span class="line">                info[p].l = ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (info[p].r == <span class="number">0</span>) &#123;</span><br><span class="line">                info.<span class="built_in">emplace_back</span>();</span><br><span class="line">                info[p].r = ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            i64 m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">lazy</span>(info[p].l, l, m, info[p].lazy);</span><br><span class="line">            <span class="built_in">lazy</span>(info[p].r, m, r, info[p].lazy);</span><br><span class="line">            info[p].lazy = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, i64 l, i64 r, i64 x, i64 y, <span class="type">const</span> T &amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">            <span class="built_in">lazy</span>(p, l, r, v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i64 m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">apply</span>(p, l, r);</span><br><span class="line">            <span class="keyword">if</span> (x &lt; m) &#123;</span><br><span class="line">                <span class="keyword">if</span> (info[p].l == <span class="number">0</span>) &#123;</span><br><span class="line">                    info.<span class="built_in">emplace_back</span>();</span><br><span class="line">                    info[p].l = ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">modify</span>(info[p].l, l, m, x, y, v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (y &gt; m) &#123;</span><br><span class="line">                <span class="keyword">if</span> (info[p].r == <span class="number">0</span>) &#123;</span><br><span class="line">                    info.<span class="built_in">emplace_back</span>();</span><br><span class="line">                    info[p].r = ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">modify</span>(info[p].r, m, r, x, y, v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">pull</span>(p, info[p].l, info[p].r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(i64 x, i64 y, <span class="type">const</span> T &amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">0</span>, n, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(i64 p, <span class="type">const</span> T &amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">0</span>, n, p, p + <span class="number">1</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> p, i64 l, i64 r, i64 x, i64 y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) <span class="keyword">return</span> info[p].g;</span><br><span class="line">        i64 m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">apply</span>(p, l, r);</span><br><span class="line">        T ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; m &amp;&amp; info[p].l) &#123;</span><br><span class="line">            ans += <span class="built_in">rangeQuery</span>(info[p].l, l, m, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (y &gt; m &amp;&amp; info[p].r) &#123;</span><br><span class="line">            ans += <span class="built_in">rangeQuery</span>(info[p].r, m, r, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">rangeQuery</span><span class="params">(i64 l, i64 r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeQuery</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="吉如一线段树"><a href="#吉如一线段树" class="headerlink" title="吉如一线段树"></a>吉如一线段树</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">JiRuYi_Segment_tree</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> cn info[p]</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> ln info[p &lt;&lt; 1]</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> rn info[p &lt;&lt; 1 | 1]</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> T T_MIN = std::numeric_limits&lt;T&gt;::<span class="built_in">min</span>();</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        T mx = <span class="number">0</span>, cnt = <span class="number">0</span>, secmx = T_MIN, sum = <span class="number">0</span>;</span><br><span class="line">        T mxadd = <span class="number">0</span>, othadd = <span class="number">0</span>;</span><br><span class="line">        T mxhis = <span class="number">0</span>, mxaddtop = <span class="number">0</span>, othaddtop = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::vector&lt;Node&gt; info;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">int</span> __lg(_Tp __n) &#123;</span><br><span class="line">        <span class="keyword">constexpr</span> <span class="type">int</span> _BIT_WIDTH = <span class="built_in">sizeof</span>(_Tp) * __CHAR_BIT__;</span><br><span class="line">        <span class="keyword">return</span> _BIT_WIDTH - <span class="number">1</span> - __builtin_clz(__n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">chmax</span><span class="params">(T &amp;a, <span class="type">const</span> T b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">            a = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">JiRuYi_Segment_tree</span>() : <span class="built_in">n</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">JiRuYi_Segment_tree</span>(<span class="type">int</span> n_, T v_ = T&#123;&#125;) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n_, v_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">JiRuYi_Segment_tree</span>(std::vector&lt;T&gt; init_) &#123;</span><br><span class="line">        <span class="built_in">init</span>(init_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n_, T v_ = T&#123;&#125;)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">init</span>(std::<span class="built_in">vector</span>(n_, v_));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(std::vector&lt;T&gt; init_)</span> </span>&#123;</span><br><span class="line">        n = init_.<span class="built_in">size</span>();</span><br><span class="line">        info.<span class="built_in">assign</span>(<span class="number">4</span> &lt;&lt; __lg(n), Node&#123;&#125;);</span><br><span class="line">        std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; build = [&amp;](<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">                cn.mx = cn.mxhis = cn.sum = init_[l];</span><br><span class="line">                cn.cnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, m);</span><br><span class="line">            <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m, r);</span><br><span class="line">            <span class="built_in">pull</span>(p);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Lazy</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">const</span> T md, <span class="type">const</span> T od, <span class="type">const</span> T mxaddtop, <span class="type">const</span> T othaddtop)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">chmax</span>(cn.mxhis, cn.mx + mxaddtop);</span><br><span class="line">        <span class="built_in">chmax</span>(cn.mxaddtop, cn.mxadd + mxaddtop);</span><br><span class="line">        <span class="built_in">chmax</span>(cn.othaddtop, cn.othadd + othaddtop);</span><br><span class="line">        cn.sum += md * cn.cnt + od * (r - l - cn.cnt);</span><br><span class="line">        cn.mx += md;</span><br><span class="line">        cn.secmx += cn.secmx == T_MIN ? <span class="number">0</span> : od;</span><br><span class="line">        cn.mxadd += md;</span><br><span class="line">        cn.othadd += od;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        cn.sum = ln.sum + rn.sum;</span><br><span class="line">        cn.mx = std::<span class="built_in">max</span>(ln.mx, rn.mx);</span><br><span class="line">        cn.mxhis = std::<span class="built_in">max</span>(ln.mxhis, rn.mxhis);</span><br><span class="line">        <span class="keyword">if</span> (ln.mx &gt; rn.mx) &#123;</span><br><span class="line">            cn.secmx = std::<span class="built_in">max</span>(ln.secmx, rn.mx);</span><br><span class="line">            cn.cnt = ln.cnt;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ln.mx &lt; rn.mx) &#123;</span><br><span class="line">            cn.secmx = std::<span class="built_in">max</span>(ln.mx, rn.secmx);</span><br><span class="line">            cn.cnt = rn.cnt;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cn.secmx = std::<span class="built_in">max</span>(ln.secmx, rn.secmx);</span><br><span class="line">            cn.cnt = ln.cnt + rn.cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        T mx = std::<span class="built_in">max</span>(ln.mx, rn.mx);</span><br><span class="line">        <span class="keyword">if</span> (ln.mx == mx) &#123;</span><br><span class="line">            <span class="built_in">Lazy</span>(p &lt;&lt; <span class="number">1</span>, l, m, cn.mxadd, cn.othadd, cn.mxaddtop, cn.othaddtop);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">Lazy</span>(p &lt;&lt; <span class="number">1</span>, l, m, cn.othadd, cn.othadd, cn.othaddtop, cn.othaddtop);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rn.mx == mx) &#123;</span><br><span class="line">            <span class="built_in">Lazy</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m, r, cn.mxadd, cn.othadd, cn.mxaddtop, cn.othaddtop);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">Lazy</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m, r, cn.othadd, cn.othadd, cn.othaddtop, cn.othaddtop);</span><br><span class="line">        &#125;</span><br><span class="line">        cn.mxadd = cn.othadd = cn.mxaddtop = cn.othaddtop = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setMin</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> T v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cn.mx &lt;= v) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y &amp;&amp; cn.secmx &lt; v) &#123;</span><br><span class="line">            <span class="built_in">Lazy</span>(p, l, r, v - cn.mx, <span class="number">0</span>, v - cn.mx, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">apply</span>(p, l, r);</span><br><span class="line">            <span class="keyword">if</span> (x &lt; m) &#123;</span><br><span class="line">                <span class="built_in">setMin</span>(p &lt;&lt; <span class="number">1</span>, l, m, x, y, v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (y &gt; m) &#123;</span><br><span class="line">                <span class="built_in">setMin</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m, r, x, y, v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">pull</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setMin</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> T v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">setMin</span>(<span class="number">1</span>, <span class="number">0</span>, n, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setMin</span><span class="params">(<span class="type">int</span> p, <span class="type">const</span> T v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">setMin</span>(<span class="number">1</span>, <span class="number">0</span>, n, p, p + <span class="number">1</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rangeAdd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> T v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">            <span class="built_in">Lazy</span>(p, l, r, v, v, v, v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">apply</span>(p, l, r);</span><br><span class="line">            <span class="keyword">if</span> (x &lt; m) &#123;</span><br><span class="line">                <span class="built_in">rangeAdd</span>(p &lt;&lt; <span class="number">1</span>, l, m, x, y, v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (y &gt; m) &#123;</span><br><span class="line">                <span class="built_in">rangeAdd</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m, r, x, y, v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">pull</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rangeAdd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> T v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">rangeAdd</span>(<span class="number">1</span>, <span class="number">0</span>, n, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rangeAdd</span><span class="params">(<span class="type">int</span> p, <span class="type">const</span> T v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">rangeAdd</span>(<span class="number">1</span>, <span class="number">0</span>, n, p, p + <span class="number">1</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">rangeQuery_Max</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x) <span class="keyword">return</span> T_MIN;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) <span class="keyword">return</span> cn.mx;</span><br><span class="line">        <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">apply</span>(p, l, r);</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">max</span>(<span class="built_in">rangeQuery_Max</span>(p &lt;&lt; <span class="number">1</span>, l, m, x, y), <span class="built_in">rangeQuery_Max</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m, r, x, y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">rangeQuery_Max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeQuery_Max</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">rangeQuery_Sum</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) <span class="keyword">return</span> cn.sum;</span><br><span class="line">        <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">apply</span>(p, l, r);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeQuery_Sum</span>(p &lt;&lt; <span class="number">1</span>, l, m, x, y) + <span class="built_in">rangeQuery_Sum</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m, r, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">rangeQuery_Sum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeQuery_Sum</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">rangeQuery_hisMax</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y || r &lt;= x) <span class="keyword">return</span> T_MIN;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) <span class="keyword">return</span> cn.mxhis;</span><br><span class="line">        <span class="type">int</span> m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">apply</span>(p, l, r);</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">max</span>(<span class="built_in">rangeQuery_hisMax</span>(p &lt;&lt; <span class="number">1</span>, l, m, x, y), <span class="built_in">rangeQuery_hisMax</span>(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m, r, x, y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">rangeQuery_hisMax</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeQuery_hisMax</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<!-- From: 数据结构\线段树\线段树分治.md -->


<h1 id="线段树分治"><a href="#线段树分治" class="headerlink" title="线段树分治"></a>线段树分治</h1><p>线段树和离线算法的结合。假如你需要维护一些信息，这些信息会在某一个时间段内出现，要求在离线的前提下回答某一个时刻的信息并，则可以考虑使用线段树分治的技巧。</p>
<p>回顾线段树内容，假如需要维护一个时间轴上的操作，对这个时间轴建立线段树，把在某一时间段生效的操作挂在线段树节点上，在到达当前节点时，添加该节点上保存的操作；在离开该节点时，对于图的连通性问题通常使用<strong>可撤销并查集</strong>，对于其他特殊问题，如果需要维护的数据结构空间复杂度很小，也可以直接保存操作前的状态，离开该节点时再复制回原来的状态。询问操作一般存储在线段树叶节点上。</p>
<h1 id="例题-10"><a href="#例题-10" class="headerlink" title="例题"></a>例题</h1><ol>
<li><p><a target="_blank" rel="noopener" href="https://loj.ac/p/121">loj121 模板题</a></p>
<p> 维护一张图，动态添加一些边，删除一些已经存在的边，查询两个点是否连通</p>
<p> 将操作标记上生效时间，用线段树维护时间轴</p>
<p> 维护一个可撤销并查集</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">  std::map&lt;pii, std::vector&lt;<span class="type">int</span>&gt;&gt; mm;</span><br><span class="line">  std::vector&lt;std::tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> op, x, y;</span><br><span class="line">    cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">if</span> (y &lt; x) &#123;</span><br><span class="line">      std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">0</span> || op == <span class="number">1</span>) &#123;</span><br><span class="line">      mm[&#123;x, y&#125;].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      q.<span class="built_in">emplace_back</span>(x, y, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  std::vector&lt;std::vector&lt;std::tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>&gt;&gt;&gt; <span class="built_in">seg</span>(m &lt;&lt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> modify = [&amp;](<span class="keyword">auto</span> &amp;&amp;self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y,</span><br><span class="line">                    std::tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>&gt; v) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">      seg[p].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= m) &#123;</span><br><span class="line">      <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span>, l, m, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= m + <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function">DSU <span class="title">dsu</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> &amp;&amp;self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y, isq] : seg[p]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isq) <span class="keyword">continue</span>;</span><br><span class="line">      cnt += dsu.<span class="built_in">merge</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y, isq] : seg[p]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isq) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (dsu.<span class="built_in">same</span>(x, y)) &#123;</span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;Y\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;N\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (cnt--) &#123;</span><br><span class="line">        dsu.<span class="built_in">revert</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span>, l, m);</span><br><span class="line">    <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cnt--) &#123;</span><br><span class="line">      dsu.<span class="built_in">revert</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[xy, vec] : mm) &#123;</span><br><span class="line">    <span class="keyword">auto</span> [x, y] = xy;</span><br><span class="line">    <span class="keyword">if</span> (vec.<span class="built_in">size</span>() &amp; <span class="number">1</span>) &#123;</span><br><span class="line">      vec.<span class="built_in">push_back</span>(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i += <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">0</span>, m - <span class="number">1</span>, vec[i], vec[i + <span class="number">1</span>], &#123;x, y, <span class="literal">false</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y, t] : q) &#123;</span><br><span class="line">    <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">0</span>, m - <span class="number">1</span>, t, t, &#123;x, y, <span class="literal">true</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(dfs, <span class="number">1</span>, <span class="number">0</span>, m - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5787">P5787</a></p>
<p> 维护一张图是否是二分图</p>
<p> 维护一个可撤销并查集，用扩展域并查集来判断是否是二分图</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n, m, k;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::vector&lt;pii&gt;&gt; <span class="built_in">seg</span>((k + <span class="number">1</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> modify = [&amp;](<span class="keyword">auto</span> &amp;&amp; self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, pii v) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">      seg[p].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= m) &#123;</span><br><span class="line">      <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span>, l, m, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= m + <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> x, y, l, r;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    l++;</span><br><span class="line">    x--;</span><br><span class="line">    y--;</span><br><span class="line">    <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">0</span>, k, l, r, &#123;x, y&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">DSU <span class="title">dsu</span><span class="params">(n * <span class="number">2</span>)</span></span>;</span><br><span class="line">  <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> &amp;&amp; self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> check = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y] : seg[p]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dsu.<span class="built_in">same</span>(x, y)) &#123;</span><br><span class="line">        check = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cnt += dsu.<span class="built_in">merge</span>(x, y + n);</span><br><span class="line">        cnt += dsu.<span class="built_in">merge</span>(x + n, y);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">      <span class="keyword">if</span> (l &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (check) &#123;</span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (cnt--) &#123;</span><br><span class="line">        dsu.<span class="built_in">revert</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!check) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (cnt--) &#123;</span><br><span class="line">        dsu.<span class="built_in">revert</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span>, l, m);</span><br><span class="line">    <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cnt--) &#123;</span><br><span class="line">      dsu.<span class="built_in">revert</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dfs</span>(dfs, <span class="number">1</span>, <span class="number">0</span>, k);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5631">P5631</a></p>
<p> 找出一张图的最小 mex 树</p>
<p> 按照边权值轴建立线段树，如果一条边的权值为 w，那么就设置它的生效时间为 $[0,w-1],[w+1,w_{max}]$，依次检查每个 $w$ 时刻能否让图连通</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// std::ios::sync_with_stdio(false);</span></span><br><span class="line">  <span class="comment">// std::cin.tie(nullptr);</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  <span class="comment">// cin &gt;&gt; n &gt;&gt; m;</span></span><br><span class="line">  <span class="built_in">read</span>(n);</span><br><span class="line">  <span class="built_in">read</span>(m);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> W = <span class="number">100&#x27;000</span> + <span class="number">1</span>;</span><br><span class="line">  std::vector&lt;std::vector&lt;pii&gt;&gt; <span class="built_in">seg</span>((W + <span class="number">1</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> modify = [&amp;](<span class="keyword">auto</span> &amp;&amp;self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y,</span><br><span class="line">                    pii v) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">      seg[p].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= m) &#123;</span><br><span class="line">      <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span>, l, m, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= m + <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">read</span>(u);</span><br><span class="line">    <span class="built_in">read</span>(v);</span><br><span class="line">    <span class="built_in">read</span>(w);</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">continue</span>;</span><br><span class="line">    u--;</span><br><span class="line">    v--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (w - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">0</span>, W, <span class="number">0</span>, w - <span class="number">1</span>, &#123;u, v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">0</span>, W, w + <span class="number">1</span>, W, &#123;u, v&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">DSU <span class="title">dsu</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="type">int</span> cnt = n;</span><br><span class="line">  <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y] : seg[p]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dsu.<span class="built_in">same</span>(x, y)) <span class="keyword">continue</span>;</span><br><span class="line">      dsu.<span class="built_in">merge</span>(x, y);</span><br><span class="line">      t++;</span><br><span class="line">      cnt--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cnt == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(l, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      cnt += t;</span><br><span class="line">      <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        dsu.<span class="built_in">revert</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span>, l, m);</span><br><span class="line">    <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    cnt += t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">      dsu.<span class="built_in">revert</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dfs</span>(dfs, <span class="number">1</span>, <span class="number">0</span>, W);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1681/F">CF1681F</a></p>
<p> 给定一棵树，树边设置权值，$f(u,v)$ 为 $u,v$ 两点间简单路径上边权只出现一次的边权个数，同样按照边权值建立线段树，统计每条边的贡献。如果当前来到线段树叶节点 $w$，检查 $w$ 权值的所有边，由于原图是一棵树，能保证枚举当前边时，边左右两个端点的连通块一定不同，且只有当前边能让它们连通，$siz[u]\times siz[v]$ 即为当前边的贡献。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::vector&lt;pii&gt;&gt; <span class="built_in">seg</span>((n + <span class="number">1</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> modify = [&amp;](<span class="keyword">auto</span> &amp;&amp; self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, pii v) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">      seg[p].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= m) &#123;</span><br><span class="line">      <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span>, l, m, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= m + <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::vector&lt;pii&gt;&gt; <span class="built_in">e</span>(n + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> u, v, x;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v &gt;&gt; x;</span><br><span class="line">    u--;</span><br><span class="line">    v--;</span><br><span class="line">    e[x].<span class="built_in">emplace_back</span>(u, v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, x - <span class="number">1</span>, &#123;u, v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; n) &#123;</span><br><span class="line">      <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">1</span>, n, x + <span class="number">1</span>, n, &#123;u, v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">DSU <span class="title">dsu</span><span class="params">(n)</span></span>;</span><br><span class="line">  i64 ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> &amp;&amp; self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y] : seg[p]) &#123;</span><br><span class="line">      t += dsu.<span class="built_in">merge</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y] : e[l]) &#123;</span><br><span class="line">        ans += <span class="number">1LL</span> * dsu.<span class="built_in">size</span>(x) * dsu.<span class="built_in">size</span>(y);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        dsu.<span class="built_in">revert</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span>, l, m);</span><br><span class="line">    <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">      dsu.<span class="built_in">revert</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dfs</span>(dfs, <span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4219">P4219</a></p>
<p> 思路同上一题</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">  std::map&lt;pii, std::vector&lt;<span class="type">int</span>&gt;&gt; mm;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">haveq</span><span class="params">(m)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    cin &gt;&gt; op &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    u--;</span><br><span class="line">    v--;</span><br><span class="line">    <span class="keyword">if</span> (u &gt; v) &#123;</span><br><span class="line">      std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mm[&#123;u, v&#125;].<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">      haveq[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  std::vector&lt;std::vector&lt;std::tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>&gt;&gt;&gt; <span class="built_in">seg</span>(m &lt;&lt; <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">auto</span> modify = [&amp;](<span class="keyword">auto</span> &amp;&amp; self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> std::tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>&gt; &amp;v) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">      seg[p].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= m) &#123;</span><br><span class="line">      <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span>, l, m, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= m + <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[edge, vec] : mm) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vec.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">1</span>, m, vec.<span class="built_in">front</span>(), m, &#123;edge.fi, edge.se, <span class="literal">false</span>&#125;);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">1</span>, m, vec[<span class="number">0</span>], vec[<span class="number">1</span>] - <span class="number">1</span>, &#123;edge.fi, edge.se, <span class="literal">false</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (vec[i] + <span class="number">1</span> &lt;= vec[i + <span class="number">1</span>] - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">1</span>, m, vec[i] + <span class="number">1</span>, vec[i + <span class="number">1</span>] - <span class="number">1</span>, &#123;edge.fi, edge.se, <span class="literal">false</span>&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vec.<span class="built_in">back</span>() &lt; m) &#123;</span><br><span class="line">      <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">1</span>, m, vec.<span class="built_in">back</span>() + <span class="number">1</span>, m, &#123;edge.fi, edge.se, <span class="literal">false</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">1</span>, m, vec[i], vec[i], &#123;edge.fi, edge.se, <span class="literal">true</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">DSU <span class="title">dsu</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> &amp;&amp; self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[x, y, isq] : seg[p]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isq) <span class="keyword">continue</span>;</span><br><span class="line">      t += dsu.<span class="built_in">merge</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[x, y, isq] : seg[p]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isq) <span class="keyword">continue</span>;</span><br><span class="line">        cout &lt;&lt; <span class="number">1LL</span> * dsu.<span class="built_in">size</span>(x) * dsu.<span class="built_in">size</span>(y) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        dsu.<span class="built_in">revert</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span>, l, m);</span><br><span class="line">    <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">      dsu.<span class="built_in">revert</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dfs</span>(dfs, <span class="number">1</span>, <span class="number">1</span>, m);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5227">P5227</a></p>
<p> 模板题</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n, m;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;pii&gt; e;</span><br><span class="line">  e.<span class="built_in">reserve</span>(m);</span><br><span class="line">  std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">opt</span>(m);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    u--;</span><br><span class="line">    v--;</span><br><span class="line">    e.<span class="built_in">emplace_back</span>(u, v);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> k;</span><br><span class="line">  cin &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">      <span class="type">int</span> x;</span><br><span class="line">      cin &gt;&gt; x;</span><br><span class="line">      x--;</span><br><span class="line">      opt[x].<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">seg</span>((k + <span class="number">1</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> modify = [&amp;](<span class="keyword">auto</span> &amp;&amp; self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> v) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">      seg[p].<span class="built_in">emplace_back</span>(v);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= m) &#123;</span><br><span class="line">      <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span>, l, m, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= m + <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> siz = opt[i].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (siz == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">0</span>, k, <span class="number">0</span>, k, i);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">0</span>, k, <span class="number">0</span>, opt[i][<span class="number">0</span>] - <span class="number">1</span>, i);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; siz - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (opt[i][j] + <span class="number">1</span> &lt;= opt[i][j + <span class="number">1</span>] - <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">0</span>, k, opt[i][j] + <span class="number">1</span>, opt[i][j + <span class="number">1</span>] - <span class="number">1</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (opt[i][siz - <span class="number">1</span>] + <span class="number">1</span> &lt;= k) &#123;</span><br><span class="line">          <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">0</span>, k, opt[i][siz - <span class="number">1</span>] + <span class="number">1</span>, k, i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">DSU <span class="title">dsu</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> &amp;&amp; self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : seg[p]) &#123;</span><br><span class="line">      <span class="keyword">auto</span> [x, y] = e[i];</span><br><span class="line">      t += dsu.<span class="built_in">merge</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">      <span class="keyword">if</span> (l &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dsu.<span class="built_in">size</span>(<span class="number">0</span>) == n) &#123;</span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;Connected\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;Disconnected\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        dsu.<span class="built_in">revert</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span>, l, m);</span><br><span class="line">    <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">      dsu.<span class="built_in">revert</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dfs</span>(dfs, <span class="number">1</span>, <span class="number">0</span>, k);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/576/E">CF576E</a></p>
<p> 初始给定一张图，边没有颜色，每次操作将边染上一种指定颜色，操作后，判断所有颜色中仅由该种颜色形成的图是否是二分图，如果是，保留操作，否则撤销这次操作。</p>
<p> 由于不合法则撤销，所以能保证每种颜色的边组成的图始终是二分图。如果将一条边由原来的 $old$ 色变为 $new$ 色，可以确保如果操作成功后，$old$ 色减少一条边，仍是二分图，所以我们只需要判断 $new$ 色的边加入当前一条新边后是否是二分图即可。</p>
<p> 该题目难点在于当前操作有可能被撤销，从而维持当前边之前的颜色。我们先按照经典的方式将所有操作加入时间轴线段树中，同时维护一个 $last$ 数组，表示 $last_i$ 为第 $i$ 条边上次的颜色，每次对边的染色操作从 $last_i$ 取出颜色，如果发现当前操作染色成功，则 $last_i&#x3D;new$，否则不变。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n, m, k, q;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;pii&gt; e;</span><br><span class="line">  e.<span class="built_in">reserve</span>(m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    u--;</span><br><span class="line">    v--;</span><br><span class="line">    <span class="keyword">if</span> (u &gt; v) &#123;</span><br><span class="line">      std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    e.<span class="built_in">emplace_back</span>(u, v);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">last</span><span class="params">(m, <span class="number">-1</span>)</span></span>;</span><br><span class="line">  std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">seg</span>(q &lt;&lt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;pii&gt; <span class="title">query</span><span class="params">(q)</span></span>;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">opt</span><span class="params">(m, <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> modify = [&amp;](<span class="keyword">auto</span> &amp;&amp; self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> v) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">      seg[p].<span class="built_in">push_back</span>(v);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= m) &#123;</span><br><span class="line">      <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span>, l, m, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= m + <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r, x, y, v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">    <span class="type">int</span> x, color;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; color;</span><br><span class="line">    x--;</span><br><span class="line">    color--;</span><br><span class="line">    query[i] = &#123;x, color&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (~opt[x]) &#123;</span><br><span class="line">      <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">0</span>, q - <span class="number">1</span>, opt[x] + <span class="number">1</span>, i, x);</span><br><span class="line">    &#125;</span><br><span class="line">    opt[x] = i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (opt[i] &lt; q - <span class="number">1</span> &amp;&amp; opt[i] != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="built_in">modify</span>(modify, <span class="number">1</span>, <span class="number">0</span>, q - <span class="number">1</span>, opt[i] + <span class="number">1</span>, q - <span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;DSU&gt; <span class="title">dsu</span><span class="params">(k, DSU(n * <span class="number">2</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> &amp;&amp; self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; change;</span><br><span class="line">    change.<span class="built_in">reserve</span>(<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> edge : seg[p]) &#123;</span><br><span class="line">      <span class="keyword">auto</span> [x, y] = e[edge];</span><br><span class="line">      <span class="type">int</span> color = last[edge];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (color == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">      t += dsu[color].<span class="built_in">merge</span>(x, y + n);</span><br><span class="line">      t += dsu[color].<span class="built_in">merge</span>(x + n, y);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        change.<span class="built_in">push_back</span>(color);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">      <span class="keyword">auto</span> [x, color] = query[l];</span><br><span class="line">      <span class="keyword">auto</span> [u, v] = e[x];</span><br><span class="line">      <span class="type">int</span> nw = color;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">auto</span> &amp;d = dsu[nw];</span><br><span class="line">      <span class="keyword">if</span> (d.<span class="built_in">same</span>(u, v)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">        last[x] = nw;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> c : change) &#123;</span><br><span class="line">        dsu[c].<span class="built_in">revert</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span>, l, m);</span><br><span class="line">    <span class="built_in">self</span>(self, p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, m + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> c : change) &#123;</span><br><span class="line">      dsu[c].<span class="built_in">revert</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dfs</span>(dfs, <span class="number">1</span>, <span class="number">0</span>, q - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>‍</p>
<!-- From: 数据结构\莫队.md -->


<h1 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h1><h1 id="普通莫队算法"><a href="#普通莫队算法" class="headerlink" title="普通莫队算法"></a>普通莫队算法</h1><p>假设有数据量 $n$ 和 询问次数  $q$，如果答案可以从 $[l,r]$ $O(1)$ 地扩展到与 $[l,r]$ 相邻的区间（$[l\pm 1,r],[l,r\pm 1]$），则可通过离线算法，在  $O(n\sqrt{n})$ 时间复杂度内求出所有询问的答案。</p>
<h2 id="过程-4"><a href="#过程-4" class="headerlink" title="过程"></a>过程</h2><p>对所有询问排序，顺序处理所有询问，暴力处理相邻的询问。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>$l$ 所在块号为第一关键字，$r$ 为第二关键字。</p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>设 $n$，$q$ 同阶，共有 $\sqrt{n}$ 个块，设每个块中询问 $l$ 的最大值为 ${max_1, max_2,\dots,max_{\sqrt{n}}}$，可知为递增序，$r$ 在每个块中单调递增，总转移复杂度为 $O(n\sqrt n)$，对于 $l$ ，最坏情况下在同一块 $i$ 中，单词询问复杂度为 $max_i - max_{i - 1}$，平均转移 $O(\sqrt n)$ 次，则 $l$ 转移总次数为 $\sqrt{n}((max_1 - 0) + (max_2 - max_1) + (max_3 - max_2)+\dots+(max_{\sqrt{n}}-max_{\sqrt{n}-1}))&#x3D;\sqrt{n}\cdot max_{\sqrt n}&#x3D;O(n\sqrt{n})$ 。</p>
<p>如果 $m$ 与 $n$ 不同阶：<br>假设块长为 $S$，那么 $l$ 总共移动 $mS$ 次，$r$ 总共移动 $\frac{n}{S}\cdot n$ 次，则时间复杂度为 $O(\frac{n^2}{S}+mS)$，求导得 $S&#x3D;\frac{n}{\sqrt m}$ 时，复杂度最小。</p>
<h3 id="普通莫队优化"><a href="#普通莫队优化" class="headerlink" title="普通莫队优化"></a>普通莫队优化</h3><p>分奇偶排序，在奇偶块之间过度时，$r$ 最多只需要移动 $n$ 次。</p>
<h1 id="带修改的莫队"><a href="#带修改的莫队" class="headerlink" title="带修改的莫队"></a>带修改的莫队</h1><p>存储询问时，带上时间戳，从三个维度对询问进行排序，时间戳标记的是第几次修改后的数据。这样在每个维度 $\pm 1$ 的过程仍可以 $O(1)$ 求得。</p>
<h2 id="最优块长"><a href="#最优块长" class="headerlink" title="最优块长"></a>最优块长</h2><p>在 $n,m,t$ 同阶的情况下：</p>
<p>$$<br>n^{\frac{2}{3<br>}}<br>$$</p>
<p>‍</p>
<!-- From: 杂项\README.md -->


<h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><p>‍</p>
<!-- From: 杂项\分块专题\README.md -->


<h1 id="分块专题"><a href="#分块专题" class="headerlink" title="分块专题"></a>分块专题</h1><p>‍</p>
<!-- From: 杂项\分块专题\块状数组 块状链表.md -->


<h1 id="1-块状数组-块状链表"><a href="#1-块状数组-块状链表" class="headerlink" title="1.块状数组 块状链表"></a>1.块状数组 块状链表</h1><p>‍</p>
<!-- From: 杂项\分数规划.md -->


<h1 id="分数规划"><a href="#分数规划" class="headerlink" title="分数规划"></a>分数规划</h1><h1 id="问题形式"><a href="#问题形式" class="headerlink" title="问题形式"></a>问题形式</h1><p>给定n个数据，每个数据有(a,b)两个值，并且没有负数，从其中选出k组数据，使它的 $\frac{\sum{a_i}}{\sum{b_i}}$ 最大。</p>
<h1 id="一般方法"><a href="#一般方法" class="headerlink" title="一般方法"></a>一般方法</h1><p>二分答案法：枚举答案 $x$ ，计算前k大的 $a_i-x\cdot b_i$，计算其和是否大于等于0</p>
<h1 id="与其他问题的结合"><a href="#与其他问题的结合" class="headerlink" title="与其他问题的结合"></a>与其他问题的结合</h1><ol>
<li><p>与01背包问题结合：[P4377 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4377">USACO18OPEN] Talent Show G - 洛谷</a></p>
<p> 保证总重量必须大于等于 $W$ 的最优解：将 $W+1,W+2,…W+w_i$ 所有情况的最优解存于 $dp[W]$ 中</p>
</li>
<li><p>与最小生成树结合： <a target="_blank" rel="noopener" href="http://poj.org/problem?id=2728">2728 – Desert King</a></p>
</li>
<li><p>与图上问题结合：[P3199 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3199">HNOI2009] 最小圈 - 洛谷</a></p>
</li>
<li><p>与树上背包结合：[P4322 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4322">JSOI2016] 最佳团体 - 洛谷</a></p>
</li>
</ol>
<!-- From: 杂项\康托展开、约瑟夫环、完美洗牌_.md -->


<h1 id="康托展开、约瑟夫环、完美洗牌"><a href="#康托展开、约瑟夫环、完美洗牌" class="headerlink" title="康托展开、约瑟夫环、完美洗牌_"></a>康托展开、约瑟夫环、完美洗牌_</h1><h1 id="康托展开"><a href="#康托展开" class="headerlink" title="康托展开"></a>康托展开</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>对于一个n大小排列 ${p}$，求它在所有n排列中的字典序大小</p>
<h2 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h2><p>对于当前位置 $i$，计算有哪些数字 $x$，满足 $x$ 小于当前数字并且没有在位置 $0 \textasciitilde i-1$ 出现过的数字的个数 $cnt$，将排名加上 $cnt\cdot (n-i)!$，最终得到的结果为该排列的大小（从0开始计数），用树状数组来区间求和</p>
<h2 id="逆康托展开"><a href="#逆康托展开" class="headerlink" title="逆康托展开"></a>逆康托展开</h2><p>对于给定的排列 ${p }$ ，求比它大 $m$ 的排列是多少</p>
<ol>
<li><p>求出排列 ${p }$ 的排名，使用阶乘进制表示（$rnk[i]$ 位置权值为 $n - i$），然后加上 $m$，再转换为阶乘进制表示：</p>
<p> 先将 $m$ 加到第 $n$ 位上，然后看它除以 $1$ 是否不为 $0$，否则将该为模 $n-i+1$，并且进位 $m&#x2F;(n-i+1)$，得到进制表示</p>
</li>
<li><p>使用线段树，求出当前位置的数字：如果当前位置进制位为 $x$，则找出一个未使用的数字 $y$，它之前未使用过的数字刚好为 $x$ 个，填入该排列</p>
</li>
</ol>
<h1 id="约瑟夫环问题"><a href="#约瑟夫环问题" class="headerlink" title="约瑟夫环问题"></a>约瑟夫环问题</h1><p>假设当前有 $n$ 个节点，在某一时刻，$x$ 位置的节点被杀死，那么对于 $x+1,x+2,…,n,1,2,…,x-1$ 会重新编号 $1,2,…,n-1$，有公式 $old&#x3D;(new+x-1)\mod n+1$ ，$old$，$new$ 含义为对于新位置 $new$，它在上一轮中的编号是 $old$</p>
<p>每数 $k$ 次杀一个节点，如何找到 $k$ 与 $x$ 的关系： $x&#x3D;(k-1)\mod n+1$</p>
<p>带回原式：$old&#x3D;(new+(k-1)\mod n)\mod n+1&#x3D;(new+k-1)\mod n+1$</p>
<div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2025-11-03 15:29:17&quot;}" hidden></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="eysikinge@gmail.com">Eysiking</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://lineagestar.github.io/2025/08/19/Algorithm/x/">http://lineagestar.github.io/2025/08/19/Algorithm/x/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Note/">Note</a></div><div class="post-share"><div class="social-share" data-image="https://eysiking-photo.oss-cn-hangzhou.aliyuncs.com/img/57.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/08/19/Algorithm/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB/" title="线段树分治"><img class="cover" src="https://eysiking-photo.oss-cn-hangzhou.aliyuncs.com/img/57.jpg" onerror="onerror=null;src='https://eysiking-photo.oss-cn-hangzhou.aliyuncs.com/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">线段树分治</div></div><div class="info-2"><div class="info-item-1">线段树和离线算法的结合。假如你需要维护一些信息，这些信息会在某一个时间段内出现，要求在离线的前提下回答某一个时刻的信息并，则可以考虑使用线段树分治的技巧。 回顾线段树内容，假如需要维护一个时间轴上的操作，对这个时间轴建立线段树，把在某一时间段生效的操作挂在线段树节点上，在到达当前节点时，添加该节点上保存的操作；在离开该节点时，对于图的连通性问题通常使用可撤销并查集，对于其他特殊问题，如果需要维护的数据结构空间复杂度很小，也可以直接保存操作前的状态，离开该节点时再复制回原来的状态。询问操作一般存储在线段树叶节点上。 例题 loj121...</div></div></div></a><a class="pagination-related" href="/2025/08/21/Algorithm/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB(2)/" title="线段树分治（2）"><img class="cover" src="https://eysiking-photo.oss-cn-hangzhou.aliyuncs.com/img/58.jpg" onerror="onerror=null;src='https://eysiking-photo.oss-cn-hangzhou.aliyuncs.com/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">线段树分治（2）</div></div><div class="info-2"><div class="info-item-1">上一章中介绍到使用可撤销并查集结合线段树分治可以维护图的连通性信息。由于在同一时间线段树的深度为 $O(\log q)$ ，因此可以利用直接复制的操作，如果数据结构大小为 $n$，则总的时间复杂度为 $O(nq\log q)$  CF601E 维护背包问题的 dp 数组： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105int main() &#123;  std::ios::sync_with_stdio(false);  std::cin.tie(nullptr);  int n, k;  cin &gt;&gt; n &gt;&gt; k;  std::vector&lt;Z&gt; fac(k); ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/08/17/Algorithm/SOSDP/" title="SOS-DP 详解"><img class="cover" src="https://eysiking-photo.oss-cn-hangzhou.aliyuncs.com/img/55.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-17</div><div class="info-item-2">SOS-DP 详解</div></div><div class="info-2"><div class="info-item-1">简介SOS-DP，英文名 Sum over Subsets(SOS) dynamic programming，即子集和DP，用来求某一集合的所有子集对应状态之和。 给定一个含 $2^N$ 个元素的集合 $A$，下标用 $i$ 来表示，求一个 $F_{state}$，对应为：$$F_{state}&#x3D;\sum_{i\subseteq state &#x2F; i \text{&amp;} state &#x3D; state}A[i]$$ 解法： Bruteforce1234567for (int mask = 0; mask &lt; (1 &lt;&lt; N); mask++) &#123;	for (int i = 0; i &lt; (1 &lt;&lt; N); i++) &#123;		if ((mask &amp; i) == i) &#123;			F[mask] += A[i];		&#125;	&#125;&#125;  对于每个 $mask$，暴力枚举哪些状态为它的子集，时间复杂度 $O(4^N)$  Suboptimal...</div></div></div></a><a class="pagination-related" href="/2025/08/19/Algorithm/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%92%8C%E5%8F%AF%E6%92%A4%E9%94%80%E5%B9%B6%E6%9F%A5%E9%9B%86/" title="可持久化并查集和可撤销并查集"><img class="cover" src="https://eysiking-photo.oss-cn-hangzhou.aliyuncs.com/img/56.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-19</div><div class="info-item-2">可持久化并查集和可撤销并查集</div></div><div class="info-2"><div class="info-item-1">可持久化并查集可以查询任意版本的并查集，本质就是可持久化数组，将 $f$ 数组与 $siz$ 可持久化 为了减少每次合并操作的修改元素数量，只做按秩合并，不做路径压缩。假设要合并 $a$ 所在元素集合和 $b$ 所在元素集合，集合代表节点和集合大小分别为 $f_a,siz_a,f_b,siz_b(siz_a&gt;siz_b)$，这样每次合并的操作就只有  $f[f_b]&#x3D;f_a  $ $siz[f_a]&#x3D;siz_a+siz_b$  只需进行两次操作，大大减小了操作量，并且由于启发式合并，每次查询操作也只会跳转 $O(\log n)$ 次。 可撤销并查集可以按照FIFO回滚所做操作，用一个栈来存储当前版本修改了哪些信息，以便回退到它上一个版本。 由于只维护了两个集合代表节点在合并时的相关信息，同样不能做路径压缩 模板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758struct DSU...</div></div></div></a><a class="pagination-related" href="/2025/08/21/Algorithm/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB(2)/" title="线段树分治（2）"><img class="cover" src="https://eysiking-photo.oss-cn-hangzhou.aliyuncs.com/img/58.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-21</div><div class="info-item-2">线段树分治（2）</div></div><div class="info-2"><div class="info-item-1">上一章中介绍到使用可撤销并查集结合线段树分治可以维护图的连通性信息。由于在同一时间线段树的深度为 $O(\log q)$ ，因此可以利用直接复制的操作，如果数据结构大小为 $n$，则总的时间复杂度为 $O(nq\log q)$  CF601E 维护背包问题的 dp 数组： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105int main() &#123;  std::ios::sync_with_stdio(false);  std::cin.tie(nullptr);  int n, k;  cin &gt;&gt; n &gt;&gt; k;  std::vector&lt;Z&gt; fac(k); ...</div></div></div></a><a class="pagination-related" href="/2025/08/19/Algorithm/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB/" title="线段树分治"><img class="cover" src="https://eysiking-photo.oss-cn-hangzhou.aliyuncs.com/img/57.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-19</div><div class="info-item-2">线段树分治</div></div><div class="info-2"><div class="info-item-1">线段树和离线算法的结合。假如你需要维护一些信息，这些信息会在某一个时间段内出现，要求在离线的前提下回答某一个时刻的信息并，则可以考虑使用线段树分治的技巧。 回顾线段树内容，假如需要维护一个时间轴上的操作，对这个时间轴建立线段树，把在某一时间段生效的操作挂在线段树节点上，在到达当前节点时，添加该节点上保存的操作；在离开该节点时，对于图的连通性问题通常使用可撤销并查集，对于其他特殊问题，如果需要维护的数据结构空间复杂度很小，也可以直接保存操作前的状态，离开该节点时再复制回原来的状态。询问操作一般存储在线段树叶节点上。 例题 loj121...</div></div></div></a><a class="pagination-related" href="/2025/08/23/Algorithm/Math/FFT/" title="快速傅里叶变换"><img class="cover" src="https://eysiking-photo.oss-cn-hangzhou.aliyuncs.com/img/59.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-23</div><div class="info-item-2">快速傅里叶变换</div></div><div class="info-2"><div class="info-item-1">复数</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://eysiking-photo.oss-cn-hangzhou.aliyuncs.com/img/aili.png" onerror="this.onerror=null;this.src='https://eysiking-photo.oss-cn-hangzhou.aliyuncs.com/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Eysiking</div><div class="author-info-description">Eysiking's Persional Blog</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/LineageStar"><i class="fab fa-github"></i><span>GitHub</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/LineageStar" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://eysikinge@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">Updating...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#DP"><span class="toc-number">1.</span> <span class="toc-text">DP</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">解法：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bruteforce"><span class="toc-number">3.0.0.1.</span> <span class="toc-text">Bruteforce</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Suboptimal-Solution"><span class="toc-number">3.0.0.2.</span> <span class="toc-text">Suboptimal Solution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SoS-Dynamic-Programming-solution"><span class="toc-number">3.0.0.3.</span> <span class="toc-text">SoS Dynamic Programming solution</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">例题：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%B0%9D%E8%AF%95%E5%92%8C%E7%8A%B6%E6%80%81%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.</span> <span class="toc-text">优化尝试和状态设计</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">6.</span> <span class="toc-text">可持久化并查集</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E6%92%A4%E9%94%80%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">7.</span> <span class="toc-text">可撤销并查集</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">8.</span> <span class="toc-text">例题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E4%BD%8DDP"><span class="toc-number">9.</span> <span class="toc-text">数位DP</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-1"><span class="toc-number">10.</span> <span class="toc-text">例题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7DP"><span class="toc-number">11.</span> <span class="toc-text">线性DP</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-2"><span class="toc-number">12.</span> <span class="toc-text">例题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-3"><span class="toc-number">13.</span> <span class="toc-text">例题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Math"><span class="toc-number">14.</span> <span class="toc-text">Math</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0"><span class="toc-number">15.</span> <span class="toc-text">多项式与生成函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F"><span class="toc-number">16.</span> <span class="toc-text">多项式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%A2%E5%BC%8F%EF%BC%9A"><span class="toc-number">16.1.</span> <span class="toc-text">形式：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0"><span class="toc-number">17.</span> <span class="toc-text">生成函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E5%BD%A2%E5%BC%8F%EF%BC%9A-F-x-sum-n-a-nk-n-x"><span class="toc-number">17.1.</span> <span class="toc-text">一般形式：$F(x)&#x3D;\sum_n  a_nk_n(x) $</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%87%E6%95%B0%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0"><span class="toc-number">18.</span> <span class="toc-text">指数生成函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BD%A2%E5%BC%8F"><span class="toc-number">19.</span> <span class="toc-text">形式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97"><span class="toc-number">20.</span> <span class="toc-text">加减运算</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97%EF%BC%88%E5%8D%B7%E7%A7%AF%EF%BC%89"><span class="toc-number">21.</span> <span class="toc-text">乘法运算（卷积）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E5%BD%A2%E5%BC%8F"><span class="toc-number">22.</span> <span class="toc-text">例题形式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0"><span class="toc-number">23.</span> <span class="toc-text">普通生成函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">24.</span> <span class="toc-text">加法运算</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97%EF%BC%88%E5%8D%B7%E7%A7%AF%EF%BC%89-1"><span class="toc-number">25.</span> <span class="toc-text">乘法运算（卷积）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E5%BD%A2%E5%BC%8F-1"><span class="toc-number">26.</span> <span class="toc-text">例题形式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0"><span class="toc-number">27.</span> <span class="toc-text">狄利克雷生成函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BD%A2%E5%BC%8F-1"><span class="toc-number">28.</span> <span class="toc-text">形式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">29.</span> <span class="toc-text">乘法运算</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0"><span class="toc-number">30.</span> <span class="toc-text">积性函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="toc-number">31.</span> <span class="toc-text">欧拉函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0"><span class="toc-number">32.</span> <span class="toc-text">莫比乌斯函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF"><span class="toc-number">33.</span> <span class="toc-text">狄利克雷卷积</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">34.</span> <span class="toc-text">生成函数的应用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80%E5%BC%8F"><span class="toc-number">35.</span> <span class="toc-text">泰勒展开式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%89%E7%A9%B7%E5%BA%8F%E5%88%97%E7%9A%84%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0"><span class="toc-number">36.</span> <span class="toc-text">有穷序列的生成函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%BF%E4%B9%89%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86"><span class="toc-number">37.</span> <span class="toc-text">广义二项式定理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Catalan%E6%95%B0"><span class="toc-number">38.</span> <span class="toc-text">Catalan数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Catalan%E6%95%B0%E5%9F%BA%E7%A1%80"><span class="toc-number">39.</span> <span class="toc-text">Catalan数基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F"><span class="toc-number">39.1.</span> <span class="toc-text">数学公式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9E%8B"><span class="toc-number">39.2.</span> <span class="toc-text">基本模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">40.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5%E5%88%86%E6%9E%90"><span class="toc-number">41.</span> <span class="toc-text">使用情况分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Euler%E5%87%BD%E6%95%B0"><span class="toc-number">42.</span> <span class="toc-text">Euler函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E8%AE%BA"><span class="toc-number">43.</span> <span class="toc-text">数论</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86CRT"><span class="toc-number">44.</span> <span class="toc-text">中国剩余定理CRT</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B1%82%E8%A7%A3"><span class="toc-number">45.</span> <span class="toc-text">求解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4"><span class="toc-number">46.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%81%E6%98%8E"><span class="toc-number">47.</span> <span class="toc-text">证明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86EXCRT"><span class="toc-number">48.</span> <span class="toc-text">扩展中国剩余定理EXCRT</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83Inv"><span class="toc-number">49.</span> <span class="toc-text">乘法逆元Inv</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">50.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">51.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E8%AE%BA%E5%88%86%E5%9D%97"><span class="toc-number">52.</span> <span class="toc-text">数论分块</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95"><span class="toc-number">53.</span> <span class="toc-text">类欧几里得算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">53.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%85%A5"><span class="toc-number">53.2.</span> <span class="toc-text">引入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95"><span class="toc-number">53.3.</span> <span class="toc-text">扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E5%AF%BC-g"><span class="toc-number">53.3.1.</span> <span class="toc-text">推导 g</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E5%AF%BC-h"><span class="toc-number">53.3.2.</span> <span class="toc-text">推导 h</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0%E4%B8%8E%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94"><span class="toc-number">54.</span> <span class="toc-text">莫比乌斯函数与莫比乌斯反演</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0"><span class="toc-number">55.</span> <span class="toc-text">线性代数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%9F%BA"><span class="toc-number">56.</span> <span class="toc-text">线性基</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E6%88%96%E7%A9%BA%E9%97%B4%E7%BA%BF%E6%80%A7%E5%9F%BA"><span class="toc-number">57.</span> <span class="toc-text">异或空间线性基</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%B1%82%E7%BA%BF%E6%80%A7%E5%9F%BA"><span class="toc-number">58.</span> <span class="toc-text">高斯消元求线性基</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4%E7%BA%BF%E6%80%A7%E5%9F%BA"><span class="toc-number">59.</span> <span class="toc-text">向量空间线性基</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83"><span class="toc-number">60.</span> <span class="toc-text">高斯消元</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E8%A7%A3%E5%8A%A0%E6%B3%95%E6%96%B9%E7%A8%8B%E7%BB%84"><span class="toc-number">61.</span> <span class="toc-text">高斯消元解加法方程组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%B3%95%E8%A7%A3%E5%BC%82%E6%88%96%E6%96%B9%E7%A8%8B%E7%BB%84"><span class="toc-number">62.</span> <span class="toc-text">高斯消元法解异或方程组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E8%A7%A3%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E7%BB%84"><span class="toc-number">63.</span> <span class="toc-text">高斯消元解同余方程组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E5%90%88"><span class="toc-number">64.</span> <span class="toc-text">组合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86%E5%92%8C%E5%8F%8D%E6%BC%94"><span class="toc-number">65.</span> <span class="toc-text">二项式定理和反演_</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">66.</span> <span class="toc-text">基础</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94"><span class="toc-number">67.</span> <span class="toc-text">二项式反演</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%81%E6%98%8E-1"><span class="toc-number">68.</span> <span class="toc-text">证明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-4"><span class="toc-number">69.</span> <span class="toc-text">例题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%9A%E5%BC%88%E8%AE%BA"><span class="toc-number">70.</span> <span class="toc-text">博弈论</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E8%AE%BA"><span class="toc-number">71.</span> <span class="toc-text">图论</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E4%B8%93%E9%A2%98"><span class="toc-number">72.</span> <span class="toc-text">图专题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%99%E4%BA%BA%E6%8E%8C%E6%A0%91"><span class="toc-number">73.</span> <span class="toc-text">仙人掌树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="toc-number">74.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">75.</span> <span class="toc-text">模板</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8C%E4%BD%99%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-number">76.</span> <span class="toc-text">同余最短路</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%BD%A2%E5%BC%8F%EF%BC%9A"><span class="toc-number">77.</span> <span class="toc-text">问题形式：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1"><span class="toc-number">78.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8"><span class="toc-number">79.</span> <span class="toc-text">性质</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-5"><span class="toc-number">80.</span> <span class="toc-text">例题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9E%E9%80%9A%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">81.</span> <span class="toc-text">连通性问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%B2%E7%82%B9%E5%92%8C%E6%A1%A5"><span class="toc-number">82.</span> <span class="toc-text">割点和桥</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%B2%E7%82%B9"><span class="toc-number">83.</span> <span class="toc-text">割点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%B2%E8%BE%B9%EF%BC%88%E6%97%A0%E9%87%8D%E8%BE%B9%E6%97%B6%EF%BC%89"><span class="toc-number">84.</span> <span class="toc-text">割边（无重边时）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B"><span class="toc-number">84.0.1.</span> <span class="toc-text">过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%B2%E8%BE%B9%EF%BC%88%E6%9C%89%E9%87%8D%E8%BE%B9%E6%97%B6%EF%BC%89"><span class="toc-number">85.</span> <span class="toc-text">割边（有重边时）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B-1"><span class="toc-number">85.0.1.</span> <span class="toc-text">过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%86%E6%96%B9%E6%A0%91"><span class="toc-number">86.</span> <span class="toc-text">圆方树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-1"><span class="toc-number">87.</span> <span class="toc-text">模板</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-3"><span class="toc-number">88.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B-2"><span class="toc-number">89.</span> <span class="toc-text">过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-6"><span class="toc-number">90.</span> <span class="toc-text">例题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="toc-number">91.</span> <span class="toc-text">无向图的双连通分量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-4"><span class="toc-number">92.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DFS-%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">93.</span> <span class="toc-text">DFS 生成树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-2"><span class="toc-number">94.</span> <span class="toc-text">模板</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#V-DCC"><span class="toc-number">94.1.</span> <span class="toc-text">V-DCC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#E-DCC"><span class="toc-number">94.2.</span> <span class="toc-text">E-DCC</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F-SCC"><span class="toc-number">95.</span> <span class="toc-text">有向图的强连通分量 SCC</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DFS-%E7%94%9F%E6%88%90%E6%A0%91-1"><span class="toc-number">96.</span> <span class="toc-text">DFS 生成树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Tarjan-%E7%AE%97%E6%B3%95%E6%B1%82%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="toc-number">97.</span> <span class="toc-text">Tarjan 算法求强连通分量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E9%87%8F%E6%A0%87%E5%8F%B7%E5%92%8C%E6%8B%93%E6%89%91%E5%BA%8F%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">98.</span> <span class="toc-text">分量标号和拓扑序的关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kruskal%E9%87%8D%E6%9E%84%E6%A0%91"><span class="toc-number">99.</span> <span class="toc-text">Kruskal重构树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-number">100.</span> <span class="toc-text">流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E9%97%AE%E9%A2%98"><span class="toc-number">101.</span> <span class="toc-text">适用问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-7"><span class="toc-number">102.</span> <span class="toc-text">例题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91%E4%B8%93%E9%A2%98"><span class="toc-number">103.</span> <span class="toc-text">树专题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%8E%AF%E6%A0%91%EF%BC%88pseudotree%EF%BC%89"><span class="toc-number">104.</span> <span class="toc-text">基环树（pseudotree）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-5"><span class="toc-number">105.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8-1"><span class="toc-number">106.</span> <span class="toc-text">性质</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6%EF%BC%88dsu-on-tree%EF%BC%89"><span class="toc-number">107.</span> <span class="toc-text">树上启发式合并（dsu on tree）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">108.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B-3"><span class="toc-number">109.</span> <span class="toc-text">过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-8"><span class="toc-number">110.</span> <span class="toc-text">例题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91%E6%A8%A1%E6%9D%BF"><span class="toc-number">111.</span> <span class="toc-text">树模板</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86"><span class="toc-number">112.</span> <span class="toc-text">树链剖分</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E9%93%BE%E5%89%96%E5%88%86"><span class="toc-number">113.</span> <span class="toc-text">重链剖分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">113.1.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E6%A0%91"><span class="toc-number">114.</span> <span class="toc-text">虚树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-3"><span class="toc-number">115.</span> <span class="toc-text">模板</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BB%BA%E6%A0%91%E6%96%B9%E5%BC%8F"><span class="toc-number">116.</span> <span class="toc-text">建树方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%B5%81"><span class="toc-number">117.</span> <span class="toc-text">网络流</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%B5%81"><span class="toc-number">118.</span> <span class="toc-text">最大流_</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ford-Fulkerson-%E6%96%B9%E6%B3%95"><span class="toc-number">119.</span> <span class="toc-text">Ford-Fulkerson 方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#EK-%E7%AE%97%E6%B3%95-O-V-E-2"><span class="toc-number">120.</span> <span class="toc-text">EK 算法 $O(|V||E|^2)$</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Dinic-%E7%AE%97%E6%B3%95-O-V-2-E"><span class="toc-number">121.</span> <span class="toc-text">Dinic 算法 $O(|V|^2|E|)$</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ISAP%E7%AE%97%E6%B3%95%EF%BC%88%E4%BC%98%E5%8C%96%E7%9A%84Dinic%EF%BC%89"><span class="toc-number">122.</span> <span class="toc-text">ISAP算法（优化的Dinic）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%B5%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">123.</span> <span class="toc-text">网络流基本概念_</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">124.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">125.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">126.</span> <span class="toc-text">可持久化数据结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96Trie"><span class="toc-number">127.</span> <span class="toc-text">可持久化Trie</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%92%8C%E5%8F%AF%E6%92%A4%E9%94%80%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">128.</span> <span class="toc-text">可持久化并查集和可撤销并查集</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E5%B9%B6%E6%9F%A5%E9%9B%86-1"><span class="toc-number">129.</span> <span class="toc-text">可持久化并查集</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E6%92%A4%E9%94%80%E5%B9%B6%E6%9F%A5%E9%9B%86-1"><span class="toc-number">130.</span> <span class="toc-text">可撤销并查集</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-9"><span class="toc-number">131.</span> <span class="toc-text">例题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">132.</span> <span class="toc-text">可持久化线段树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9%EF%BC%8C%E5%8D%95%E7%82%B9%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%88%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E7%BB%84%EF%BC%89"><span class="toc-number">133.</span> <span class="toc-text">单点修改，单点查询的可持久化线段树（可持久化数组）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9%EF%BC%8C%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">134.</span> <span class="toc-text">单点修改，区间查询的可持久化线段树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%EF%BC%8C%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">135.</span> <span class="toc-text">区间修改，区间查询的可持久化线段树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B0%B8%E4%B9%85%E5%8C%96"><span class="toc-number">136.</span> <span class="toc-text">*标记永久化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AVL%E6%A0%91%EF%BC%88%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89"><span class="toc-number">137.</span> <span class="toc-text">AVL树（平衡搜索二叉树）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">138.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AVL%E6%A0%91"><span class="toc-number">139.</span> <span class="toc-text">AVL树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="toc-number">140.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%A6%E6%97%8B%E5%92%8C%E5%8F%B3%E6%97%8B"><span class="toc-number">141.</span> <span class="toc-text">左旋和右旋</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LL%E5%9E%8B%E5%92%8CRR%E5%9E%8B"><span class="toc-number">141.1.</span> <span class="toc-text">LL型和RR型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LR%E5%9E%8B%E5%92%8CRL%E5%9E%8B"><span class="toc-number">141.2.</span> <span class="toc-text">LR型和RL型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">142.</span> <span class="toc-text">插入和删除</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-STL%EF%BC%9Apbds%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="toc-number">143.</span> <span class="toc-text">C++STL：pbds平衡树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%BD%A2%E5%8F%82"><span class="toc-number">143.1.</span> <span class="toc-text">模板形参</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E5%BC%8F"><span class="toc-number">143.2.</span> <span class="toc-text">构造方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">143.3.</span> <span class="toc-text">成员函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#P3369-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%99%AE%E9%80%9A%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="toc-number">144.</span> <span class="toc-text">P3369 【模板】普通平衡树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-number">144.1.</span> <span class="toc-text">题目描述</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E8%A1%A8"><span class="toc-number">145.</span> <span class="toc-text">有序表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E8%A1%A8-1"><span class="toc-number">146.</span> <span class="toc-text">有序表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">147.</span> <span class="toc-text">通用接口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LCT"><span class="toc-number">148.</span> <span class="toc-text">LCT</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%A0%91%E9%97%AE%E9%A2%98"><span class="toc-number">149.</span> <span class="toc-text">动态树问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E9%93%BE%E5%89%96%E5%88%86"><span class="toc-number">150.</span> <span class="toc-text">实链剖分</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LCT-1"><span class="toc-number">151.</span> <span class="toc-text">LCT</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-4"><span class="toc-number">152.</span> <span class="toc-text">模板</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Splay"><span class="toc-number">153.</span> <span class="toc-text">Splay</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#splay%E6%93%8D%E4%BD%9C"><span class="toc-number">154.</span> <span class="toc-text">splay操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#zig"><span class="toc-number">154.1.</span> <span class="toc-text">zig</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zig-zig"><span class="toc-number">154.2.</span> <span class="toc-text">zig-zig</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zig-zag"><span class="toc-number">154.3.</span> <span class="toc-text">zig-zag</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">155.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91%EF%BC%8C%E6%97%8B%E8%BD%ACTreap%EF%BC%8CFHQ-Treap"><span class="toc-number">156.</span> <span class="toc-text">笛卡尔树，旋转Treap，FHQ Treap</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91"><span class="toc-number">157.</span> <span class="toc-text">笛卡尔树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%85%A5-1"><span class="toc-number">157.1.</span> <span class="toc-text">引入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B-1"><span class="toc-number">157.2.</span> <span class="toc-text">流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%8B%E8%BD%ACTreap"><span class="toc-number">158.</span> <span class="toc-text">旋转Treap</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A0%E6%97%8BTreap%EF%BC%88FHQ-Treap%EF%BC%89"><span class="toc-number">159.</span> <span class="toc-text">无旋Treap（FHQ Treap）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E8%A3%82-split-%E6%93%8D%E4%BD%9C"><span class="toc-number">159.1.</span> <span class="toc-text">分裂 split 操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E5%80%BC%E5%88%86%E8%A3%82"><span class="toc-number">159.1.1.</span> <span class="toc-text">按值分裂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E6%8E%92%E5%90%8D%E5%88%86%E8%A3%82%EF%BC%88%E6%97%A0%E8%AF%8D%E9%A2%91%E5%8E%8B%E7%BC%A9%EF%BC%89"><span class="toc-number">159.1.2.</span> <span class="toc-text">按排名分裂（无词频压缩）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6-merge-%E6%93%8D%E4%BD%9C"><span class="toc-number">159.2.</span> <span class="toc-text">合并 merge 操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E8%89%BA%E6%A0%91"><span class="toc-number">160.</span> <span class="toc-text">文艺树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8"><span class="toc-number">161.</span> <span class="toc-text">跳表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-5"><span class="toc-number">162.</span> <span class="toc-text">模板</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">163.</span> <span class="toc-text">线段树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9%EF%BC%8C%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2"><span class="toc-number">164.</span> <span class="toc-text">单点修改，区间查询</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%EF%BC%8C%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2"><span class="toc-number">165.</span> <span class="toc-text">区间修改，区间查询</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">166.</span> <span class="toc-text">动态开点线段树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%89%E5%A6%82%E4%B8%80%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">167.</span> <span class="toc-text">吉如一线段树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB"><span class="toc-number">168.</span> <span class="toc-text">线段树分治</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-10"><span class="toc-number">169.</span> <span class="toc-text">例题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%8E%AB%E9%98%9F"><span class="toc-number">170.</span> <span class="toc-text">莫队</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95"><span class="toc-number">171.</span> <span class="toc-text">普通莫队算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B-4"><span class="toc-number">171.1.</span> <span class="toc-text">过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">171.2.</span> <span class="toc-text">排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">171.3.</span> <span class="toc-text">复杂度分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E8%8E%AB%E9%98%9F%E4%BC%98%E5%8C%96"><span class="toc-number">171.3.1.</span> <span class="toc-text">普通莫队优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%A6%E4%BF%AE%E6%94%B9%E7%9A%84%E8%8E%AB%E9%98%9F"><span class="toc-number">172.</span> <span class="toc-text">带修改的莫队</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BC%98%E5%9D%97%E9%95%BF"><span class="toc-number">172.1.</span> <span class="toc-text">最优块长</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%82%E9%A1%B9"><span class="toc-number">173.</span> <span class="toc-text">杂项</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%9D%97%E4%B8%93%E9%A2%98"><span class="toc-number">174.</span> <span class="toc-text">分块专题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%9D%97%E7%8A%B6%E6%95%B0%E7%BB%84-%E5%9D%97%E7%8A%B6%E9%93%BE%E8%A1%A8"><span class="toc-number">175.</span> <span class="toc-text">1.块状数组 块状链表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92"><span class="toc-number">176.</span> <span class="toc-text">分数规划</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%BD%A2%E5%BC%8F"><span class="toc-number">177.</span> <span class="toc-text">问题形式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E6%96%B9%E6%B3%95"><span class="toc-number">178.</span> <span class="toc-text">一般方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98%E7%9A%84%E7%BB%93%E5%90%88"><span class="toc-number">179.</span> <span class="toc-text">与其他问题的结合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80%E3%80%81%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E3%80%81%E5%AE%8C%E7%BE%8E%E6%B4%97%E7%89%8C"><span class="toc-number">180.</span> <span class="toc-text">康托展开、约瑟夫环、完美洗牌_</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80"><span class="toc-number">181.</span> <span class="toc-text">康托展开</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-number">181.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%82%E6%B3%95"><span class="toc-number">181.2.</span> <span class="toc-text">求法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%86%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80"><span class="toc-number">181.3.</span> <span class="toc-text">逆康托展开</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98"><span class="toc-number">182.</span> <span class="toc-text">约瑟夫环问题</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/19/Algorithm/x/" title="Temp"><img src="https://eysiking-photo.oss-cn-hangzhou.aliyuncs.com/img/57.jpg" onerror="this.onerror=null;this.src='https://eysiking-photo.oss-cn-hangzhou.aliyuncs.com/img/404.jpg'" alt="Temp"/></a><div class="content"><a class="title" href="/2025/08/19/Algorithm/x/" title="Temp">Temp</a><time datetime="2025-11-03T07:29:17.654Z" title="Updated 2025-11-03 15:29:17">2025-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/21/Algorithm/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB(2)/" title="线段树分治（2）"><img src="https://eysiking-photo.oss-cn-hangzhou.aliyuncs.com/img/58.jpg" onerror="this.onerror=null;this.src='https://eysiking-photo.oss-cn-hangzhou.aliyuncs.com/img/404.jpg'" alt="线段树分治（2）"/></a><div class="content"><a class="title" href="/2025/08/21/Algorithm/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB(2)/" title="线段树分治（2）">线段树分治（2）</a><time datetime="2025-09-03T01:44:01.891Z" title="Updated 2025-09-03 09:44:01">2025-09-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/17/Algorithm/SOSDP/" title="SOS-DP 详解"><img src="https://eysiking-photo.oss-cn-hangzhou.aliyuncs.com/img/55.jpg" onerror="this.onerror=null;this.src='https://eysiking-photo.oss-cn-hangzhou.aliyuncs.com/img/404.jpg'" alt="SOS-DP 详解"/></a><div class="content"><a class="title" href="/2025/08/17/Algorithm/SOSDP/" title="SOS-DP 详解">SOS-DP 详解</a><time datetime="2025-09-01T13:26:34.187Z" title="Updated 2025-09-01 21:26:34">2025-09-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/23/Algorithm/Math/FFT/" title="快速傅里叶变换"><img src="https://eysiking-photo.oss-cn-hangzhou.aliyuncs.com/img/59.jpg" onerror="this.onerror=null;this.src='https://eysiking-photo.oss-cn-hangzhou.aliyuncs.com/img/404.jpg'" alt="快速傅里叶变换"/></a><div class="content"><a class="title" href="/2025/08/23/Algorithm/Math/FFT/" title="快速傅里叶变换">快速傅里叶变换</a><time datetime="2025-09-01T13:04:18.289Z" title="Updated 2025-09-01 21:04:18">2025-09-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/19/Algorithm/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB/" title="线段树分治"><img src="https://eysiking-photo.oss-cn-hangzhou.aliyuncs.com/img/57.jpg" onerror="this.onerror=null;this.src='https://eysiking-photo.oss-cn-hangzhou.aliyuncs.com/img/404.jpg'" alt="线段树分治"/></a><div class="content"><a class="title" href="/2025/08/19/Algorithm/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB/" title="线段树分治">线段树分治</a><time datetime="2025-08-21T06:53:26.712Z" title="Updated 2025-08-21 14:53:26">2025-08-21</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://eysiking-photo.oss-cn-hangzhou.aliyuncs.com/img/57.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Eysiking</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://lineagestar.github.io">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'NoBorder Dark' : 'NoBorder Light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'LineageStar/Eysiking-s-personal-blog',
      'data-repo-id': 'R_kgDONIZRMA',
      'data-category-id': 'DIC_kwDONIZRMM4Cj37c',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !true) {
    if (true) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script async data-pjax src="https://cdn.jsdelivr.net/gh/Pil0tXia/busuanzi-modified/busuanzi.pure.mini.js"></script></div></body></html>